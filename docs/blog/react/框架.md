# react 工具教程

## react-toolkit

### 入门使用

1. 安装依赖
2. 创建分片
3. 创建redux
4. redux提供给react并且复制给store
5. 应用中使用获取/分发

``` javascript
npm i @redux-toolkit react-redux //#1

const counterStore = createSlice({  //#2
    name:'counter',
    initialState:{
        count:0
    },
    reducers:{
        add(state,action){
            state.count+= action.payload
        },
        reducer(state,action){
            state.count-= action.payload
        },
    },
})
export const {add,reducer} = counterStore.actions; //导出actions
export default counterStore.reducer;

export default configureStore({ //#3
    reducer:{
        counterStore,
        channelStore
    },
})

ReactDOM.createRoot(document.getElementById('root')).render( //#4
    <React.StrictMode>
            <Provider store={store}>
                ......
            </Provider>
  </React.StrictMode>,
)


 const dispatch = useDispatch() //#5 分发
 dispatch(add(1))
 dispatch(reducer(1))

const count = useSelector(state=>{ //获取值
  return state.counterStore.count
 })

```

### redux-persist 持久化

1. 安装redux-persist
2. 把所有的combineReducers
3. 配置persist并导出
4. dom处添加persist

``` javascript
npm i redux-persist -S //#1


import {combineReducers} from "@reduxjs/toolkit"; //#2
import counterStore from "./countStore.js";
import channelStore from "./channelStore.js";

export  default combineReducers({
    counterStore,
    channelStore
})

import {configureStore, } from "@reduxjs/toolkit"; //#3
import storage from 'redux-persist/lib/storage'
import {persistReducer, persistStore} from "redux-persist";
import rootReducer from './modules/index.js'
const persistConfig = {
    key: 'roots',
    storage,
}

const persistedReducer = persistReducer(persistConfig, rootReducer);
export  const store = configureStore({
    reducer: persistedReducer,
    middleware:(getDefaultMiddleware=>[
        ...getDefaultMiddleware({serializableCheck:false})
    ]),
});
export let persistor = persistStore(store)



ReactDOM.createRoot(document.getElementById('root')).render( //#4
    <React.StrictMode>
            <Provider store={store}>
                <PersistGate loading={null} persistor={persistor}>
                    <RouterProvider router={ router} />
                </PersistGate>
            </Provider>
  </React.StrictMode>,
)

```

## rect-router 6.0

## hooks

### useCallback

1.第一个参数回调会存储缓存
2.第二个是依赖，只有依赖变化后，回调的缓存才会变化，类似vue的computed 的method缓存一样
3.应用场景
    + 跳过组件的刷新优化
    + 从记忆中回调更新state
    + 防止平凡effect触发
    + 
``` javascript

function Child(){
    let [index,setIndex] = useState(0)
    const add = ()=>{
        setIndex(index+1);
    }
    const reducer = ()=>{
        setIndex(index-1);
    }
    const submit = useCallback(()=>{
        console.log(index)
    },[index])

    return <div>
        <button onClick={add}>+</button>
        <button>{index}</button>
        <button onClick={reducer}>-</button>
        <button onClick={submit}>test</button>
    </div>
}
```

### useMemo和React.M

1.第一个参数回调会存储缓存
2.第二个是依赖，只有依赖变化后，回调的缓存才会变化，更像vue中的computed
3.要返回一个值

``` javascript
//当count变化的时候该计算没有被重新执行 
function Child(){
    let [index,setIndex] = useState(0)
    const add = ()=>{
        setIndex(index+1);
    }
    const reducer = ()=>{
        setIndex(index-1);
    }
    const submit = useCallback(()=>{
        console.log(index)
    },[index])
    const computedCount = useMemo(()=>{
        console.log('大量计算')
        return 212222222222*1024
    },[])
    return <div>
        <button onClick={add}>+</button>
        <button>{index}</button>
        <button>{computedCount}</button>
        {/*<Meo indeex={index}></Meo>*/}
        <button onClick={reducer}>-</button>
        <button onClick={submit}>test</button>
    </div>
}
```

### useContext 和useReducer

1、一般这两个api是同时使用
2、useReducer(reducer, initialState)
3、useContext 和 createContext() 以及context.Provider配合使用

``` javascript
//ContextProvider.js
import {createContext} from "react";
import {useReducer} from "react";

export const ThemeContext = createContext();  //创建一个当前组件的的context，所有的内容传入进去
export const reducer = (state,action)=>{//创建一个reducer
    if(action.type==='change'){
        return {
            ...state,
            name:state.name+1
        }
    }
}
export const initialState = {//初始值
    name:1
}


function ContextProvider({children}) { //写一个组件
    const [state] = useReducer(reducer, initialState);
    console.log(state)
    return ( //使用provider封装，value为你需要传递的方法或者值
        <ThemeContext.Provider className="Provider" value={{state,dispatch}}> 
            {children}
        </ThemeContext.Provider>
    );
}

export default ContextProvider;

//使用

  <ContextProvider>
    <UseReduxTest />
  </ContextProvider>

  //UseReduxTest 组件内部


import {useContext} from "react";
import {ThemeContext} from "./contextProvider.jsx";
import {Button} from "antd";
function UseReduxTest() {
    const {state:{name},dispatch} = useContext(ThemeContext); //获取context，使用
    return (
        <>
          <div>{name}</div>
            <Button onClick={()=>dispatch({type:'change'})}>添加</Button>
        </>
    );
}

export default UseReduxTest;


```

### useRef
1、用来访问dom元素
2、保存状态但不触发渲染
3、保存上一次的 props 或 state

### useDeferredValue 
1、延迟加载值，比如多次输入获取最后一次的值，类似debounce
2、18支持

### useInsertionEffect 

### 


## aHook

## react-router 

### 嵌套路由

``` tsx
//router
   <Routes>
        <Route element={<Layout />}>
          <Route path="/" element={<PublicPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route
            path="/protected"
            element={
              <RequireAuth>
                <ProtectedPage />
              </RequireAuth>
            }
          />
        </Route>
      </Routes>


      ///Layout
     function Layout() {
        return (
            <div>
            <AuthStatus />

            <ul>
                <li>
                <Link to="/">Public Page</Link>
                </li>
                <li>
                <Link to="/protected">Protected Page</Link>
                </li>
            </ul>

            <Outlet />  //子路由
            </div>
        );
        }

        //main.js
        <BrowserRouter>
            <[客户端路由]/>  
        </BrowserRouter>


```

### 客户端路由

+ hashRouter
+ browserRouter
+ 基本重定向 
  + redirect  react-router-dom
  + 

``` jsx
//router.js

const router = createBrowserRouter([
  {
    id: "root",
    path: "/",
    loader() {
      // Our root route always provides the user, if logged in
      return { user: fakeAuthProvider.username };
    },
    Component: Layout,
    children: [
      {
        index: true,
        Component: PublicPage,
      },
      {
        path: "login",
        action: loginAction,
        loader: loginLoader,
        Component: LoginPage,
      },
      {
        path: "protected",
        loader: protectedLoader,
        Component: ProtectedPage,
      },
    ],
  },
  {
    path: "/logout",
    async action() {
      // We signout in a "resource route" that we can hit from a fetcher.Form
      await fakeAuthProvider.signout();
      return redirect("/");
    },
  },
]);

// main.js
 <RouterProvider router={router} fallbackElement={<p>Initial Load...</p>} />

```

