<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.js精度问题 | 翻手机壳</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.3aadf512.css" as="style"><link rel="preload" href="/blog/assets/js/app.4050c2a3.js" as="script"><link rel="preload" href="/blog/assets/js/2.c8cb3ded.js" as="script"><link rel="preload" href="/blog/assets/js/49.e0dedc3e.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.15f24462.js"><link rel="prefetch" href="/blog/assets/js/100.536bfd57.js"><link rel="prefetch" href="/blog/assets/js/101.230cc0de.js"><link rel="prefetch" href="/blog/assets/js/102.f5d6df84.js"><link rel="prefetch" href="/blog/assets/js/103.270890a3.js"><link rel="prefetch" href="/blog/assets/js/104.75daa6a2.js"><link rel="prefetch" href="/blog/assets/js/105.b75b293b.js"><link rel="prefetch" href="/blog/assets/js/106.c51f8455.js"><link rel="prefetch" href="/blog/assets/js/107.661cea79.js"><link rel="prefetch" href="/blog/assets/js/108.fe0a6852.js"><link rel="prefetch" href="/blog/assets/js/109.d4e2d59f.js"><link rel="prefetch" href="/blog/assets/js/11.1f95f5e3.js"><link rel="prefetch" href="/blog/assets/js/110.5145a28e.js"><link rel="prefetch" href="/blog/assets/js/111.5b595eca.js"><link rel="prefetch" href="/blog/assets/js/112.106917c0.js"><link rel="prefetch" href="/blog/assets/js/113.f5e09d27.js"><link rel="prefetch" href="/blog/assets/js/114.484cb0bb.js"><link rel="prefetch" href="/blog/assets/js/115.c3584979.js"><link rel="prefetch" href="/blog/assets/js/116.205c365d.js"><link rel="prefetch" href="/blog/assets/js/117.a524a0f8.js"><link rel="prefetch" href="/blog/assets/js/12.c6bbdc14.js"><link rel="prefetch" href="/blog/assets/js/13.4e940bfb.js"><link rel="prefetch" href="/blog/assets/js/14.be73f21b.js"><link rel="prefetch" href="/blog/assets/js/15.d90bd7e9.js"><link rel="prefetch" href="/blog/assets/js/16.546dc7a4.js"><link rel="prefetch" href="/blog/assets/js/17.cb49a6fc.js"><link rel="prefetch" href="/blog/assets/js/18.157f5e1d.js"><link rel="prefetch" href="/blog/assets/js/19.e242c44c.js"><link rel="prefetch" href="/blog/assets/js/20.96ae03dd.js"><link rel="prefetch" href="/blog/assets/js/21.0c023549.js"><link rel="prefetch" href="/blog/assets/js/22.8ae977ff.js"><link rel="prefetch" href="/blog/assets/js/23.be2fcb64.js"><link rel="prefetch" href="/blog/assets/js/24.213177fc.js"><link rel="prefetch" href="/blog/assets/js/25.75a908fb.js"><link rel="prefetch" href="/blog/assets/js/26.9939a4ce.js"><link rel="prefetch" href="/blog/assets/js/27.a2ae7dfc.js"><link rel="prefetch" href="/blog/assets/js/28.92f1845c.js"><link rel="prefetch" href="/blog/assets/js/29.3da89af5.js"><link rel="prefetch" href="/blog/assets/js/3.8794b010.js"><link rel="prefetch" href="/blog/assets/js/30.f535eed4.js"><link rel="prefetch" href="/blog/assets/js/31.1673f46e.js"><link rel="prefetch" href="/blog/assets/js/32.96c99bee.js"><link rel="prefetch" href="/blog/assets/js/33.cd3dc358.js"><link rel="prefetch" href="/blog/assets/js/34.36ec420a.js"><link rel="prefetch" href="/blog/assets/js/35.5e13a55d.js"><link rel="prefetch" href="/blog/assets/js/36.d3556886.js"><link rel="prefetch" href="/blog/assets/js/37.62ce75bc.js"><link rel="prefetch" href="/blog/assets/js/38.a79b824e.js"><link rel="prefetch" href="/blog/assets/js/39.f7fc7b82.js"><link rel="prefetch" href="/blog/assets/js/4.9de8a4ed.js"><link rel="prefetch" href="/blog/assets/js/40.31ab64b6.js"><link rel="prefetch" href="/blog/assets/js/41.17f746e8.js"><link rel="prefetch" href="/blog/assets/js/42.3978a488.js"><link rel="prefetch" href="/blog/assets/js/43.1857483a.js"><link rel="prefetch" href="/blog/assets/js/44.23ffc935.js"><link rel="prefetch" href="/blog/assets/js/45.def263da.js"><link rel="prefetch" href="/blog/assets/js/46.935ea449.js"><link rel="prefetch" href="/blog/assets/js/47.96fa26e0.js"><link rel="prefetch" href="/blog/assets/js/48.e7c189ab.js"><link rel="prefetch" href="/blog/assets/js/5.a434e9b9.js"><link rel="prefetch" href="/blog/assets/js/50.22ce4b63.js"><link rel="prefetch" href="/blog/assets/js/51.faee7fab.js"><link rel="prefetch" href="/blog/assets/js/52.1a9e1b2d.js"><link rel="prefetch" href="/blog/assets/js/53.cbe07eb5.js"><link rel="prefetch" href="/blog/assets/js/54.93d44330.js"><link rel="prefetch" href="/blog/assets/js/55.6eb8f4ad.js"><link rel="prefetch" href="/blog/assets/js/56.8e080dce.js"><link rel="prefetch" href="/blog/assets/js/57.dc1deda1.js"><link rel="prefetch" href="/blog/assets/js/58.7d639900.js"><link rel="prefetch" href="/blog/assets/js/59.a8971146.js"><link rel="prefetch" href="/blog/assets/js/6.5681fdb3.js"><link rel="prefetch" href="/blog/assets/js/60.d6bfbc87.js"><link rel="prefetch" href="/blog/assets/js/61.3453cb92.js"><link rel="prefetch" href="/blog/assets/js/62.e17142f0.js"><link rel="prefetch" href="/blog/assets/js/63.3fe21df4.js"><link rel="prefetch" href="/blog/assets/js/64.4894b46b.js"><link rel="prefetch" href="/blog/assets/js/65.97f1a37c.js"><link rel="prefetch" href="/blog/assets/js/66.81d72616.js"><link rel="prefetch" href="/blog/assets/js/67.f2ff3126.js"><link rel="prefetch" href="/blog/assets/js/68.a01241f8.js"><link rel="prefetch" href="/blog/assets/js/69.9a0be996.js"><link rel="prefetch" href="/blog/assets/js/7.c8654701.js"><link rel="prefetch" href="/blog/assets/js/70.d2bd1510.js"><link rel="prefetch" href="/blog/assets/js/71.6fb2df6e.js"><link rel="prefetch" href="/blog/assets/js/72.b1971a5c.js"><link rel="prefetch" href="/blog/assets/js/73.20d5af68.js"><link rel="prefetch" href="/blog/assets/js/74.847ee68c.js"><link rel="prefetch" href="/blog/assets/js/75.47577d92.js"><link rel="prefetch" href="/blog/assets/js/76.62e007c1.js"><link rel="prefetch" href="/blog/assets/js/77.82b55b00.js"><link rel="prefetch" href="/blog/assets/js/78.4138cb4b.js"><link rel="prefetch" href="/blog/assets/js/79.588f8b3a.js"><link rel="prefetch" href="/blog/assets/js/8.57dc5981.js"><link rel="prefetch" href="/blog/assets/js/80.1ddca6ee.js"><link rel="prefetch" href="/blog/assets/js/81.95a5d96d.js"><link rel="prefetch" href="/blog/assets/js/82.48556514.js"><link rel="prefetch" href="/blog/assets/js/83.092b5ce2.js"><link rel="prefetch" href="/blog/assets/js/84.2af4f564.js"><link rel="prefetch" href="/blog/assets/js/85.cf484736.js"><link rel="prefetch" href="/blog/assets/js/86.52c7d562.js"><link rel="prefetch" href="/blog/assets/js/87.717b3486.js"><link rel="prefetch" href="/blog/assets/js/88.8c437db8.js"><link rel="prefetch" href="/blog/assets/js/89.993b1549.js"><link rel="prefetch" href="/blog/assets/js/9.b2569be9.js"><link rel="prefetch" href="/blog/assets/js/90.84035085.js"><link rel="prefetch" href="/blog/assets/js/91.e2a20a1c.js"><link rel="prefetch" href="/blog/assets/js/92.0fe7013c.js"><link rel="prefetch" href="/blog/assets/js/93.a165018c.js"><link rel="prefetch" href="/blog/assets/js/94.496f4219.js"><link rel="prefetch" href="/blog/assets/js/95.2a0e5cd3.js"><link rel="prefetch" href="/blog/assets/js/96.13c14d9f.js"><link rel="prefetch" href="/blog/assets/js/97.d06cc536.js"><link rel="prefetch" href="/blog/assets/js/98.40f7d01f.js"><link rel="prefetch" href="/blog/assets/js/99.c84004ba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.3aadf512.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">翻手机壳</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/experience/request/index.html" class="nav-link">
  总结
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/experience/request/index.html" class="nav-link">
  总结
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2周面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js相关</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/interview/js/js.html" aria-current="page" class="active sidebar-link">1.js精度问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#_14-es6中新增的set、map两种数据结构怎么理解" class="sidebar-link">14.ES6中新增的Set、Map两种数据结构怎么理解?</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#" class="sidebar-link"></a></li></ul></li><li><a href="/blog/interview/js/map和weakMap.html" class="sidebar-link">map和set</a></li><li><a href="/blog/interview/js/事件循环.html" class="sidebar-link">事件循环</a></li><li><a href="/blog/interview/js/原型.html" class="sidebar-link">原型链与继承</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_1-js精度问题"><a href="#_1-js精度问题" class="header-anchor">#</a> 1.js精度问题</h3> <p>主要是因为js采用了<code>IEEE 754</code>标准，小数位只能存54位，所以有精度问题，使用big.js或者decimeal.js</p> <h3 id="_2-作用域和闭包"><a href="#_2-作用域和闭包" class="header-anchor">#</a> 2.作用域和闭包</h3> <blockquote><p>什么是作用链</p></blockquote> <p>当访问一个变量时，解释器会首先在当前作用域中查找标识符，如果没找到，就去父作用域找，直到找到该变量的标识符或没找到为止。这条寻找的链路就叫作用域链</p> <blockquote><p>什么是闭包</p></blockquote> <p>在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数当中声明的变量；当调用通过外部函数返回的内部函数时，即使此时外部函数已经执行结束，但是内部函数所引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包</p> <blockquote><p>闭包怎么产生的</p></blockquote> <p>当函数存在对其所在词法作用域的引用，而该函数被拿到当前词法作用域外执行，此时就产生了闭包。</p> <blockquote><p>在工作中，哪些地方使用到了闭包</p></blockquote> <ul><li>return 一个函数</li> <li>函数作为参数</li> <li>IIFE自执行函数</li></ul> <blockquote><p>为什么要使用闭包？/ 闭包的好处？</p></blockquote> <ul><li>保护函数的私有变量不受外部干扰。形成不销毁的栈内存</li> <li>把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li></ul> <blockquote><p>闭包变量怎么回收呢？</p></blockquote> <ul><li><p>如果是全局变量被作为闭包变量的话，则该闭包变量会一直保存到页面关闭。（因为全局上下文会一直存在，不会被回收，除非页面关闭）</p></li> <li><p>如果是局部变量被作为闭包变量的话，下面分两种情况讨论</p> <ul><li><p>立马执行时会自动回收</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token keyword">var</span> b<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
　　<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　　b<span class="token operator">++</span><span class="token punctuation">;</span>
　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11</span>
</code></pre></div></li> <li><p>不回立马被执行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        b <span class="token operator">++</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
<span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>
</code></pre></div></li></ul></li></ul> <h3 id="_3-js数据类型"><a href="#_3-js数据类型" class="header-anchor">#</a> 3.JS数据类型</h3> <ul><li><p>原始值：</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>undefined</li> <li>null</li> <li>symbol</li> <li>Bigint</li></ul></li> <li><p>引用类型</p> <ul><li>OBject</li> <li>Array</li> <li>RegExp</li> <li>Date</li> <li>Math</li> <li>Function</li></ul></li></ul> <p>主要说下bitint,bigint是Es2020出现的，主要弥补number的精度丢失的异常，再最后使用n，来标识，也可用BigInt方法来写的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token number">12312312312312n</span>
<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">12312312312312</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_4-js类型判断"><a href="#_4-js类型判断" class="header-anchor">#</a> 4.JS类型判断</h3> <ul><li>typeof</li> <li>instanceof 所有引用类型，</li> <li>Object.prototype.toString.call() 判断浏览器内置对象</li> <li>Constructor 对number和null无效</li></ul> <h3 id="_5-js的深拷贝和浅拷贝的方法"><a href="#_5-js的深拷贝和浅拷贝的方法" class="header-anchor">#</a> 5.JS的深拷贝和浅拷贝的方法</h3> <ul><li>Object.assign(目标对象,源对象)</li> <li>[...arr]</li> <li>Array.protype.concat()</li> <li>JSON.parse(JSON.stringify())</li> <li>concat</li> <li>slice</li></ul> <h3 id="_6-this的指向问题"><a href="#_6-this的指向问题" class="header-anchor">#</a> 6.this的指向问题</h3> <ul><li><p>默认调用，指向window</p></li> <li><p>对象调用，指向该对象</p></li> <li><p>做构造函数使用，指向实例对象</p></li> <li><p>箭头函数，执行函数所在的作用域</p></li> <li><p>Call,apply,bind指向传入的第一个参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">pa<span class="token punctuation">,</span>pb</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//和call差不多，但是不会执行</span>
</code></pre></div></li></ul> <h3 id="_7-js原型和原型链"><a href="#_7-js原型和原型链" class="header-anchor">#</a> 7.JS原型和原型链</h3> <blockquote><p>什么事原型对象</p></blockquote> <p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型对象，每一个对象都会从原型&quot;继承&quot;属性。</p> <blockquote><p>函数的原型和对象的原型：</p></blockquote> <ul><li><p>每个函数都有一个prototype属性，该属性指向函数的原型</p></li> <li><p>每个对象都有一个__proto__属性，该属性指向对象的原型</p></li></ul> <blockquote><p>什么是原型链</p></blockquote> <p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这条查找的路径就叫原型链</p> <h3 id="_8-js中的垃圾回收机制"><a href="#_8-js中的垃圾回收机制" class="header-anchor">#</a> 8.js中的垃圾回收机制</h3> <blockquote><p>什么是内存泄漏</p></blockquote> <p>内存是运行时操作系统分配给浏览器的内存空间，对于正在运行的内存需要及时释放，如果不及时释放，内存会越来越高，轻则影响系统性能，重则导致进程崩溃。不在使用的内存没有及时释放，就叫做内存泄漏。</p> <p>影响内存泄漏的原因</p> <ul><li>全局的声明变量，解决：使用var let、const</li> <li>忘记关闭的定时器</li> <li>使用闭包</li></ul> <blockquote><p>垃圾回收机制</p></blockquote> <ul><li><p>标记清除</p> <p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p></li> <li><p>引用计数</p></li></ul> <p>​	另一种<strong>没那么常用的</strong>垃圾回收策略是<strong>引用计数</strong>（referencecounting）。其思路是对每个值都记录它被引用的次数。声明量	并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值	引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地	收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。但是会有循环引用的问题，导出出现bug.</p> <h3 id="_9-null-和-undefined-区别"><a href="#_9-null-和-undefined-区别" class="header-anchor">#</a> 9.null 和 undefined 区别</h3> <blockquote><p>简单点理解： undefined表示值不存在，null表示值存在但是为空，没有意义；</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>null == undefined // true
null === undefined // fasle
// typeof null 为 Object, typeof undefined 为 undefined
</code></pre></div><h3 id="_10-函数柯里化"><a href="#_10-函数柯里化" class="header-anchor">#</a> 10.函数柯里化</h3> <p>将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">const</span> add <span class="token operator">=</span> function <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> function <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> y
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> add1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">3</span>
</code></pre></div><h3 id="_11-节流防抖"><a href="#_11-节流防抖" class="header-anchor">#</a> 11.节流防抖</h3> <p>解释：</p> <p>防抖： 每次有请求是继续延长时间，如：输入框输入请求，延迟1秒钟，一秒内还有请求继续延迟</p> <p>节流：固定个时间请求。滚动滚轮，拖拽等高频事件</p> <h3 id="_12-箭头函数和普通函数区别"><a href="#_12-箭头函数和普通函数区别" class="header-anchor">#</a> 12.箭头函数和普通函数区别</h3> <ul><li>不能new</li> <li>this指向</li> <li>不能使用arguments</li> <li>没有原型属性</li> <li>不能当作generator函数，不能使用yeid关键字</li></ul> <h3 id="_13-new运算符的实现机制"><a href="#_13-new运算符的实现机制" class="header-anchor">#</a> 13.new运算符的实现机制</h3> <ol><li>首先创建了一个新的<code>空对象</code></li> <li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li> <li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li> <li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol> <h2 id="_14-es6中新增的set、map两种数据结构怎么理解"><a href="#_14-es6中新增的set、map两种数据结构怎么理解" class="header-anchor">#</a> 14.ES6中新增的Set、Map两种数据结构怎么理解?</h2> <p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p> <p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p> <ul><li>add()</li> <li>delete()</li> <li>has()</li> <li>clear()</li></ul> <p>遍历：</p> <ul><li><p>keys()：返回键名的遍历器</p></li> <li><p>values()：返回键值的遍历器</p></li> <li><p>entries()：返回键值对的遍历器</p></li> <li><p>forEach()：使用回调函数遍历每个成员</p></li></ul> <p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p> <p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p> <ul><li>size 属性</li> <li>set()</li> <li>get()</li> <li>has()</li> <li>delete()</li> <li>clear()</li></ul> <p>遍历：</p> <ul><li>keys()：返回键名的遍历器</li> <li>values()：返回键值的遍历器</li> <li>entries()：返回所有成员的遍历器</li> <li>forEach()：遍历 Map 的所有成员</li></ul> <p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p> <ul><li>没有遍历操作的<code>API</code></li> <li>没有<code>size</code>属性</li></ul> <p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p> <p><code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p> <p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p> <p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p> <ul><li>没有遍历操作的<code>API</code></li> <li>没有<code>clear</code>清空方法</li></ul> <p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p> <p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p> <h3 id="_15-什么是作用域链"><a href="#_15-什么是作用域链" class="header-anchor">#</a> 15.什么是作用域链？</h3> <p>我们一般将作用域分成：</p> <ul><li>全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</li> <li>函数作用域：函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</li> <li>块级作用域：ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在大括号中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</li> <li></li></ul> <h3 id="_16-说说你对函数式编程的理解-以及优缺点"><a href="#_16-说说你对函数式编程的理解-以及优缺点" class="header-anchor">#</a> 16.说说你对函数式编程的理解，以及优缺点？</h3> <p>主要的编程范式有三种：命令式编程，声明式编程和函数式编程</p> <ul><li>高阶函数：函数作为参数</li> <li>纯函数：没有副作用</li> <li>柯里化：多元函数转为一元函数的过程，
<ul><li>关于柯里化函数的意义如下：
<ul><li>让纯函数更纯，每次接受一个参数，松散解耦</li> <li>惰性执行</li></ul></li></ul></li></ul> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li> <li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</li> <li>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</li> <li>隐性好处。减少代码量，提高维护性</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点：</h4> <ul><li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</li> <li>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</li> <li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li></ul> <h3 id="_17-null-和-undefined-有什么区别"><a href="#_17-null-和-undefined-有什么区别" class="header-anchor">#</a> 17.null 和 undefined 有什么区别？</h3> <p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p> <p>undefined 代表的含义是未定义，null 代表的含义是空对象</p> <p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p> <h3 id="_18-类的创建和继承"><a href="#_18-类的创建和继承" class="header-anchor">#</a> 18.类的创建和继承</h3> <h4 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h4> <ul><li>特点：基于原型链，既是父类的实例，也是子类的实例</li> <li>缺点：无法实现多继承</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'cat'</span><span class="token punctuation">;</span>


</code></pre></div><h4 id="构造继承"><a href="#构造继承" class="header-anchor">#</a> 构造继承</h4> <ul><li>特点：可以实现多继承</li> <li>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

</code></pre></div><h4 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h4> <p>相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p> <ul><li>特点：可以继承实例属性/方法，也可以继承原型属性/方法</li> <li>缺点：调用了两次父类构造函数，生成了两份实例</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>


</code></pre></div><h4 id="寄生组合继承"><a href="#寄生组合继承" class="header-anchor">#</a> 寄生组合继承</h4> <p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 创建一个没有实例方法的类</span>
  <span class="token keyword">var</span> <span class="token function-variable function">Super</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">Super</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">//将实例作为子类的原型</span>
  <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

</code></pre></div><h3 id="_19-利用-es6-set-去重"><a href="#_19-利用-es6-set-去重" class="header-anchor">#</a> 19.利用 ES6 Set 去重</h3> <ul><li>Array.from(new Set())</li> <li>算法
<ul><li>Map</li> <li>filter</li> <li>for循环</li></ul></li></ul> <h3 id="_20-说说前端中的事件流"><a href="#_20-说说前端中的事件流" class="header-anchor">#</a> 20.说说前端中的事件流</h3> <p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p> <ul><li>事件捕获阶段</li> <li>处于目标阶段</li> <li>事件冒泡阶段</li></ul> <p><strong>addEventListener</strong>，最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p> <h3 id="_21-如何让事件先冒泡后捕获"><a href="#_21-如何让事件先冒泡后捕获" class="header-anchor">#</a> 21.如何让事件先冒泡后捕获</h3> <p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p> <h3 id="_22-事件委托"><a href="#_22-事件委托" class="header-anchor">#</a> 22.事件委托</h3> <ul><li>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</li></ul> <ul><li>最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</li> <li>较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</li></ul> <h3 id="_23-mouseover和mouseenter的区别"><a href="#_23-mouseover和mouseenter的区别" class="header-anchor">#</a> 23.mouseover和mouseenter的区别</h3> <ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li> <li>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li></ul> <h3 id="_24-改变函数内部this指针的指向函数-bind-apply-call的区别"><a href="#_24-改变函数内部this指针的指向函数-bind-apply-call的区别" class="header-anchor">#</a> 24.改变函数内部this指针的指向函数（bind，apply，call的区别）</h3> <ul><li><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。</p></li> <li><p>通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</p> <h3 id="_25-js的各种位置-比如clientheight-scrollheight-offsetheight-以及scrolltop-offsettop-clienttop的区别"><a href="#_25-js的各种位置-比如clientheight-scrollheight-offsetheight-以及scrolltop-offsettop-clienttop的区别" class="header-anchor">#</a> 25.js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？</h3></li> <li><p>clientHeight：表示的是可视区域的高度，不包含border和滚动条</p></li> <li><p>offsetHeight：表示可视区域的高度，包含了border和滚动条</p></li> <li><p>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</p></li> <li><p>clientTop：表示边框border的厚度，在未指定的情况下一般为0</p></li> <li><p>scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。</p></li></ul> <h2 id=""><a href="#" class="header-anchor">#</a></h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/interview/ms/第四章 基础面试.html" class="prev">
        1、Ajax、fetch、Axios的区别？
      </a></span> <span class="next"><a href="/blog/interview/js/map和weakMap.html">
        map和set
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.4050c2a3.js" defer></script><script src="/blog/assets/js/2.c8cb3ded.js" defer></script><script src="/blog/assets/js/49.e0dedc3e.js" defer></script>
  </body>
</html>
