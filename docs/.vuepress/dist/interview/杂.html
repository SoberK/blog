<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.浏览器是如何渲染页面的？</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.b1721a3f.js" as="script"><link rel="preload" href="/assets/js/2.c8cb3ded.js" as="script"><link rel="preload" href="/assets/js/83.7b6488d3.js" as="script"><link rel="prefetch" href="/assets/js/10.213eb8c6.js"><link rel="prefetch" href="/assets/js/11.b4a8d23a.js"><link rel="prefetch" href="/assets/js/12.aee7ba70.js"><link rel="prefetch" href="/assets/js/13.6f49b002.js"><link rel="prefetch" href="/assets/js/14.1cff925e.js"><link rel="prefetch" href="/assets/js/15.fea3c73e.js"><link rel="prefetch" href="/assets/js/16.4b7101df.js"><link rel="prefetch" href="/assets/js/17.34ff2765.js"><link rel="prefetch" href="/assets/js/18.23ca8d62.js"><link rel="prefetch" href="/assets/js/19.4869668b.js"><link rel="prefetch" href="/assets/js/20.7095763b.js"><link rel="prefetch" href="/assets/js/21.5be49f42.js"><link rel="prefetch" href="/assets/js/22.20f84ab4.js"><link rel="prefetch" href="/assets/js/23.d778f780.js"><link rel="prefetch" href="/assets/js/24.a63fe158.js"><link rel="prefetch" href="/assets/js/25.3ee368a8.js"><link rel="prefetch" href="/assets/js/26.53a3ff14.js"><link rel="prefetch" href="/assets/js/27.16161488.js"><link rel="prefetch" href="/assets/js/28.abb1d0eb.js"><link rel="prefetch" href="/assets/js/29.20c5eb35.js"><link rel="prefetch" href="/assets/js/3.eb8f2650.js"><link rel="prefetch" href="/assets/js/30.71f94bc7.js"><link rel="prefetch" href="/assets/js/31.79a9a67f.js"><link rel="prefetch" href="/assets/js/32.c80c355f.js"><link rel="prefetch" href="/assets/js/33.837f6ed0.js"><link rel="prefetch" href="/assets/js/34.207a6fb8.js"><link rel="prefetch" href="/assets/js/35.592f3ee3.js"><link rel="prefetch" href="/assets/js/36.1e903ee0.js"><link rel="prefetch" href="/assets/js/37.86e3738d.js"><link rel="prefetch" href="/assets/js/38.efe4e9e5.js"><link rel="prefetch" href="/assets/js/39.be2160dc.js"><link rel="prefetch" href="/assets/js/4.e436362a.js"><link rel="prefetch" href="/assets/js/40.9faebd6c.js"><link rel="prefetch" href="/assets/js/41.992a00a9.js"><link rel="prefetch" href="/assets/js/42.95296b64.js"><link rel="prefetch" href="/assets/js/43.85090a04.js"><link rel="prefetch" href="/assets/js/44.e4244d79.js"><link rel="prefetch" href="/assets/js/45.e86620ec.js"><link rel="prefetch" href="/assets/js/46.bd67d46b.js"><link rel="prefetch" href="/assets/js/47.eb266c00.js"><link rel="prefetch" href="/assets/js/48.469ae2b3.js"><link rel="prefetch" href="/assets/js/49.ed7879b3.js"><link rel="prefetch" href="/assets/js/5.a03444cb.js"><link rel="prefetch" href="/assets/js/50.8ebb2816.js"><link rel="prefetch" href="/assets/js/51.da3966c2.js"><link rel="prefetch" href="/assets/js/52.5ed59886.js"><link rel="prefetch" href="/assets/js/53.07f7b30a.js"><link rel="prefetch" href="/assets/js/54.c8b74c11.js"><link rel="prefetch" href="/assets/js/55.f5b6550c.js"><link rel="prefetch" href="/assets/js/56.2c11d008.js"><link rel="prefetch" href="/assets/js/57.c79780ec.js"><link rel="prefetch" href="/assets/js/58.4614a6f2.js"><link rel="prefetch" href="/assets/js/59.07c58bc3.js"><link rel="prefetch" href="/assets/js/6.1894fe79.js"><link rel="prefetch" href="/assets/js/60.4b60dd72.js"><link rel="prefetch" href="/assets/js/61.2dfc903c.js"><link rel="prefetch" href="/assets/js/62.198a045a.js"><link rel="prefetch" href="/assets/js/63.ff1bf0dd.js"><link rel="prefetch" href="/assets/js/64.6d2273ef.js"><link rel="prefetch" href="/assets/js/65.8b73367f.js"><link rel="prefetch" href="/assets/js/66.4290a2e9.js"><link rel="prefetch" href="/assets/js/67.cf595479.js"><link rel="prefetch" href="/assets/js/68.927c903d.js"><link rel="prefetch" href="/assets/js/69.8360432c.js"><link rel="prefetch" href="/assets/js/7.c8654701.js"><link rel="prefetch" href="/assets/js/70.486af9f9.js"><link rel="prefetch" href="/assets/js/71.964eb093.js"><link rel="prefetch" href="/assets/js/72.cbefb1c4.js"><link rel="prefetch" href="/assets/js/73.2dd5cc6b.js"><link rel="prefetch" href="/assets/js/74.909c196e.js"><link rel="prefetch" href="/assets/js/75.54c95b38.js"><link rel="prefetch" href="/assets/js/76.b8b6d217.js"><link rel="prefetch" href="/assets/js/77.4f86a1bd.js"><link rel="prefetch" href="/assets/js/78.683f014b.js"><link rel="prefetch" href="/assets/js/79.fef918e0.js"><link rel="prefetch" href="/assets/js/8.2e87cc83.js"><link rel="prefetch" href="/assets/js/80.87b2951e.js"><link rel="prefetch" href="/assets/js/81.c6cfa5cc.js"><link rel="prefetch" href="/assets/js/82.26c69d1b.js"><link rel="prefetch" href="/assets/js/9.857b3b33.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>2周面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/ms/第七章 工作经验.html" class="sidebar-link">1、H5页面如何进行首屏优化</a></li><li><a href="/interview/ms/第七章 真实项目.html" class="sidebar-link">1、首屏优化</a></li><li><a href="/interview/ms/第九章 解决问题.html" class="sidebar-link">1、[1,2,3].map(parseInt)</a></li><li><a href="/interview/ms/第二、三章 算法结构和算法.html" class="sidebar-link">算法</a></li><li><a href="/interview/ms/第五章 知识深度-原理源码.html" class="sidebar-link">1、JS内存泄漏如何检测？场景有哪些</a></li><li><a href="/interview/ms/第八章 手写.html" class="sidebar-link">1、数组扁平化</a></li><li><a href="/interview/ms/第六章 知识广度.html" class="sidebar-link">1、网络请求中，token和cookie有什么区别</a></li><li><a href="/interview/ms/第四章 基础面试.html" class="sidebar-link">1、Ajax、fetch、Axios的区别？</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_1-浏览器是如何渲染页面的"><a href="#_1-浏览器是如何渲染页面的" class="header-anchor">#</a> 1.浏览器是如何渲染页面的？</h3> <p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p> <p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p> <hr> <p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p> <p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p> <p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p> <hr> <p>渲染的第一步是<strong>解析 HTML</strong>。</p> <p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p> <p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p> <p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p> <p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p> <hr> <p>渲染的下一步是<strong>样式计算</strong>。</p> <p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p> <p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p> <p>这一步完成后，会得到一棵带有样式的 DOM 树。</p> <hr> <p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p> <p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p> <p>大部分时候，DOM 树和布局树并非一一对应。</p> <p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p> <hr> <p>下一步是<strong>分层</strong></p> <p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p> <p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p> <p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p> <hr> <p>再下一步是<strong>绘制</strong></p> <p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p> <hr> <p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p> <p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p> <p>它会从线程池中拿取多个线程来完成分块工作。</p> <hr> <p>分块完成后，进入<strong>光栅化</strong>阶段。</p> <p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p> <p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p> <p>光栅化的结果，就是一块一块的位图</p> <hr> <p>最后一个阶段就是<strong>画</strong>了</p> <p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p> <p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p> <p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p> <p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p> <h3 id="_2-什么是-reflow"><a href="#_2-什么是-reflow" class="header-anchor">#</a> 2.什么是 reflow？</h3> <p>reflow 的本质就是重新计算 layout 树。</p> <p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p> <p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p> <p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p> <p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p> <h3 id="_3-什么是-repaint"><a href="#_3-什么是-repaint" class="header-anchor">#</a> 3.什么是 repaint？</h3> <p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p> <p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p> <p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p> <h3 id="_4-为什么-transform-的效率高"><a href="#_4-为什么-transform-的效率高" class="header-anchor">#</a> 4.为什么 transform 的效率高？</h3> <p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p> <p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p> <h3 id="_5-http缓存、协商缓存、强缓存"><a href="#_5-http缓存、协商缓存、强缓存" class="header-anchor">#</a> 5.HTTP缓存、协商缓存、强缓存</h3> <p>在浏览器加载资源的时候，首先会根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存策略，判断是否向远程服务器请求资源还是去本地获取缓存资源。</p> <p>强缓存：</p> <ul><li><h4 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h4> <p>​	这个是1.0的缓存，在浏览器第一个请求资源时，服务器端的响应头会附上<code>Expires</code>这个响应字段，当浏览器在下一次请求这个资源时会根据上次的<code>expires</code>字段是否使用缓存资源（当请求时间小于服务端返回的到期时间，直接使用缓存数据）</p></li> <li><h4 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-control</h4> <p>有个问题，就是服务端客户端时间对不上有差距，所有加了一个cache-control字段，这个字段优先级高于expires，是相对时间</p> <p>实例值：max-age\s-maxage\private\public\no-store\no-chache</p></li></ul> <p>协商缓存：</p> <ul><li><p>协商缓存是服务器来确定这个资源是否可用，</p> <p>来张图：</p> <p>![image-20230323193921777](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20230323193921777.png)</p> <h5 id="etag-if-none-match"><a href="#etag-if-none-match" class="header-anchor">#</a> Etag/If-None-Match</h5> <blockquote><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p> <p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p></blockquote> <h5 id="last-modifed-if-modified-since"><a href="#last-modifed-if-modified-since" class="header-anchor">#</a> Last-Modifed/If-Modified-Since</h5> <blockquote><p>Last-Modifed 浏览器向服务器发送资源最后的修改时间</p> <p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p></blockquote> <h3 id="_6-get和post请求区别"><a href="#_6-get和post请求区别" class="header-anchor">#</a> 6.get和post请求区别</h3> <p>1.url 体现区别，get请求能在URL上体现，post不可以。</p> <p>2.长度限制，get请求有长度限制，但并非HTTP协议的限制，是浏览器和web服务器的限制，因此不同浏览器和web服务器限制成都不一样。</p> <p>3.缓存区别, get请求一般用于查询，可以不用每次都与数据库交互，利用缓存机制，post请求一般用于增删改操作，必须与数据库就行操作，所以不可用于缓存。</p> <p>其他的请求：</p> <table><thead><tr><th>主要方法</th> <th>功能说明</th></tr></thead> <tbody><tr><td>GET</td> <td>获取资源</td></tr> <tr><td>POST</td> <td>传输实体主体，一般用于向服务器提交数据</td></tr> <tr><td>PUT</td> <td>传输文件</td></tr> <tr><td>HEAD</td> <td>获取报文首部</td></tr> <tr><td>DELETE</td> <td>删除文件</td></tr> <tr><td>OPTIONS</td> <td>询问服务器支持的方法</td></tr> <tr><td>TRACE</td> <td>追踪路径</td></tr> <tr><td>CONNECT</td> <td>要求用隧道协议连接</td></tr></tbody></table> <h3 id="_7-跨域和解决方法"><a href="#_7-跨域和解决方法" class="header-anchor">#</a> 7.跨域和解决方法</h3> <ul><li>Jsonp、</li> <li>webpack 配置proxy,</li> <li>nginx 反向代理，</li> <li>Cors: 后端需要在目标服务器http相应头 配置允许跨域： Access-control-Allow-origin: '</li></ul> <h3 id="_8-模块化发展历程"><a href="#_8-模块化发展历程" class="header-anchor">#</a> 8.模块化发展历程</h3> <p>IIFE：立即执行函数，在一个独立的作用域中执行代码，不会污染全局作用域和避免变量冲突。</p> <p>AMD： 用requireJS 来编写模块化，特点：依赖必须提前声明。</p> <p>CMD： 使用seaJS 来编写模块化，特点：支持动态引入依赖文件。</p> <p>CommonJS: nodeJS 内置的模块化。</p> <p>ES6的modules： es6引入的模块化。</p> <h3 id="_9-tcp三次握手"><a href="#_9-tcp三次握手" class="header-anchor">#</a> 9.TCP三次握手</h3> <p>第一次：client -&gt; server 服务端知道客户端有发送能力</p> <p>第二次：server -&gt; client 客户端知道服务端游发送能力</p> <p>第三次：client -&gt; server 让服务端知道客户端接受能力没问题</p> <p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。</p> <h3 id="_10-为什么-0-1-0-2-不等于-0-3"><a href="#_10-为什么-0-1-0-2-不等于-0-3" class="header-anchor">#</a> 10.为什么 0.1 + 0.2 不等于 0.3</h3></li></ul> <p>与许多其他编程语言不同，JavaScript 并未定义不同类型的数字数据类型，而是始终遵循国际 IEEE 754 标准，将数字存储为<code>双精度浮点数</code>。</p> <p>这种格式以 64 位存储数字，其中<code>数字（分数）存储在位 0 到 51 中</code>，指数存储在位 52 到 62 中，符号存储在位 63 中。</p> <p>用科学计数法表示二进制 0.1 并只保留前 52 位</p> <h3 id="_11-http-和-https"><a href="#_11-http-和-https" class="header-anchor">#</a> 11. HTTP 和 HTTPS</h3> <h4 id="_1-http-和-https-的基本概念"><a href="#_1-http-和-https-的基本概念" class="header-anchor">#</a> 1.http 和 https 的基本概念</h4> <p>http:http是服务器与客户端请求的一个应答标准Tcp,用于从www服务器传输超文本到本地浏览器的超文本传输协议</p> <p>Https：https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p> <h4 id="_2-http-和-https-的区别及优缺点"><a href="#_2-http-和-https-的区别及优缺点" class="header-anchor">#</a> 2.http 和 https 的区别及优缺点？</h4> <ul><li>http:80端口，https:443</li> <li>Https 需要ca证书，</li> <li>http是明文传输，https是加密传输】</li> <li>https需要握手比较费时</li> <li>https缓存不如http高效</li></ul> <h4 id="_3-https-协议的工作原理"><a href="#_3-https-协议的工作原理" class="header-anchor">#</a> 3.https 协议的工作原理</h4> <ul><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li> <li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li> <li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li> <li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li> <li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li> <li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ul> <h3 id="_12-tcp和udp的区别tcp是面向链接的-而udp是面向无连接的。"><a href="#_12-tcp和udp的区别tcp是面向链接的-而udp是面向无连接的。" class="header-anchor">#</a> 12.TCP和UDP的区别TCP是面向<code>链接</code>的，而UDP是面向无连接的。</h3> <ul><li><p>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p></li> <li><p>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</p></li> <li><p>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p></li> <li><p>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p></li></ul> <h3 id="_13-cookie、sessionstorage、localstorage-的区别"><a href="#_13-cookie、sessionstorage、localstorage-的区别" class="header-anchor">#</a> 13.Cookie、sessionStorage、localStorage 的区别</h3> <p><strong>相同点</strong>：</p> <ul><li>存储在客户端</li></ul> <p><strong>不同点</strong>：</p> <ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li> <li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li> <li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul> <h3 id="_14-从输入url到页面加载的全过程"><a href="#_14-从输入url到页面加载的全过程" class="header-anchor">#</a> 14.从输入URL到页面加载的全过程</h3> <p>1、首先在浏览器中输入URL</p> <p>2、查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p> <ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li> <li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li> <li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li> <li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul> <p>3、DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p> <p>4、建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p> <p>5、发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p> <p>6、服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p> <p>7、关闭TCP连接：通过四次挥手释放TCP连接</p> <p>8、浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p> <ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li> <li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li> <li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li> <li>布局（Layout）：计算出每个节点在屏幕中的位置</li> <li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul> <p>9、JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p> <h3 id="_15-浏览器重绘与重排的区别"><a href="#_15-浏览器重绘与重排的区别" class="header-anchor">#</a> 15.浏览器重绘与重排的区别？</h3> <ul><li><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li> <li><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul> <h3 id="_16-如何触发重排和重绘"><a href="#_16-如何触发重排和重绘" class="header-anchor">#</a> 16.如何触发重排和重绘？</h3> <p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p> <ul><li><p>添加、删除、更新DOM节点</p></li> <li><p>通过display: none隐藏一个DOM节点-触发重排和重绘</p></li> <li><p>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</p></li> <li><p>移动或者给页面中的DOM节点添加动画</p></li> <li><p>添加一个样式表，调整样式属性</p></li> <li><p>用户行为，例如调整窗口大小，改变字号，或者滚动。</p></li></ul> <h3 id="_17-如何避免重绘或者重排"><a href="#_17-如何避免重绘或者重排" class="header-anchor">#</a> 17.如何避免重绘或者重排？</h3> <ol><li><code>集中改变样式</code>，不要一条一条地修改 DOM 的样式。</li> <li>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li> <li>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>，那么修改他们的 CSS 是不会 reflow 的。</li> <li>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li> <li>尽量只修改<code>position：absolute</code>或<code>fixed</code>元素，对其他元素影响不大</li> <li>动画开始<code>GPU</code>加速，<code>translate</code>使用<code>3D</code>变化</li> <li>提升为合成层</li></ol> <h3 id="_18-说说你对-xss-的了解"><a href="#_18-说说你对-xss-的了解" class="header-anchor">#</a> 18.说说你对 XSS 的了解</h3> <p>英文全称是 <code>Cross Site Script</code>，<code>XSS</code>攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于<code>DOM XSS</code></p> <p>反射线：通过用户的输入的信息反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功，通常反射型<code>XSS</code>的恶意代码存在<code>URL</code>里，通过<code>URL</code>传递参数的功能，如网站搜索、跳转等</p> <p>存储型:存储型 <code>XSS</code> 会把用户输入的数据“存储”在服务器端,比如表单中写入js,当渲染页面执行的时候，遇到script标签就会执行输入的脚本</p> <p>基于<code>DOM XSS</code>：实际上，这种类型的<code>XSS</code>并非按照“数据是否保存在服务器端”来划分，<code>DOM Based XSS</code>从效果上来说也是反射型<code>XSS</code>。单独划分出来，是因为<code>DOM Based XSS</code> 的形成原因比较特别，发现它的安全专家专门提出了这种类型的<code>XSS</code>。<code>DOM 型 XSS</code>跟前两种<code>XSS</code>的区别：<code>DOM 型 XSS</code>攻击中，取出和执行恶意代码由浏览器端完成，属于前端<code>JavaScript</code>自身的安全漏洞，而其他两种<code>XSS</code>都属于服务端的安全漏洞。</p> <h3 id="_19-xss攻击防御"><a href="#_19-xss攻击防御" class="header-anchor">#</a> 19.<code>XSS</code>攻击防御</h3> <ul><li>HttpOnly`</li> <li>输入检查 ：在<code>XSS</code>的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如<code>＜、＞、’、”</code>，做转义</li> <li>输出检查：和输入一样，转义</li></ul> <h3 id="_20-get请求传参长度的误区"><a href="#_20-get请求传参长度的误区" class="header-anchor">#</a> 20.get请求传参长度的误区</h3> <ul><li><p>HTTP 协议 未规定 GET 和POST的长度限制</p></li> <li><p>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</p></li> <li><p>不同的浏览器和WEB服务器，限制的最大长度不一样</p></li> <li><p>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</p></li></ul> <h3 id="_21-补充get和post请求在缓存方面的区别"><a href="#_21-补充get和post请求在缓存方面的区别" class="header-anchor">#</a> 21.补充get和post请求在缓存方面的区别</h3> <ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li> <li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul> <h3 id="_22-状态码"><a href="#_22-状态码" class="header-anchor">#</a> 22.状态码</h3> <ul><li><p>400状态码：请求无效</p></li> <li><p>401状态码：当前请求需要用户验证，token过期</p></li> <li><p>403状态码：服务器已经得到请求，但是拒绝执行 getpost方法不对</p> <h3 id="_23-cookie如何防范xss攻击"><a href="#_23-cookie如何防范xss攻击" class="header-anchor">#</a> 23.Cookie如何防范XSS攻击</h3></li></ul> <p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：</p> <ul><li>httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。</li> <li>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b1721a3f.js" defer></script><script src="/assets/js/2.c8cb3ded.js" defer></script><script src="/assets/js/83.7b6488d3.js" defer></script>
  </body>
</html>
