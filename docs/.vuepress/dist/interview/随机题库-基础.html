<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>随机题库-基础 | 翻手机壳</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.671fbdd0.css" as="style"><link rel="preload" href="/blog/assets/js/app.ce2c2954.js" as="script"><link rel="preload" href="/blog/assets/js/2.245720e2.js" as="script"><link rel="preload" href="/blog/assets/js/133.c525dbfa.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.06910aeb.js"><link rel="prefetch" href="/blog/assets/js/100.debfc0ec.js"><link rel="prefetch" href="/blog/assets/js/101.7b9650f2.js"><link rel="prefetch" href="/blog/assets/js/102.567e72f8.js"><link rel="prefetch" href="/blog/assets/js/103.b3585dc0.js"><link rel="prefetch" href="/blog/assets/js/104.39b8408f.js"><link rel="prefetch" href="/blog/assets/js/105.9e1f64d6.js"><link rel="prefetch" href="/blog/assets/js/106.be111f43.js"><link rel="prefetch" href="/blog/assets/js/107.5ea1071a.js"><link rel="prefetch" href="/blog/assets/js/108.ceab86d2.js"><link rel="prefetch" href="/blog/assets/js/109.9d3df089.js"><link rel="prefetch" href="/blog/assets/js/11.da5ac828.js"><link rel="prefetch" href="/blog/assets/js/110.e35ea1c7.js"><link rel="prefetch" href="/blog/assets/js/111.71b527c0.js"><link rel="prefetch" href="/blog/assets/js/112.7cb601a1.js"><link rel="prefetch" href="/blog/assets/js/113.5a1957cc.js"><link rel="prefetch" href="/blog/assets/js/114.1a010c32.js"><link rel="prefetch" href="/blog/assets/js/115.a6c22202.js"><link rel="prefetch" href="/blog/assets/js/116.37ae9fd1.js"><link rel="prefetch" href="/blog/assets/js/117.e8963f78.js"><link rel="prefetch" href="/blog/assets/js/118.78b49e2d.js"><link rel="prefetch" href="/blog/assets/js/119.c0215fc7.js"><link rel="prefetch" href="/blog/assets/js/12.0c7867d7.js"><link rel="prefetch" href="/blog/assets/js/120.6f4ba2b1.js"><link rel="prefetch" href="/blog/assets/js/121.eda52b6c.js"><link rel="prefetch" href="/blog/assets/js/122.b1406988.js"><link rel="prefetch" href="/blog/assets/js/123.56eeda5e.js"><link rel="prefetch" href="/blog/assets/js/124.a52b3c81.js"><link rel="prefetch" href="/blog/assets/js/125.f292b9dd.js"><link rel="prefetch" href="/blog/assets/js/126.132d314b.js"><link rel="prefetch" href="/blog/assets/js/127.326580cc.js"><link rel="prefetch" href="/blog/assets/js/128.1026b8dc.js"><link rel="prefetch" href="/blog/assets/js/129.763b4f61.js"><link rel="prefetch" href="/blog/assets/js/13.5b995bf4.js"><link rel="prefetch" href="/blog/assets/js/130.ca1fb137.js"><link rel="prefetch" href="/blog/assets/js/131.8205b6f7.js"><link rel="prefetch" href="/blog/assets/js/132.680be26d.js"><link rel="prefetch" href="/blog/assets/js/134.9c388059.js"><link rel="prefetch" href="/blog/assets/js/14.752c486e.js"><link rel="prefetch" href="/blog/assets/js/15.4422ad76.js"><link rel="prefetch" href="/blog/assets/js/16.892f4438.js"><link rel="prefetch" href="/blog/assets/js/17.6ab5fc5d.js"><link rel="prefetch" href="/blog/assets/js/18.d4bee414.js"><link rel="prefetch" href="/blog/assets/js/19.ec1c42e7.js"><link rel="prefetch" href="/blog/assets/js/20.8f5317ad.js"><link rel="prefetch" href="/blog/assets/js/21.655bdf4b.js"><link rel="prefetch" href="/blog/assets/js/22.e6eff085.js"><link rel="prefetch" href="/blog/assets/js/23.dd7d7de5.js"><link rel="prefetch" href="/blog/assets/js/24.bf09dda4.js"><link rel="prefetch" href="/blog/assets/js/25.e7cb4edc.js"><link rel="prefetch" href="/blog/assets/js/26.2c9b91e2.js"><link rel="prefetch" href="/blog/assets/js/27.31698b89.js"><link rel="prefetch" href="/blog/assets/js/28.89c5164d.js"><link rel="prefetch" href="/blog/assets/js/29.53ce079f.js"><link rel="prefetch" href="/blog/assets/js/3.6f19f564.js"><link rel="prefetch" href="/blog/assets/js/30.2168f669.js"><link rel="prefetch" href="/blog/assets/js/31.09c300f7.js"><link rel="prefetch" href="/blog/assets/js/32.417c60f0.js"><link rel="prefetch" href="/blog/assets/js/33.bc96ddf7.js"><link rel="prefetch" href="/blog/assets/js/34.f988c929.js"><link rel="prefetch" href="/blog/assets/js/35.2f26c9e2.js"><link rel="prefetch" href="/blog/assets/js/36.2a62ea9e.js"><link rel="prefetch" href="/blog/assets/js/37.58383294.js"><link rel="prefetch" href="/blog/assets/js/38.947df07b.js"><link rel="prefetch" href="/blog/assets/js/39.db46aafe.js"><link rel="prefetch" href="/blog/assets/js/4.3e16be69.js"><link rel="prefetch" href="/blog/assets/js/40.15e911e9.js"><link rel="prefetch" href="/blog/assets/js/41.1f30e429.js"><link rel="prefetch" href="/blog/assets/js/42.ef2bbbd1.js"><link rel="prefetch" href="/blog/assets/js/43.0ae09631.js"><link rel="prefetch" href="/blog/assets/js/44.49429642.js"><link rel="prefetch" href="/blog/assets/js/45.ad64d08c.js"><link rel="prefetch" href="/blog/assets/js/46.2ba870c2.js"><link rel="prefetch" href="/blog/assets/js/47.9e204e99.js"><link rel="prefetch" href="/blog/assets/js/48.21b37482.js"><link rel="prefetch" href="/blog/assets/js/49.3caff103.js"><link rel="prefetch" href="/blog/assets/js/5.7dce9bf1.js"><link rel="prefetch" href="/blog/assets/js/50.6b243c44.js"><link rel="prefetch" href="/blog/assets/js/51.0793dd19.js"><link rel="prefetch" href="/blog/assets/js/52.f9ddb34c.js"><link rel="prefetch" href="/blog/assets/js/53.9b396a0b.js"><link rel="prefetch" href="/blog/assets/js/54.1539ed74.js"><link rel="prefetch" href="/blog/assets/js/55.c5391572.js"><link rel="prefetch" href="/blog/assets/js/56.ab9259d8.js"><link rel="prefetch" href="/blog/assets/js/57.8d8a5dc2.js"><link rel="prefetch" href="/blog/assets/js/58.3a30f259.js"><link rel="prefetch" href="/blog/assets/js/59.4a9319ec.js"><link rel="prefetch" href="/blog/assets/js/6.0585bb02.js"><link rel="prefetch" href="/blog/assets/js/60.8d1baa9d.js"><link rel="prefetch" href="/blog/assets/js/61.035f33bd.js"><link rel="prefetch" href="/blog/assets/js/62.005fb5ab.js"><link rel="prefetch" href="/blog/assets/js/63.7755e9ae.js"><link rel="prefetch" href="/blog/assets/js/64.d96029e5.js"><link rel="prefetch" href="/blog/assets/js/65.9023c2dd.js"><link rel="prefetch" href="/blog/assets/js/66.7783718d.js"><link rel="prefetch" href="/blog/assets/js/67.178d7b49.js"><link rel="prefetch" href="/blog/assets/js/68.e4af1614.js"><link rel="prefetch" href="/blog/assets/js/69.ead840ae.js"><link rel="prefetch" href="/blog/assets/js/7.934e04cb.js"><link rel="prefetch" href="/blog/assets/js/70.d3ecd9bc.js"><link rel="prefetch" href="/blog/assets/js/71.2d4fbcfc.js"><link rel="prefetch" href="/blog/assets/js/72.17deb2e5.js"><link rel="prefetch" href="/blog/assets/js/73.34c13d73.js"><link rel="prefetch" href="/blog/assets/js/74.0295c23c.js"><link rel="prefetch" href="/blog/assets/js/75.f538cb4d.js"><link rel="prefetch" href="/blog/assets/js/76.47dcdcd8.js"><link rel="prefetch" href="/blog/assets/js/77.fb21760a.js"><link rel="prefetch" href="/blog/assets/js/78.a085030a.js"><link rel="prefetch" href="/blog/assets/js/79.e384c750.js"><link rel="prefetch" href="/blog/assets/js/8.a6061e3a.js"><link rel="prefetch" href="/blog/assets/js/80.203f22e9.js"><link rel="prefetch" href="/blog/assets/js/81.ba32b44a.js"><link rel="prefetch" href="/blog/assets/js/82.f530011f.js"><link rel="prefetch" href="/blog/assets/js/83.ae107585.js"><link rel="prefetch" href="/blog/assets/js/84.13aaf9cd.js"><link rel="prefetch" href="/blog/assets/js/85.114da2f0.js"><link rel="prefetch" href="/blog/assets/js/86.141a419b.js"><link rel="prefetch" href="/blog/assets/js/87.b65c4bf4.js"><link rel="prefetch" href="/blog/assets/js/88.e8ae9dac.js"><link rel="prefetch" href="/blog/assets/js/89.5dce9692.js"><link rel="prefetch" href="/blog/assets/js/9.2b5c6f97.js"><link rel="prefetch" href="/blog/assets/js/90.f9979ac7.js"><link rel="prefetch" href="/blog/assets/js/91.664d739e.js"><link rel="prefetch" href="/blog/assets/js/92.82183c7c.js"><link rel="prefetch" href="/blog/assets/js/93.68a0b2ab.js"><link rel="prefetch" href="/blog/assets/js/94.f30d71bc.js"><link rel="prefetch" href="/blog/assets/js/95.b7882666.js"><link rel="prefetch" href="/blog/assets/js/96.03dc3c8d.js"><link rel="prefetch" href="/blog/assets/js/97.320960be.js"><link rel="prefetch" href="/blog/assets/js/98.093fc300.js"><link rel="prefetch" href="/blog/assets/js/99.2fa367a4.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.671fbdd0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">翻手机壳</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/experience/request/请求.html" class="nav-link">
  总结
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/experience/request/请求.html" class="nav-link">
  总结
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>随机题库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/interview/随机题库-基础.html" class="active sidebar-link">随机题库-基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第一波" class="sidebar-link">第一波</a></li><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第二波" class="sidebar-link">第二波</a></li><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第三波" class="sidebar-link">第三波</a></li><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第四波" class="sidebar-link">第四波</a></li><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第五波" class="sidebar-link">第五波</a></li><li class="sidebar-sub-header"><a href="/blog/interview/随机题库-基础.html#第六波" class="sidebar-link">第六波</a></li></ul></li><li><a href="/blog/interview/随机题库-手写.html" class="sidebar-link">随机题库-手写</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2周面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="随机题库-基础"><a href="#随机题库-基础" class="header-anchor">#</a> 随机题库-基础</h1> <h2 id="第一波"><a href="#第一波" class="header-anchor">#</a> 第一波</h2> <h3 id="_1-js-有哪些数据类型-基本类型有哪些引用类型有哪些"><a href="#_1-js-有哪些数据类型-基本类型有哪些引用类型有哪些" class="header-anchor">#</a> 1:js 有哪些数据类型？基本类型有哪些引用类型有哪些？</h3> <p>JavaScript 中有 7 种数据类型，其中 6 种是基本数据类型：number、string、boolean、null、undefined 和 symbol。基本类型的特点是它们是不可变的，赋值操作是值的复制。另一种类型是 object，它是一种引用类型，可以存储多个值或者复杂的数据结构，比如数组和函数。</p> <h3 id="_2-null-与-undefined-的区别-与-的区别"><a href="#_2-null-与-undefined-的区别-与-的区别" class="header-anchor">#</a> 2:null 与 undefined 的区别？==与===的区别？</h3> <p>null 表示一个空的对象指针，它是一个 JavaScript 关键字，用于显式地表示一个空值。undefined 是一个全局对象的属性，表示声明了但未赋值的变量的默认值，或者访问不存在的对象属性时的返回值。</p> <h3 id="_3-如何判断某一个变量是数组"><a href="#_3-如何判断某一个变量是数组" class="header-anchor">#</a> 3:如何判断某一个变量是数组？</h3> <p>除了使用 Array.isArray()方法之外，还可以通过 Object.prototype.toString.call()方法来判断一个变量是否为数组。例如：</p> <h3 id="_4-js-哪些操作会实行隐式转换"><a href="#_4-js-哪些操作会实行隐式转换" class="header-anchor">#</a> 4:js 哪些操作会实行隐式转换？</h3> <p>隐式类型转换是指在运行时将一个数据类型自动转换为另一个数据类型。JavaScript 中存在的一些隐式转换包括数字与字符串相加时，布尔值与数字的运算时等。</p> <h3 id="_5-变量提升、函数名提升问题-哪些情况会有变量、函数名的提升-比如-a-function-a-之类的问题"><a href="#_5-变量提升、函数名提升问题-哪些情况会有变量、函数名的提升-比如-a-function-a-之类的问题" class="header-anchor">#</a> 5:变量提升、函数名提升问题，哪些情况会有变量、函数名的提升？比如 a() function a(){}之类的问题</h3> <p>变量提升、函数名提升问题： JavaScript 中的变量和函数声明会在代码执行前被提升。变量声明会被提升，但是初始化的值不会，而函数声明整体会被提升，包括函数名和函数体。这意味着你可以在函数声明之前调用函数，但对于变量赋值则不会受到影响</p> <h3 id="_6-作用域的问题"><a href="#_6-作用域的问题" class="header-anchor">#</a> 6:作用域的问题？</h3> <p>作用域： JavaScript 中的作用域定义了变量的可访问性。作用域分为全局作用域和局部作用域（函数作用域）。变量在不同的作用域中可以被访问或者不可访问。</p> <h3 id="_7-什么是-iife-立即执行函数-如何实现"><a href="#_7-什么是-iife-立即执行函数-如何实现" class="header-anchor">#</a> 7:什么是 IIFE 立即执行函数？如何实现？</h3> <p>IIFE 立即执行函数： IIFE 是 Immediately Invoked Function Expression 的缩写，指的是定义后立即执行的函数表达式。实现方式是在函数定义后紧跟一对括号()，例如(function() { /_ code _/ })();。</p> <h3 id="_8-什么是闭包-请手写一个闭包-闭包的原理"><a href="#_8-什么是闭包-请手写一个闭包-闭包的原理" class="header-anchor">#</a> 8:什么是闭包？请手写一个闭包？闭包的原理？</h3> <p>闭包： 闭包是指函数和其相关的引用环境组合而成的实体。简单说，闭包可以访问定义时的作用域以及自身的参数和变量。以下是一个闭包的示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> outerVariable <span class="token operator">=</span> <span class="token string">&quot;I am from outer&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> myClosure <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">myClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：'I am from outer'</span>
</code></pre></div><h3 id="_9-this-的指向问题-如何改变-this-的指向-闭包中-this-指向什么-在严格模式下函数的-this-指向什么-非严格模式呢"><a href="#_9-this-的指向问题-如何改变-this-的指向-闭包中-this-指向什么-在严格模式下函数的-this-指向什么-非严格模式呢" class="header-anchor">#</a> 9:this 的指向问题：如何改变 this 的指向？闭包中 this 指向什么？在严格模式下函数的 this 指向什么？非严格模式呢？</h3> <p>this 的指向问题： this 在 JavaScript 中取决于函数的调用方式。可以使用 call、apply、bind 来改变 this 的指向。在闭包中，this 指向的是定义该闭包的函数所在的作用域。在严格模式下，函数的 this 指向 undefined，而非严格模式下函数的 this 指向全局对象（在浏览器中是 window 对象）。</p> <h3 id="_10-js-如何实现继承-es6-class-如何实现的继承-与-es5-的区别是什么"><a href="#_10-js-如何实现继承-es6-class-如何实现的继承-与-es5-的区别是什么" class="header-anchor">#</a> 10:js 如何实现继承？ES6 class 如何实现的继承？与 ES5 的区别是什么？</h3> <p>JavaScript 实现继承： 在 ES5 中，可以通过原型链来实现继承，通过将子类的原型指向父类的实例来继承父类的属性和方法。而在 ES6 中，使用 class 和 extends 来实现继承，更直观且易读。ES6 的继承语法更接近其他面向对象语言。</p> <h3 id="_11-什么是原型链-什么是-prototype-属性-如何避免原型链属性共享-原型方面考题还有如何让你一个伪数组使用-slice-方法"><a href="#_11-什么是原型链-什么是-prototype-属性-如何避免原型链属性共享-原型方面考题还有如何让你一个伪数组使用-slice-方法" class="header-anchor">#</a> 11:什么是原型链？什么是 prototype 属性？如何避免原型链属性共享？原型方面考题还有如何让你一个伪数组使用 slice 方法？</h3> <p>原型链与 prototype 属性： 原型链是由对象组成的链式结构，每个对象都有一个指向其原型对象的引用。prototype 属性是函数特有的属性，它指向一个对象，这个对象就是该函数的原型对象。要避免原型链属性共享，可以使用对象的 Object.create()方法或者构造函数配合 new 关键字创建对象，确保实例的属性不共享。</p> <h3 id="_12-异步与同步的执行顺序-settimeout-function-200-中-200-的含义-promise-的用法-promise-接受一个同步任务会怎么样-什么是-promise-的链式调用-如何解决回调地狱-es7-的-async-与-await-的用法-一些面试题中还会涉及宏任务与微任务。"><a href="#_12-异步与同步的执行顺序-settimeout-function-200-中-200-的含义-promise-的用法-promise-接受一个同步任务会怎么样-什么是-promise-的链式调用-如何解决回调地狱-es7-的-async-与-await-的用法-一些面试题中还会涉及宏任务与微任务。" class="header-anchor">#</a> 12:异步与同步的执行顺序？setTimeout（function（）{},200）中 200 的含义？promise 的用法？promise 接受一个同步任务会怎么样？什么是 promise 的链式调用？如何解决回调地狱？ES7 的 async 与 await 的用法？一些面试题中还会涉及宏任务与微任务。</h3> <p>异步与同步的执行顺序： 异步操作不会阻塞代码的执行，而同步操作会阻塞代码的执行。setTimeout(function(){}, 200)中的 200 表示延迟执行的时间，单位是毫秒。Promise 是一种用来处理异步操作的对象，它可以接受同步任务，但是会立即执行。</p> <h3 id="_13-什么是事件冒泡-事件捕获-如何阻止事件冒泡与默认行为-什么是事件委托-事件委托对于性能的提升"><a href="#_13-什么是事件冒泡-事件捕获-如何阻止事件冒泡与默认行为-什么是事件委托-事件委托对于性能的提升" class="header-anchor">#</a> 13:什么是事件冒泡？事件捕获？如何阻止事件冒泡与默认行为？什么是事件委托？事件委托对于性能的提升？</h3> <p>事件冒泡、捕获与事件委托： 事件冒泡是指事件从最具体的元素开始逐级向上传播，事件捕获则相反，从最不具体的元素到最具体元素。阻止事件冒泡可以使用 event.stopPropagation()，阻止默认行为可以使用 event.preventDefault()。事件委托是利用事件冒泡的特性，将事件绑定在父元素上来代理处理子元素的事件，可以提升性能。</p> <h3 id="_14-模块化的了解-amd-cmd-commonjs-requirejs-以及-es6-的模块化"><a href="#_14-模块化的了解-amd-cmd-commonjs-requirejs-以及-es6-的模块化" class="header-anchor">#</a> 14:模块化的了解？AMD CMD commonJs requireJs 以及 ES6 的模块化</h3> <p>模块化： 模块化是指将代码分割为小的、独立的模块。在 JavaScript 中，有多种模块化规范，如 AMD、CommonJS、ES6 模块等。AMD 和 CommonJS 是用于浏览器和 Node.js 的模块化规范，而 ES6 的模块化是语言层面的支持。</p> <h3 id="_15-了解单例模式与观察者模式-可以模拟一个简单的观察者模式吗"><a href="#_15-了解单例模式与观察者模式-可以模拟一个简单的观察者模式吗" class="header-anchor">#</a> 15:了解单例模式与观察者模式？可以模拟一个简单的观察者模式吗？</h3> <p>单例模式与观察者模式： 单例模式确保一个类只有一个实例，并提供一个全局访问点。观察者模式定义了对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知。可以通过管理订阅者列表来模拟观察者模式。</p> <h3 id="_16-js-的垃圾回收机制-引用计数有什么本质问题"><a href="#_16-js-的垃圾回收机制-引用计数有什么本质问题" class="header-anchor">#</a> 16:js 的垃圾回收机制？引用计数有什么本质问题？</h3> <p>JavaScript 通过垃圾回收器来管理内存。其中最常用的算法是标记-清除（mark-and-sweep）：在这个过程中，垃圾回收器会标记所有被引用的对象，然后清除未被标记的对象，释放它们的内存。而引用计数是一种简单的垃圾回收方法，它通过跟踪每个值被引用的次数，当引用次数为零时便释放内存。然而，引用计数存在一个重大问题，即循环引用。假如两个对象相互引用，但是又不再被外部引用，这种情况下引用计数并不能释放这两个对象的内存，因为它们的引用计数不为零。因此，JavaScript 并不使用引用计数作为主要的垃圾回收机制。</p> <h3 id="_17-es6-的-set-与-map-对-symbol-有了解吗"><a href="#_17-es6-的-set-与-map-对-symbol-有了解吗" class="header-anchor">#</a> 17:ES6 的 set 与 map？对 symbol 有了解吗？</h3> <p>Set 是一种集合，它允许你存储唯一值，不重复。Map 是键值对的集合，与对象不同的是，Map 的键可以是任意类型的值。Symbol 是 ES6 引入的一种新的基本数据类型，表示唯一的、不可变的值。它通常用于创建对象的私有成员或者唯一的键。在对象属性中使用 Symbol 作为键可以确保不会被意外覆盖，因为 Symbol 的值是唯一的。</p> <h3 id="_18-什么是箭头函数-箭头函数中-this-指向哪里"><a href="#_18-什么是箭头函数-箭头函数中-this-指向哪里" class="header-anchor">#</a> 18:什么是箭头函数？箭头函数中 this 指向哪里？</h3> <p>箭头函数是 ES6 引入的新特性，它使用=&gt;语法来定义函数。箭头函数的 this 指向是静态的，它指向函数定义时所在的词法作用域的 this 值，而不是调用时的 this。因此，箭头函数内部没有自己的 this，它会捕获所在上下文的 this 值。这一点与传统的函数不同，传统函数的 this 是动态的，它在调用时才确定指向。</p> <h2 id="第二波"><a href="#第二波" class="header-anchor">#</a> 第二波</h2> <h3 id="_1-加载一个网页通常经历以下步骤"><a href="#_1-加载一个网页通常经历以下步骤" class="header-anchor">#</a> 1：加载一个网页通常经历以下步骤</h3> <ol><li>解析 URL： 首先，浏览器会解析输入的 URL，确定协议（如 HTTP 或 HTTPS）、主机名、端口号和路径等信息。</li> <li>DNS 解析： 浏览器会检查缓存中是否有该网址的 IP 地址，如果没有，则向 DNS 服务器发送请求以获取该网址的 IP 地址。</li> <li>建立 TCP 连接： 浏览器通过 IP 地址和端口号与服务器建立 TCP 连接，通过三次握手确立连接。</li> <li>发起 HTTP 请求： 浏览器向服务器发送一个 HTTP 请求，请求包括需要的资源类型（HTML、CSS、JavaScript 等）和其他参数。</li> <li>服务器处理请求并返回响应： 服务器收到请求后，根据请求的内容进行处理，并将相应的资源返回给浏览器。</li> <li>浏览器渲染页面： 浏览器接收到服务器返回的 HTML、CSS 和 JavaScript 等资源后，进行页面解析，构建 DOM 树（文档对象模型）、CSSOM 树（CSS 对象模型）和 JavaScript 引擎会处理 JavaScript 代码，并生成渲染树。</li> <li>页面渲染： 浏览器根据生成的渲染树开始绘制页面，计算每个元素的位置和大小，并将页面呈现给用户。</li> <li>页面加载完成： 所有资源都加载完成后，页面被完全渲染，并触发 load 事件。</li></ol> <h3 id="_2-new-生成一个对象的过程"><a href="#_2-new-生成一个对象的过程" class="header-anchor">#</a> 2：new 生成一个对象的过程</h3> <ol><li>创建一个新对象： 使用 new 关键字调用构造函数时，会创建一个新的空对象。</li> <li>设置新对象的原型： 新创建的对象会被赋予一个 [[Prototype]]（或者说是 <strong>proto</strong>）指针，指向构造函数的原型对象（prototype 属性所指向的对象）。</li> <li>执行构造函数： 构造函数会被调用，并且 this 指向新创建的对象。在构造函数内部，可以通过 this 来引用新对象，并对其进行属性和方法的赋值。</li> <li>返回新对象： 如果构造函数中没有显式返回一个对象，那么 new 表达式会隐式返回这个新创建的对象。如果构造函数返回了一个非对象类型的值（比如一个数字、字符串或者 null），则会忽略返回值，仍然返回新创建的对象。</li></ol> <h3 id="_3-请简单叙述一下原型链从-prototype、隐式的-proto、constructor-再到修改原型链的内容会导致的影响。"><a href="#_3-请简单叙述一下原型链从-prototype、隐式的-proto、constructor-再到修改原型链的内容会导致的影响。" class="header-anchor">#</a> 3：请简单叙述一下原型链从 prototype、隐式的 proto、constructor 再到修改原型链的内容会导致的影响。</h3> <p>原型链： JavaScript 中的每个对象都有一个 prototype 属性，它指向该对象的原型。每个对象都有一个隐藏属性 <strong>proto</strong>，指向其构造函数的 prototype。如果一个对象需要访问一个属性或方法，它会首先在自身属性中查找，如果找不到，就会沿着原型链向上查找，直到找到对应的属性或方法，或者到达原型链的顶端（Object.prototype）</p> <h3 id="_4-es6-了解吗-请简单说一下-promise-机制异步的承诺机制、顺势说了一下解决回调地狱的问题"><a href="#_4-es6-了解吗-请简单说一下-promise-机制异步的承诺机制、顺势说了一下解决回调地狱的问题" class="header-anchor">#</a> 4:ES6 了解吗？请简单说一下 promise 机制异步的承诺机制、顺势说了一下解决回调地狱的问题</h3> <p>ES6 Promise 机制： Promise 是一种用于处理异步操作的对象，它代表了一个异步操作的最终完成或者失败。Promise 有三种状态：pending、fulfilled、rejected，一旦状态改变就不会再变。使用 Promise 可以解决回调地狱问题，通过.then()方法和 catch()方法可以链式调用，更清晰地管理异步代码的执行顺序和处理异步操作。</p> <h3 id="_5-手写一下深拷贝"><a href="#_5-手写一下深拷贝" class="header-anchor">#</a> 5:手写一下深拷贝</h3> <p>通过 JSON.parse(JSON.stringify(obj)) 可以实现一个简单的深拷贝。这种方法可以将对象转换为字符串再转回对象，但它有一些限制，比如不能拷贝函数、循环引用等。对于复杂的对象，可能需要使用其他方法来实现深拷贝，比如递归遍历对象并创建一个全新的对象副本。</p> <h3 id="_6-如何改变-this-的指向-当然是-call、aplly、bind-紧接着问了一个这之间的区别"><a href="#_6-如何改变-this-的指向-当然是-call、aplly、bind-紧接着问了一个这之间的区别" class="header-anchor">#</a> 6:如何改变 this 的指向，当然是 call、aplly、bind，紧接着问了一个这之间的区别</h3> <p>call()、apply()、bind() 是用来改变函数执行时的 this 指向的方法。它们的区别在于传递参数的方式不同，call() 和 apply() 立即执行函数，而 bind() 返回一个新函数并指定新的 this，不立即执行。</p> <div class="language- extra-class"><pre class="language-text"><code>Product.call(this, name, price);
Product.apply(this, [name, price]);
</code></pre></div><h3 id="_7-与-的区别-typeof-null-的结果是什么"><a href="#_7-与-的区别-typeof-null-的结果是什么" class="header-anchor">#</a> 7: ==与===的区别 typeof null 的结果是什么</h3> <p>== 是松散相等，会进行类型转换后比较，而 === 是严格相等，要求类型和值都相等。typeof null 的结果是 'object'，这是一个历史遗留问题，实际上 null 应该属于原始数据类型。</p> <h3 id="_8-请求的方式有几种-并说说他们的异同"><a href="#_8-请求的方式有几种-并说说他们的异同" class="header-anchor">#</a> 8：请求的方式有几种，并说说他们的异同</h3> <p>请求的方式： 主要有 GET、POST、PUT、DELETE 等。它们的主要区别在于：
GET： 用于从服务器获取数据，请求的参数会附加在 URL 中，有长度限制，不适合传输敏感信息。
POST： 用于向服务器提交数据，请求的参数会作为请求体传输，没有长度限制，适合传输敏感信息。
PUT： 用于更新资源，类似于 POST，但是一般用于更新整个资源。
DELETE： 用于删除服务器上的资源。</p> <h3 id="_9-什么情况算是跨域-如何解决跨域问题"><a href="#_9-什么情况算是跨域-如何解决跨域问题" class="header-anchor">#</a> 9：什么情况算是跨域？如何解决跨域问题？</h3> <p>跨域问题与解决方法： 当发起请求的页面与请求的资源不在同一个域下时就会发生跨域问题。主要的解决方法包括：</p> <p>JSONP： 利用 <code>&lt;script&gt;</code> 标签的跨域特性，缺点是只能发送 GET 请求。
CORS（跨域资源共享）： 在服务端设置响应头来允许跨域请求。
代理： 在同源服务器上设置代理，将请求转发到目标服务器。
使用 iframe 或者 postMessage： 通过在不同域之间嵌套页面或者使用 postMessage 方法进行通信。</p> <h2 id="第三波"><a href="#第三波" class="header-anchor">#</a> 第三波</h2> <h3 id="一、基础-javascript-篇"><a href="#一、基础-javascript-篇" class="header-anchor">#</a> 一、基础 javascript 篇</h3> <h4 id="_1-get-请求传参长度的误区"><a href="#_1-get-请求传参长度的误区" class="header-anchor">#</a> 1. get 请求传参长度的误区</h4> <p><em><strong>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</strong></em></p> <p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p> <ul><li>HTTP 协议 未规定 GET 和 POST 的长度限制</li> <li>GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度</li> <li>不同的浏览器和 WEB 服务器，限制的最大长度不一样</li> <li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul> <h4 id="_2-补充-get-和-post-请求在缓存方面的区别"><a href="#_2-补充-get-和-post-请求在缓存方面的区别" class="header-anchor">#</a> 2. 补充 get 和 post 请求在缓存方面的区别</h4> <p>post/get 的请求区别，具体不再赘述。</p> <p>补充补充一个 get 和 post 在缓存方面的区别：</p> <ul><li>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li> <li>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</li></ul> <h4 id="_3-闭包"><a href="#_3-闭包" class="header-anchor">#</a> 3. 闭包</h4> <p>一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p> <h4 id="_4-类的创建和继承"><a href="#_4-类的创建和继承" class="header-anchor">#</a> 4. 类的创建和继承</h4> <p>（1）类的创建（es5）：new 一个 function，在这个 function 的 prototype 里面增加属性和方法。</p> <p>下面来创建一个 Animal 类：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义一个动物类</span>
<span class="token keyword">function</span> <span class="token function">Animal</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 属性</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Animal'</span><span class="token punctuation">;</span>
 <span class="token comment">// 实例方法</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在睡觉！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型方法</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">food</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在吃：'</span> <span class="token operator">+</span> food<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就生成了一个 Animal 类，实力化生成对象后，有方法和属性。</p> <p>（2）类的继承——原型链继承</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>

<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">--原型链继承
function Cat(){ }
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';
//&amp;emsp;Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat('fish'));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true
console.log(cat instanceof Cat); //true</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><ul><li>介绍：在这里我们可以看到 new 了一个空对象,这个空对象指向 Animal 并且 Cat.prototype 指向了这个空对象，这种就是基于原型链的继承。</li> <li>特点：基于原型链，既是父类的实例，也是子类的实例</li> <li>缺点：无法实现多继承</li></ul> <p>（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true`</span>
</code></pre></div><ul><li>特点：可以实现多继承</li> <li>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</li></ul> <p>（4）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true`</span>
</code></pre></div><ul><li>特点：可以继承实例属性/方法，也可以继承原型属性/方法</li> <li>缺点：调用了两次父类构造函数，生成了两份实例</li></ul> <p>（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个没有实例方法的类</span>
  <span class="token keyword">var</span> <span class="token function-variable function">Super</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">Super</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">//将实例作为子类的原型</span>
  <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true`</span>
</code></pre></div><ul><li>较为推荐</li></ul> <h4 id="_5-如何解决异步回调地狱"><a href="#_5-如何解决异步回调地狱" class="header-anchor">#</a> 5. 如何解决异步回调地狱</h4> <p>promise、generator、async/await</p> <h4 id="_6-说说前端中的事件流"><a href="#_6-说说前端中的事件流" class="header-anchor">#</a> 6. 说说前端中的事件流</h4> <p>HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll 等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p> <p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。</p> <ul><li>事件捕获阶段</li> <li>处于目标阶段</li> <li>事件冒泡阶段</li></ul> <p><strong>addEventListener</strong>：<strong>addEventListener</strong> 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p> <p><strong>IE 只支持事件冒泡</strong>。</p> <h4 id="_7-如何让事件先冒泡后捕获"><a href="#_7-如何让事件先冒泡后捕获" class="header-anchor">#</a> 7. 如何让事件先冒泡后捕获</h4> <p>在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p> <h4 id="_8-事件委托"><a href="#_8-事件委托" class="header-anchor">#</a> 8. 事件委托</h4> <ul><li>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</li> <li>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</li> <li>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</li></ul> <h4 id="_9-图片的懒加载和预加载"><a href="#_9-图片的懒加载和预加载" class="header-anchor">#</a> 9. 图片的懒加载和预加载</h4> <ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li> <li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li></ul> <p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p> <h4 id="_10-mouseover-和-mouseenter-的区别"><a href="#_10-mouseover-和-mouseenter-的区别" class="header-anchor">#</a> 10. mouseover 和 mouseenter 的区别</h4> <ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout</li> <li>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</li></ul> <h4 id="_11-js-的-new-操作符做了哪些事情"><a href="#_11-js-的-new-操作符做了哪些事情" class="header-anchor">#</a> 11. js 的 new 操作符做了哪些事情</h4> <p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。</p> <h4 id="_12-改变函数内部-this-指针的指向函数-bind-apply-call-的区别"><a href="#_12-改变函数内部-this-指针的指向函数-bind-apply-call-的区别" class="header-anchor">#</a> 12.改变函数内部 this 指针的指向函数（bind，apply，call 的区别）</h4> <ul><li>通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是 arg1,arg2...这种形式。</li> <li>通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。</li></ul> <h4 id="_13-js-的各种位置-比如-clientheight-scrollheight-offsetheight-以及-scrolltop-offsettop-clienttop-的区别"><a href="#_13-js-的各种位置-比如-clientheight-scrollheight-offsetheight-以及-scrolltop-offsettop-clienttop-的区别" class="header-anchor">#</a> 13. js 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h4> <ul><li>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</li> <li>offsetHeight：表示可视区域的高度，包含了 border 和滚动条</li> <li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</li> <li>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</li> <li>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</li></ul> <h4 id="_14-js-拖拽功能的实现"><a href="#_14-js-拖拽功能的实现" class="header-anchor">#</a> 14. js 拖拽功能的实现</h4> <ul><li><p>首先是三个事件，分别是 mousedown，mousemove，mouseup 当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</p></li> <li><p>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：</p> <p><strong>鼠标移动时候的坐标-鼠标按下去时候的坐标。</strong></p> <p>也就是说定位信息为：</p> <p>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</p></li> <li><p>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left 以及 top 等等值。</p></li></ul> <p>补充：也可以通过 html5 的拖放（Drag 和 drop）来实现</p> <h3 id="二、进阶-javascript-篇"><a href="#二、进阶-javascript-篇" class="header-anchor">#</a> 二、进阶 javascript 篇</h3> <h4 id="_3-代码的执行顺序"><a href="#_3-代码的执行顺序" class="header-anchor">#</a> 3.代码的执行顺序</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//输出2,6,5,3,4,1`</span>
</code></pre></div><blockquote><p>process.nextTick()： 这个方法会在当前执行栈的尾部，当前操作结束之后，下一次事件循环开始之前触发。它的优先级高于 then&gt; setTimeout() 和 setImmediate()。因此，process.nextTick() 的回调函数会在当前代码执行结束后、事件循环开始之前立即执行。</p></blockquote> <h4 id="_6-function-proto-getprototypeof-是什么"><a href="#_6-function-proto-getprototypeof-是什么" class="header-anchor">#</a> 6.Function.<strong>proto</strong>(getPrototypeOf)是什么？</h4> <p>获取一个对象的原型，在 chrome 中可以通过__proto__的形式，或者在 ES6 中可以通过 Object.getPrototypeOf 的形式。</p> <p>那么 Function.proto 是什么么？也就是说 Function 由什么对象继承而来，我们来做如下判别。</p> <p>javascript</p> <p><code>Function.__proto__==Object.prototype //false Function.__proto__==Function.prototype//true</code></p> <p>我们发现 Function 的原型也是 Function。</p> <p>我们用图可以来明确这个关系：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/10/1648412f2ed72c1d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="2018-07-10 2 38 27"></p> <h4 id="_7-实现-js-中所有对象的深度克隆-包装对象-date-对象-正则对象"><a href="#_7-实现-js-中所有对象的深度克隆-包装对象-date-对象-正则对象" class="header-anchor">#</a> 7.实现 js 中所有对象的深度克隆（包装对象，Date 对象，正则对象）</h4> <p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6 还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象 Number，String ， Boolean，以及 Date 对象，RegExp 对象的复制。</p> <h5 id="_1-前文的方法"><a href="#_1-前文的方法" class="header-anchor">#</a> (1)前文的方法</h5> <p>haxe</p> <p><code>function deepClone(obj){ var newObj= obj instanceof Array?[]:{}; for(var i in obj){ newObj[i]=typeof obj[i]=='object'? deepClone(obj[i]):obj[i]; } return newObj; }</code></p> <p>这种方法可以实现一般对象和数组对象的克隆，比如：</p> <p>haxe</p> <p><code>var arr=[1,2,3]; var newArr=deepClone(arr); // newArr-&gt;[1,2,3] var obj={ x:1, y:2 } var newObj=deepClone(obj); // newObj={x:1,y:2}</code></p> <p>但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：</p> <p>haxe</p> <p><code>//Number包装对象 var num=new Number(1); typeof num // &quot;object&quot; var newNum=deepClone(num); //newNum -&gt; {} 空对象 //String包装对象 var str=new String(&quot;hello&quot;); typeof str //&quot;object&quot; var newStr=deepClone(str); //newStr-&gt; {0:'h',1:'e',2:'l',3:'l',4:'o'}; //Boolean包装对象 var bol=new Boolean(true); typeof bol //&quot;object&quot; var newBol=deepClone(bol); // newBol -&gt;{} 空对象 ....</code></p> <h5 id="_2-valueof-函数"><a href="#_2-valueof-函数" class="header-anchor">#</a> (2)valueof()函数</h5> <p>所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的 valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。</p> <p>对于原始值或者包装类：</p> <p>haxe</p> <p><code>function baseClone(base){ return base.valueOf(); } //Number var num=new Number(1); var newNum=baseClone(num); //newNum-&gt;1 //String var str=new String('hello'); var newStr=baseClone(str); // newStr-&gt;&quot;hello&quot; //Boolean var bol=new Boolean(true); var newBol=baseClone(bol); //newBol-&gt; true</code></p> <p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说，</p> <p>这里用 valueOf 实现，语法上比较符合规范。</p> <p>对于 Date 类型：</p> <p>因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1 月 1 日以来的毫秒数.因此我们可以在 Date 的原型上定义克隆的方法：</p> <p>qml</p> <p><code>Date.prototype.clone=function(){ return new Date(this.valueOf()); } var date=new Date('2010'); var newDate=date.clone(); // newDate-&gt; Fri Jan 01 2010 08:00:00 GMT+0800</code></p> <p>对于正则对象 RegExp：</p> <p>javascript</p> <p><code>RegExp.prototype.clone = function() { var pattern = this.valueOf(); var flags = ''; flags += pattern.global ? 'g' : ''; flags += pattern.ignoreCase ? 'i' : ''; flags += pattern.multiline ? 'm' : ''; return new RegExp(pattern.source, flags); }; var reg=new RegExp('/111/'); var newReg=reg.clone(); //newReg-&gt; /\/111\//</code></p> <h4 id="_8-简单实现-node-的-events-模块"><a href="#_8-简单实现-node-的-events-模块" class="header-anchor">#</a> 8.简单实现 Node 的 Events 模块</h4> <p>简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p> <p>node 中的 Events 模块就是通过观察者模式来实现的：</p> <p>arcade</p> <p><code>var events=require('events'); var eventEmitter=new events.EventEmitter(); eventEmitter.on('say',function(name){ console.log('Hello',name); }) eventEmitter.emit('say','Jony yu');</code></p> <p>这样，eventEmitter 发出 say 事件，通过 On 接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个 Events 模块的 EventEmitter。</p> <h5 id="_1-实现简单的-event-模块的-emit-和-on-方法"><a href="#_1-实现简单的-event-模块的-emit-和-on-方法" class="header-anchor">#</a> (1)实现简单的 Event 模块的 emit 和 on 方法</h5> <p>kotlin</p> <p><code>function Events(){ this.on=function(eventName,callBack){ if(!this.handles){ this.handles={}; } if(!this.handles[eventName]){ this.handles[eventName]=[]; } this.handles[eventName].push(callBack); } this.emit=function(eventName,obj){ if(this.handles[eventName]){ for(var i=0;o&lt;this.handles[eventName].length;i++){ this.handles[eventName][i](obj); } } } return this; }</code></p> <p>这样我们就定义了 Events，现在我们可以开始来调用：</p> <p>arcade</p> <p><code>var events=new Events(); events.on('say',function(name){ console.log('Hello',nama) }); events.emit('say','Jony yu'); //结果就是通过emit调用之后，输出了Jony yu</code></p> <h5 id="_2-每个对象是独立的"><a href="#_2-每个对象是独立的" class="header-anchor">#</a> (2)每个对象是独立的</h5> <p>因为是通过 new 的方式，每次生成的对象都是不相同的，因此：</p> <p>arcade</p> <p><code>var event1=new Events(); var event2=new Events(); event1.on('say',function(){ console.log('Jony event1'); }); event2.on('say',function(){ console.log('Jony event2'); }) event1.emit('say'); event2.emit('say'); //event1、event2之间的事件监听互相不影响 //输出结果为'Jony event1' 'Jony event2'</code></p> <h4 id="_9-箭头函数中-this-指向举例"><a href="#_9-箭头函数中-this-指向举例" class="header-anchor">#</a> 9.箭头函数中 this 指向举例</h4> <p>javascript</p> <p><code>var a=11; function test2(){ this.a=22; let b=()=&gt;{console.log(this.a)} b(); } var x=new test2(); //输出22</code></p> <p>定义时绑定。</p> <h3 id="三、http、html-和浏览器篇"><a href="#三、http、html-和浏览器篇" class="header-anchor">#</a> 三、http、html 和浏览器篇</h3> <h4 id="_1-http-和-https"><a href="#_1-http-和-https" class="header-anchor">#</a> 1.http 和 https</h4> <p><strong><em>https 的 SSL 加密是在传输层实现的。</em></strong></p> <h5 id="_1-http-和-https-的基本概念"><a href="#_1-http-和-https-的基本概念" class="header-anchor">#</a> (1)http 和 https 的基本概念</h5> <p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p> <p>https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p> <p>https 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p> <h5 id="_2-http-和-https-的区别"><a href="#_2-http-和-https-的区别" class="header-anchor">#</a> (2)http 和 https 的区别？</h5> <p>http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。 主要的区别如下：</p> <ul><li>Https 协议需要 ca 证书，费用较高。</li> <li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li> <li>使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443</li> <li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li></ul> <h5 id="_3-https-协议的工作原理"><a href="#_3-https-协议的工作原理" class="header-anchor">#</a> (3)https 协议的工作原理</h5> <p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。</p> <ul><li>客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li> <li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li> <li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li> <li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li> <li>web 服务器通过自己的私钥解密出会话密钥。</li> <li>web 服务器通过会话密钥加密与客户端之间的通信。</li></ul> <h5 id="_4-https-协议的优点"><a href="#_4-https-协议的优点" class="header-anchor">#</a> (4)https 协议的优点</h5> <ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li> <li>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li> <li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li> <li>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。</li></ul> <h5 id="_5-https-协议的缺点"><a href="#_5-https-协议的缺点" class="header-anchor">#</a> (5)https 协议的缺点</h5> <ul><li>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li> <li>https 缓存不如 http 高效，会增加数据开销。</li> <li>SSL 证书也需要钱，功能越强大的证书费用越高。</li> <li>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ul> <h4 id="_2-tcp-三次握手-一句话概括"><a href="#_2-tcp-三次握手-一句话概括" class="header-anchor">#</a> 2.tcp 三次握手，一句话概括</h4> <p><strong><em>客户端和服务端都需要直到各自可收发，因此需要三次握手。</em></strong></p> <p>简化三次握手：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/10/16484133eee33c76~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="2018-07-10 3 42 11"></p> <p>从图片可以得到三次握手可以简化为：C 发起请求连接 S 确认，也发起连接 C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受 C 发送的报文段第二次握手：C 可以确认 S 收到了自己发送的报文段，并且可以确认 自己可以接受 S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段</p> <h4 id="_3-tcp-和-udp-的区别"><a href="#_3-tcp-和-udp-的区别" class="header-anchor">#</a> 3.TCP 和 UDP 的区别</h4> <p>（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</p> <p>（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p> <p>（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</p> <p>（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</p> <p>（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</p> <p>（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p> <h4 id="_4-websocket-的实现和应用"><a href="#_4-websocket-的实现和应用" class="header-anchor">#</a> 4.WebSocket 的实现和应用</h4> <h5 id="_1-什么是-websocket"><a href="#_1-什么是-websocket" class="header-anchor">#</a> (1)什么是 WebSocket?</h5> <p>WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个</p> <h5 id="_2-websocket-是什么样的协议-具体有什么优点"><a href="#_2-websocket-是什么样的协议-具体有什么优点" class="header-anchor">#</a> (2)WebSocket 是什么样的协议，具体有什么优点？</h5> <ul><li>HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。但是必须记住，在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。</li> <li>WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，upgrade，connection。</li></ul> <p>基本请求如下：</p> <p>http</p> <p><code>GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com</code></p> <p>多了下面 2 个属性：</p> <p>avrasm</p> <p><code>Upgrade:webSocket Connection:Upgrade 告诉服务器发送的是websocket Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13</code></p> <h4 id="_5-http-请求的方式-head-方式"><a href="#_5-http-请求的方式-head-方式" class="header-anchor">#</a> 5.HTTP 请求的方式，HEAD 方式</h4> <ul><li>head：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头</li> <li>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</li></ul> <h4 id="_6-一个图片-url-访问后直接下载怎样实现"><a href="#_6-一个图片-url-访问后直接下载怎样实现" class="header-anchor">#</a> 6.一个图片 url 访问后直接下载怎样实现？</h4> <p>请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http 头，决定用户下载行为的参数。</p> <p>下载的情况下：</p> <p>llvm</p> <p><code>1. x-oss-object-type: Normal 2. x-oss-request-id: 598D5ED34F29D01FE2925F41 3. x-oss-storage-class: Standard</code></p> <h4 id="_7-web-quality-无障碍"><a href="#_7-web-quality-无障碍" class="header-anchor">#</a> 7.web Quality （无障碍）</h4> <p>能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。 残障人士指的是那些带有残疾或者身体不健康的用户。</p> <p>使用 alt 属性：</p> <p>routeros</p> <p><code>&lt;img src=&quot;person.jpg&quot; alt=&quot;this is a person&quot;/&gt;</code></p> <p>有时候浏览器会无法显示图像。具体的原因有：</p> <ul><li>用户关闭了图像显示</li> <li>浏览器是不支持图形显示的迷你浏览器</li> <li>浏览器是语音浏览器（供盲人和弱视人群使用） 如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</li></ul> <h4 id="_8-几个很实用的-bom-属性对象方法"><a href="#_8-几个很实用的-bom-属性对象方法" class="header-anchor">#</a> 8.几个很实用的 BOM 属性对象方法?</h4> <p>什么是 Bom? Bom 是浏览器对象。有哪些常用的 Bom 属性呢？</p> <h5 id="_1-location-对象"><a href="#_1-location-对象" class="header-anchor">#</a> (1)location 对象</h5> <p>location.href-- 返回或设置当前文档的 URL location.search -- 返回 URL 中的查询字符串部分。例如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.dreamdu.com%2Fdreamdu.php%3Fid%3D5%26name%3Ddreamdu" title="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu" target="_blank" rel="noopener noreferrer">www.dreamdu.com/dreamdu.php…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 返回包括(?)后面的内容?id=5&amp;name=dreamdu location.hash -- 返回 URL#后面的内容，如果没有#，返回空 location.host -- 返回 URL 中的域名部分，例如www.dreamdu.com location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com location.pathname -- 返回 URL 的域名后的部分。例如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.dreamdu.com%2Fxhtml%2F" title="http://www.dreamdu.com/xhtml/" target="_blank" rel="noopener noreferrer">www.dreamdu.com/xhtml/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 返回/xhtml/ location.port -- 返回 URL 中的端口部分。例如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.dreamdu.com%3A8080%2Fxhtml%2F" title="http://www.dreamdu.com:8080/xhtml/" target="_blank" rel="noopener noreferrer">www.dreamdu.com:8080/xhtml/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 返回 8080 location.protocol -- 返回 URL 中的协议部分。例如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.dreamdu.com%3A8080%2Fxhtml%2F" title="http://www.dreamdu.com:8080/xhtml/" target="_blank" rel="noopener noreferrer">www.dreamdu.com:8080/xhtml/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 返回(//)前面的内容 http: location.assign -- 设置当前文档的 URL location.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url); location.reload() -- 重载当前页面</p> <h5 id="_2-history-对象"><a href="#_2-history-对象" class="header-anchor">#</a> (2)history 对象</h5> <p>history.go() -- 前进或后退指定的页面数 history.go(num); history.back() -- 后退一页 history.forward() -- 前进一页</p> <h5 id="_3-navigator-对象"><a href="#_3-navigator-对象" class="header-anchor">#</a> (3)Navigator 对象</h5> <p>navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie</p> <h4 id="_9-html5-drag-api"><a href="#_9-html5-drag-api" class="header-anchor">#</a> 9.HTML5 drag api</h4> <ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。</li> <li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li> <li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li> <li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li> <li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li> <li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li> <li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</li></ul> <h4 id="_10-http2-0"><a href="#_10-http2-0" class="header-anchor">#</a> 10.http2.0</h4> <p>首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议 简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。</p> <ul><li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0）</li> <li>允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li> <li>二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li> <li>首部压缩</li> <li>服务器端推送</li></ul> <h4 id="_11-补充-400-和-401、403-状态码"><a href="#_11-补充-400-和-401、403-状态码" class="header-anchor">#</a> 11.补充 400 和 401、403 状态码</h4> <h5 id="_1-400-状态码-请求无效"><a href="#_1-400-状态码-请求无效" class="header-anchor">#</a> (1)400 状态码：请求无效</h5> <p>产生原因：</p> <ul><li>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</li> <li>前端提交到后台的数据应该是 json 字符串类型，但是前端没有将对象 JSON.stringify 转化成字符串。</li></ul> <p>解决方法：</p> <ul><li>对照字段的名称，保持一致性</li> <li>将 obj 对象通过 JSON.stringify 实现序列化</li></ul> <h5 id="_2-401-状态码-当前请求需要用户验证"><a href="#_2-401-状态码-当前请求需要用户验证" class="header-anchor">#</a> (2)401 状态码：当前请求需要用户验证</h5> <h5 id="_3-403-状态码-服务器已经得到请求-但是拒绝执行"><a href="#_3-403-状态码-服务器已经得到请求-但是拒绝执行" class="header-anchor">#</a> (3)403 状态码：服务器已经得到请求，但是拒绝执行</h5> <h4 id="_12-fetch-发送-2-次请求的原因"><a href="#_12-fetch-发送-2-次请求的原因" class="header-anchor">#</a> 12.fetch 发送 2 次请求的原因</h4> <p><strong><em>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？</em></strong></p> <p>原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p> <h4 id="_13-cookie、sessionstorage、localstorage-的区别"><a href="#_13-cookie、sessionstorage、localstorage-的区别" class="header-anchor">#</a> 13.Cookie、sessionStorage、localStorage 的区别</h4> <p>共同点：都是保存在浏览器端，并且是同源的</p> <ul><li>Cookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）</li> <li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</li> <li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</li></ul> <p>补充说明一下 cookie 的作用：</p> <ul><li>保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li> <li>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便</li> <li>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用 cookie 来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li></ul> <h4 id="_14-web-worker"><a href="#_14-web-worker" class="header-anchor">#</a> 14.web worker</h4> <p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p> <p>如何创建 web worker：</p> <ul><li>检测浏览器对于 web worker 的支持性</li> <li>创建 web worker 文件（js，回传函数等）</li> <li>创建 web worker 对象</li></ul> <h4 id="_15-对-html-语义化标签的理解"><a href="#_15-对-html-语义化标签的理解" class="header-anchor">#</a> 15.对 HTML 语义化标签的理解</h4> <p>HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签。</p> <h4 id="_16-iframe-是什么-有什么缺点"><a href="#_16-iframe-是什么-有什么缺点" class="header-anchor">#</a> 16.iframe 是什么？有什么缺点？</h4> <p>定义：iframe 元素会创建包含另一个文档的内联框架 提示：可以将提示文字放在之间，来提示某些不支持 iframe 的浏览器</p> <p>缺点：</p> <ul><li>会阻塞主页面的 onload 事件</li> <li>搜索引擎无法解读这种页面，不利于 SEO</li> <li>iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</li></ul> <h4 id="_17-doctype-作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#_17-doctype-作用-严格模式与混杂模式如何区分-它们有何意义" class="header-anchor">#</a> 17.Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h4> <p>Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p> <ul><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li> <li>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</li></ul> <h4 id="_18-cookie-如何防范-xss-攻击"><a href="#_18-cookie-如何防范-xss-攻击" class="header-anchor">#</a> 18.Cookie 如何防范 XSS 攻击</h4> <p>XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：</p> <ul><li>httponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。</li> <li>secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。</li></ul> <p>结果应该是这样的：Set-Cookie=.....</p> <h4 id="_19-cookie-和-session-的区别"><a href="#_19-cookie-和-session-的区别" class="header-anchor">#</a> 19.Cookie 和 session 的区别</h4> <p>HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户</p> <h4 id="_20-一句话概括-restful"><a href="#_20-一句话概括-restful" class="header-anchor">#</a> 20. 一句话概括 RESTFUL</h4> <p><strong><em>就是用 URL 定位资源，用 HTTP 描述操作</em></strong></p> <h4 id="_21-讲讲-viewport-和移动端布局"><a href="#_21-讲讲-viewport-和移动端布局" class="header-anchor">#</a> 21.讲讲 viewport 和移动端布局</h4> <p>可以参考我的这篇文章：</p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fforthealllight%2Fblog%2Fissues%2F13" title="https://github.com/forthealllight/blog/issues/13" target="_blank" rel="noopener noreferrer">响应式布局的常用解决方案对比(媒体查询、百分比、rem 和 vw/vh）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_22-click-在-ios-上有-300ms-延迟-原因及如何解决"><a href="#_22-click-在-ios-上有-300ms-延迟-原因及如何解决" class="header-anchor">#</a> 22. click 在 ios 上有 300ms 延迟，原因及如何解决？</h4> <h5 id="_1-粗暴型-禁用缩放"><a href="#_1-粗暴型-禁用缩放" class="header-anchor">#</a> (1)粗暴型，禁用缩放</h5> <p>routeros</p> <p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt;</code></p> <h5 id="_2-利用-fastclick-其原理是"><a href="#_2-利用-fastclick-其原理是" class="header-anchor">#</a> (2)利用 FastClick，其原理是：</h5> <p>检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉</p> <h3 id="四、css-篇"><a href="#四、css-篇" class="header-anchor">#</a> 四、css 篇</h3> <h4 id="_1-css-盒模型"><a href="#_1-css-盒模型" class="header-anchor">#</a> 1.css 盒模型</h4> <p>简介：就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p> <p>border-sizing(有 3 个值哦)：border-box,padding-box,content-box.</p> <ul><li>标准盒子模型：</li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/10/1648419a623a69db~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="2018-07-10 4 24 03"></p> <ul><li>IE 盒子模型：</li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/10/1648419a6d29fa5e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="2018-07-10 4 24 12"></p> <p>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是 width 的包含范围，在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p> <p>标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width</p> <p>在 CSS3 中引入了 box-sizing 属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box 表示的是 IE 盒子模型</p> <p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右 padding+width</p> <p>也很好理解性记忆，包含什么，width 就从什么开始算起。</p> <h4 id="_2-画一条-0-5px-的线"><a href="#_2-画一条-0-5px-的线" class="header-anchor">#</a> 2.画一条 0.5px 的线</h4> <ul><li>采用 meta viewport 的方式</li> <li>采用 border-image 的方式</li> <li>采用 transform: scale()的方式</li></ul> <h4 id="_3-link-标签和-import-标签的区别"><a href="#_3-link-标签和-import-标签的区别" class="header-anchor">#</a> 3.link 标签和 import 标签的区别</h4> <ul><li>link 属于 html 标签，而@import 是 css 提供的</li> <li>页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。</li> <li>link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。</li> <li>link 方式样式的权重高于@import 的。</li></ul> <h4 id="_4-transition-和-animation-的区别"><a href="#_4-transition-和-animation-的区别" class="header-anchor">#</a> 4.transition 和 animation 的区别</h4> <p>Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation 不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从 from .... to，而 animation 可以一帧一帧的。</p> <h4 id="_5-flex-布局"><a href="#_5-flex-布局" class="header-anchor">#</a> 5.Flex 布局</h4> <p>文章链接： <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html%3Futm_source%3Dtuicool%25EF%25BC%2588%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587%25EF%25BC%2589" title="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89" target="_blank" rel="noopener noreferrer">www.ruanyifeng.com/blog/2015/0…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-examples.html%25EF%25BC%2588%25E5%25AE%259E%25E4%25BE%258B%25E7%25AF%2587%25EF%25BC%2589" title="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89" target="_blank" rel="noopener noreferrer">www.ruanyifeng.com/blog/2015/0…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p> <p>简单的分为容器属性和元素属性 容器的属性：</p> <ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法） .box { flex-direction: row | row-reverse | column | column-reverse; }</li> <li>flex-wrap：决定换行规则 .box{ flex-wrap: nowrap | wrap | wrap-reverse; }</li> <li>flex-flow： .box { flex-flow: || ; }</li> <li>justify-content：对其方式，水平主轴对齐方式</li> <li>align-items：对齐方式，竖直轴线方向</li></ul> <p>项目的属性（元素的属性）：</p> <ul><li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li> <li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li> <li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小</li> <li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li> <li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li> <li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖 align-items，默认属性为 auto，表示继承父元素的 align-items</li></ul> <p>比如说，用 flex 实现圣杯布局</p> <h4 id="_6-bfc-块级格式化上下文-用于清楚浮动-防止-margin-重叠等"><a href="#_6-bfc-块级格式化上下文-用于清楚浮动-防止-margin-重叠等" class="header-anchor">#</a> 6.BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）</h4> <p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p> <ul><li>BFC 区域不会与 float box 重叠</li> <li>BFC 是页面上的一个独立容器，子元素不会影响到外面</li> <li>计算 BFC 的高度时，浮动元素也会参与计算</li></ul> <p>那些元素会生成 BFC：</p> <ul><li>根元素</li> <li>float 不为 none 的元素</li> <li>position 为 fixed 和 absolute 的元素</li> <li>display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素</li> <li>overflow 不为 visible 的元素</li></ul> <h4 id="_7-垂直居中的方法"><a href="#_7-垂直居中的方法" class="header-anchor">#</a> 7.垂直居中的方法</h4> <h4 id="_1-margin-auto-法"><a href="#_1-margin-auto-法" class="header-anchor">#</a> (1)margin:auto 法</h4> <p>css:</p> <p>css</p> <p><code>div{ width: 400px; height: 400px; position: relative; border: 1px solid #465468; } img{ position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; }</code></p> <p>html:</p> <p>xml</p> <p>`</p><div><img src="mm.jpg"><p></p></div>`
<p>定位为上下左右为 0，margin：0 可以实现脱离文档流的居中.</p> <h5 id="_2-margin-负值法"><a href="#_2-margin-负值法" class="header-anchor">#</a> (2)margin 负值法</h5> <p>css</p> <p><code>.container{ width: 500px; height: 400px; border: 2px solid #379; position: relative; } .inner{ width: 480px; height: 380px; background-color: #746; position: absolute; top: 50%; left: 50%; margin-top: -190px; /*height的一半*/ margin-left: -240px; /*width的一半*/ }</code></p> <p>补充：其实这里也可以将 marin-top 和 margin-left 负值替换成， transform：translateX(-50%)和 transform：translateY(-50%)</p> <h5 id="_3-table-cell-未脱离文档流的"><a href="#_3-table-cell-未脱离文档流的" class="header-anchor">#</a> (3)table-cell（未脱离文档流的）</h5> <p>设置父元素的 display:table-cell,并且 vertical-align:middle，这样子元素可以实现垂直居中。</p> <p>css</p> <p><code>css: div{ width: 300px; height: 300px; border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center; } img{ vertical-align: middle; }</code></p> <h5 id="_4-利用-flex"><a href="#_4-利用-flex" class="header-anchor">#</a> (4)利用 flex</h5> <p>将父元素设置为 display:flex，并且设置 align-items:center;justify-content:center;</p> <p>css</p> <p><code>css: .container{ width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; } .inner{ border: 3px solid #458761; padding: 20px; }</code></p> <h4 id="_8-关于-js-动画和-css3-动画的差异性"><a href="#_8-关于-js-动画和-css3-动画的差异性" class="header-anchor">#</a> 8.关于 js 动画和 css3 动画的差异性</h4> <p>渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和 opacity，这时整个 CSS 动画得以在 compositor trhead 完成（而 js 动画则会在 main thread 执行，然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity 是不会 layout 或者 paint 的。 区别：</p> <ul><li>功能涵盖面，js 比 css 大</li> <li>实现/重构难度不一，CSS3 比 js 更加简单，性能跳优方向固定</li> <li>对帧速表现不好的低版本浏览器，css3 可以做到自然降级</li> <li>css 动画有天然事件支持</li> <li>css3 有兼容性问题</li></ul> <h4 id="_9-块元素和行元素"><a href="#_9-块元素和行元素" class="header-anchor">#</a> 9.块元素和行元素</h4> <p>块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 pading 以及高度和宽度 行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和 margin 会失 效。</p> <h4 id="_10-多行元素的文本省略号"><a href="#_10-多行元素的文本省略号" class="header-anchor">#</a> 10.多行元素的文本省略号</h4> <p>less</p> <p><code>display: -webkit-box -webkit-box-orient:vertical -web-line-clamp:3 overflow:hidden</code></p> <h4 id="_11-visibility-hidden-opacity-0-display-none"><a href="#_11-visibility-hidden-opacity-0-display-none" class="header-anchor">#</a> 11.visibility=hidden, opacity=0，display:none</h4> <p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p> <h4 id="_12-双边距重叠问题-外边距折叠"><a href="#_12-双边距重叠问题-外边距折叠" class="header-anchor">#</a> 12.双边距重叠问题（外边距折叠）</h4> <p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠</p> <p>折叠的结果为：</p> <p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。</p> <h2 id="第四波"><a href="#第四波" class="header-anchor">#</a> 第四波</h2> <h3 id="盒模型"><a href="#盒模型" class="header-anchor">#</a> 盒模型</h3> <p>盒模型感觉是刚学前端的时候就会接触到的问题。元素都是按照盒模型的规则布局在页面中的。盒模型由 <code>margin + border + padding + content</code> 四个属性组成，分为两种：W3C 的标准盒模型和 IE 盒模型。</p> <p><strong>W3C 的标准盒模型</strong></p> <p><code>width = content</code>，不包含 <code>border + padding</code></p> <p><strong>IE 盒模型</strong></p> <p><code>width = border + padding + content</code></p> <p><strong>相互转换</strong></p> <p>二者之间可以通过 CSS3 的 <code>box-sizing</code> 属性来转换。</p> <p><code>box-sizing: content-box</code> 是 W3C 盒模型</p> <p><code>box-sizing: border-box</code> 是 IE 盒模型</p> <h3 id="垂直居中的方法"><a href="#垂直居中的方法" class="header-anchor">#</a> 垂直居中的方法</h3> <p>垂直居中的方法，如果全写出来，有 10 多种。面试的时候一般都会说比较常用的几种。<code>flex</code>、<code>position + transform</code>、<code>position + 负margin</code>是最常见的三种情况。</p> <p>ini</p> <p><code>&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;</code></p> <p><strong>方法一：flex</strong></p> <p>css</p> <p><code>.outer{ display: flex; justify-content: center; align-items: center }</code></p> <p><strong>方法二： position + transform, inner 宽高未知</strong></p> <p>css</p> <p><code>.outer{ position:relative; } .inner{ position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); }</code></p> <p><strong>方法三：position + 负 margin, inner 宽高已知</strong></p> <p>css</p> <p><code>.outer{ position: relative; } .inner{ width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; }</code></p> <p><strong>方法四：设置各个方向的距离都是 0，再将 margin 设为 auto，也可以实现，前提是 inner 宽高已知</strong></p> <p>css</p> <p><code>.outer { position: relative; } .inner { width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; }</code></p> <h3 id="三栏布局"><a href="#三栏布局" class="header-anchor">#</a> 三栏布局</h3> <p>三栏布局是很常见的一种页面布局方式。左右固定，中间自适应。实现方式有很多种方法。</p> <p><strong>第一种：flex</strong></p> <p>css</p> <p><code>&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; .container{ display: flex; } .left{ flex-basis:200px; background: green; } .main{ flex: 1; background: red; } .right{ flex-basis:200px; background: green; }</code></p> <p><strong>第二种：position + margin</strong></p> <p>css</p> <p><code>&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;/div&gt; body,html{ padding: 0; margin: 0; } .left,.right{ position: absolute; top: 0; background: red; } .left{ left: 0; width: 200px; } .right{ right: 0; width: 200px; } .main{ margin: 0 200px ; background: green; }</code></p> <p><strong>第三种：float + margin</strong></p> <p>css</p> <p><code>&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;/div&gt; body,html{ padding:0; margin: 0; } .left{ float:left; width:200px; background:red; } .main{ margin:0 200px; background: green; } .right{ float:right; width:200px; background:red; }</code></p> <h3 id="css-权重计算方式"><a href="#css-权重计算方式" class="header-anchor">#</a> CSS 权重计算方式</h3> <p>CSS 基本选择器包含 ID 选择器、类选择器、标签选择器、通配符选择器。 正常情况下，一般都能答出<code>!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器</code>。</p> <p>但如果这几种选择器同时作用于一个元素时，该元素最后应用哪个样式呢？这就涉及到权重计算的问题。 关于权重计算，有两种不同的计算方式：一种是以二进制的规则计算，一种是以 1,10,100,1000 这种的计算方式。我更倾向于二进制的这种方式。</p> <p><strong>各选择器权值：</strong></p> <ul><li>内联样式，权值为 1000</li> <li>ID 选择器，权值为 0100</li> <li>类，伪类和属性选择器，权值为 0010</li> <li>标签选择器和伪元素选择器，权值为 0001</li> <li>通配符、子选择器、相邻选择器等，权值为 0000</li> <li>继承的样式没有权值</li></ul> <p><strong>比较方式：</strong></p> <p>如果层级相同，继续往后比较，如果层级不同，层级高的权重大，不论低层级有多少个选择器。</p> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <p>BFC 的全称为 <code>Block Formatting Context</code>，也就是块级格式化上下文的意思。</p> <p><strong>以下方式都会创建 BFC：</strong></p> <ul><li>根元素(html)</li> <li>浮动元素（元素的 float 不是 none）</li> <li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li> <li>行内块元素（元素的 display 为 inline-block）</li> <li>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）</li> <li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li> <li>匿名表格单元格元素（元素的 display 为 table、table-row、table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li> <li>overflow 值不为 visible 的块元素</li> <li>display 值为 flow-root 的元素</li> <li>contain 值为 layout、content 或 paint 的元素</li> <li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li> <li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li> <li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li></ul> <p><strong>BFC 布局规则：</strong></p> <ol><li>内部的 box 会在垂直方向，一个接一个的放置。</li> <li>box 垂直方向的距离有 margin 决定。属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠。</li> <li>每个元素的左外边距与包含块的左边界相接触，即使浮动元素也是如此。</li> <li>BFC 的区域不会与 float 的元素区域重叠。</li> <li>计算 BFC 的高度时，浮动子元素也参与计算。</li> <li>BFC 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li></ol> <p><strong>BFC 能解决的问题：</strong></p> <ol><li>父元素塌陷</li> <li>外边距重叠</li> <li>清除浮动</li></ol> <h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="header-anchor">#</a> 清除浮动的方法</h3> <p>清除浮动主要是为了防止父元素塌陷。清除浮动的方法有很多，常用的是 <code>clearfix</code> 伪类。</p> <p><strong>方法一：clearfix</strong></p> <p>css</p> <p><code>&lt;div class=&quot;outer clearfix&quot;&gt; &lt;div class=&quot;inner&quot;&gt;inner&lt;/div&gt; &lt;/div&gt; .outer{ background: blue; } .inner{ width: 100px; height: 100px; background: red; float: left; } .clearfix:after{ content: &quot;&quot;; display: block; height: 0; clear:both; visibility: hidden; }</code></p> <p><strong>方法二：额外加一个 div，clear:both</strong></p> <p>css</p> <p><code>&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; .container{ background: blue; } .inner { width: 100px; height: 100px; background: red; float: left; } .clear{ clear:both; }</code></p> <p><strong>方法三：触发父盒子 BFC，overflow:hidden</strong></p> <p>css</p> <p><code>&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;inner&lt;/div&gt; &lt;/div&gt; .outer{ background: blue; overflow: hidden; } .inner { width: 100px; height: 100px; background: red; float: left; }</code></p> <h3 id="flex-布局"><a href="#flex-布局" class="header-anchor">#</a> flex 布局</h3> <p><code>flex</code> 布局现在已经很普及的在用了。垂直居中用 <code>flex</code> 实现起来很简单。关于 <code>flex</code> 的属性也不是很多，父容器和子容器各 6 个，一共 12 个，比较好记。</p> <p>下面是我复习 flex 属性时的一张导图。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/14/16dca9f0ef712b7a~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <h3 id="position-属性"><a href="#position-属性" class="header-anchor">#</a> position 属性</h3> <p>position 属性的重要性应该没啥可说的了。想必谁都回答的上来。</p> <ul><li><code>absolute</code> 绝对定位，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</li> <li><code>relative</code> 相对定位，相对于其自身正常位置进行定位。</li> <li><code>fixed</code> 固定定位，相对于浏览器窗口进行定位。</li> <li><code>static</code> 默认值。没有定位，元素出现在正常的流中。</li> <li><code>inherit</code> 规定应该从父元素继承 position 属性的值。</li></ul> <p>但是要注意一个问题，<code>absolute</code> 是相对于父元素的哪个属性进行定位的？通过下面的例子我们来看一看。</p> <p>css</p> <p><code>.container{ position: relative; width: 30px; height: 30px; margin: 20px; border: 10px solid red; padding: 10px; background: blue; } .inner { position: absolute; width: 10px; height: 10px; top: 0; left: 0; background: pink; }</code></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/13/16dc5ac40cc1d842~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p>从上图可以看出，是相对于 <code>static</code> 定位以外的第一个父元素的 <strong><code>padding</code></strong> 来定位的。</p> <p>CSS3 中新增了一个 <code>position:sticky</code> 属性，该属性的作用类似 <code>position:relative</code> 和 <code>position:fixed</code>的结合。元素在跨越特定阈值前为相对定位，之后为固定定位。必须指定 <code>top, right, bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。但 <code>sticky</code> 尚在实验性阶段。</p> <h3 id="如何实现一个自适应的正方形"><a href="#如何实现一个自适应的正方形" class="header-anchor">#</a> 如何实现一个自适应的正方形</h3> <p><strong>方法 1：利用 CSS3 的 vw 单位</strong></p> <p><code>vw</code> 会把视口的宽度平均分为 100 份</p> <p>css</p> <p><code>.square { width: 10vw; height: 10vw; background: red; }</code></p> <p><strong>方法 2：利用 margin 或者 padding 的百分比计算是参照父元素的 width 属性</strong></p> <p>css</p> <p><code>.square { width: 10%; padding-bottom: 10%; height: 0; // 防止内容撑开多余的高度 background: red; }</code></p> <h3 id="如何用-css-实现一个三角形"><a href="#如何用-css-实现一个三角形" class="header-anchor">#</a> 如何用 css 实现一个三角形</h3> <p><strong>方法 1： 利用 border 属性</strong></p> <p>利用盒模型的 <code>border</code> 属性上下左右边框交界处会呈现出平滑的斜线这个特点，通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形。</p> <p>css</p> <p><code>.triangle { height:0; width:0; border-color:red blue green pink; border-style:solid; border-width:30px; }</code></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/13/16dc5881277c896c~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p>如果想实现其中的任一个三角形，把其他方向上的 <code>border-color</code> 都设置成透明即可。</p> <p>css</p> <p><code>.triangle { height:0; width:0; border-color:red transparent transparent transparent; border-style:solid; border-width:30px; }</code></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/13/16dc58ad2033b4be~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p><strong>方法二： 利用 CSS3 的 clip-path 属性</strong></p> <p>不了解 <code>clip-path</code> 属性的可以先看看 <code>MDN</code> 上的介绍：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2Fclip-path" title="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path" target="_blank" rel="noopener noreferrer">chip-path<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>css</p> <p><code>.triangle { width: 30px; height: 30px; background: red; clip-path: polygon(0px 0px, 0px 30px, 30px 0px); // 将坐标(0,0),(0,30),(30,0)连成一个三角形 transform: rotate(225deg); // 旋转225，变成下三角 }</code></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/13/16dc594b5da448fc~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <h3 id="前端有哪些页面优化方法"><a href="#前端有哪些页面优化方法" class="header-anchor">#</a> 前端有哪些页面优化方法?</h3> <ul><li>减少 HTTP 请求数</li> <li>从设计实现层面简化页面</li> <li>合理设置 HTTP 缓存</li> <li>资源合并与压缩</li> <li>合并 CSS 图片，减少请求数的又一个好办法。</li> <li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li> <li>多图片网页使用图片懒加载。</li> <li>在 js 中尽量减少闭包的使用</li> <li>尽量合并 css 和 js 文件</li> <li>尽量使用字体图标或者 SVG 图标，来代替传统的 PNG 等格式的图片</li> <li>减少对 DOM 的操作</li> <li>在 JS 中避免“嵌套循环”和 “死循环”</li> <li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul> <h3 id="ajax-的状态码"><a href="#ajax-的状态码" class="header-anchor">#</a> ajax 的状态码</h3> <ul><li>200 : 代表请求成功；</li> <li>301 : 永久重定向；</li> <li>302: 临时转移</li> <li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li> <li>307:临时重定向</li> <li>400 :数据/格式错误</li> <li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li> <li>404 : 路径错误，找不到文件</li> <li>500 : 服务器的问题</li> <li>503: 超负荷；</li></ul> <h3 id="移动端兼容"><a href="#移动端兼容" class="header-anchor">#</a> 移动端兼容</h3> <ul><li>给移动端添加点击事件会有 300S 的延迟</li> <li>如果用点击事件，需要引一个 fastclick.js 文件，解决 300s 的延迟</li> <li>一般在移动端用 ontouchstart、ontouchmove、ontouchend</li> <li>移动端点透问题,touchstart 早于 touchend 早于 click,click 的触发是有延迟的，这个时间大概在 300ms 左右，也就是说我们 tap 触发之后蒙层隐藏， 此时 click 还没有触发，300ms 之后由于蒙层隐藏，我们的 click 触发到了下面的 a 链接上</li> <li>尽量都使用 touch 事件来替换 click 事件。例如用 touchend 事件(推荐)。</li> <li>用 fastclick，github.com/ftlabs/fast…</li> <li>用 preventDefault 阻止 a 标签的 click</li></ul> <h2 id="第五波"><a href="#第五波" class="header-anchor">#</a> 第五波</h2> <h3 id="_1-如何理解-js-中的this关键字"><a href="#_1-如何理解-js-中的this关键字" class="header-anchor">#</a> 1.如何理解 JS 中的<code>this</code>关键字？</h3> <hr> <p>JS 初学者总是对 <code>this</code> 关键字感到困惑，因为与其他现代编程语言相比，JS 中的这<code>this</code>关键字有点棘手。 “this” 一般是表示当前所在的对象，但是事情并没有像它应该的那样发生。JS 中的<code>this</code>关键字由函数的调用者决定，谁调用就<code>this</code>就指向哪个。如果找不到调用者，<code>this</code>将指向<code>windows</code>对象。</p> <p>来几个粟子</p> <p>第一个例子很简单。 调用 <code>test</code>对象中的 <code>func()</code>，因此<code>func()</code> 中的'this'指向的是 <code>test</code> 对象，所以打印的 <code>prop</code> 是 <code>test</code> 中的 <code>prop</code>，即 <code>42</code>。</p> <p>javascript</p> <p><code>var test = { prop: 42, func: function(){ return this.prop; }, }; console.log (test.func()); // 42</code></p> <p>如果我们直接调用<code>getFullname</code>函数，第二个例子将打印出<code>'David Jones'</code>，因为此时 <code>this</code> 找不到调用者，所以默认就为 <code>window</code> 对象，打印的 <code>fullname</code> 即是全局的。</p> <p>javascript</p> <div class="language- extra-class"><pre><code>`var fullname = ‘David Jones’     var obj ={     fullname: ‘Colin Brown’,     prop:{       fullname:’Aurelio Deftch’,       getFullname: function(){         return this.fullname;       }      }     }     var test = obj.prop.getFullname     console.log(test()) // David Jones     obj.prop.getFullname() // ‘Aurelio Deftch’`
</code></pre></div><h3 id="_2-由于-this-关键字很混乱-如何解决这个问题"><a href="#_2-由于-this-关键字很混乱-如何解决这个问题" class="header-anchor">#</a> 2. 由于 <code>this</code> 关键字很混乱，如何解决这个问题</h3> <hr> <p>有很多方法可以解决这个问题; 但是，无论你选择哪种解决方案，最重要的是要知道你决定让 <code>this</code> 指向哪个对象。</p> <p>一旦你弄清楚了<code>this</code>指向的对象，你就可以直接将它改成对象名。 否则，使用<code>bind</code>，<code>call</code>，<code>apply</code>函数也可以解决问题。</p> <h3 id="_3-什么是闭包"><a href="#_3-什么是闭包" class="header-anchor">#</a> 3.什么是闭包</h3> <hr> <p>当我第一次解释闭包时，我常说函数中的函数;但是，它没有正确地描述闭包的确切含义。</p> <p>闭包是在另一个作用域内创建一个封闭的词法范围。它通常会自动返回来生成这个词法环境。这个环境由创建闭包时在作用域内的任何局部变量组成。它就像一个微型工厂，用这些原料生产出具有特定功能的产品。</p> <p>scss</p> <p><code>function add(n){ var num = n return function addTo(x){ return x + num } } addTwo = add(2) addTwo(5)</code></p> <p>闭包的另一个应用是创建私有变量和方法。JavaScript 不像 Java 那样可以很好地支持 oop。在 JS 中没有明确的方法来创建私有方法，但是闭包可以私有方法。</p> <h3 id="_4-解释一下变量的提升"><a href="#_4-解释一下变量的提升" class="header-anchor">#</a> 4.解释一下变量的提升</h3> <hr> <p>变量的提升是 JavaScript 的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。</p> <p>javascript</p> <p><code>var x = 1 console.log(x + '——' + y) // 1——undefined var y = 2</code></p> <h3 id="_5-javascript-如何处理同步和异步情况"><a href="#_5-javascript-如何处理同步和异步情况" class="header-anchor">#</a> 5. JavaScript 如何处理同步和异步情况</h3> <hr> <p>尽管 JavaScript 是一种只有一个调用堆栈的<strong>单线程</strong>编程语言，但它也可以使用一个称为**事件循环(event loop)**的机制来处理一些异步函数。从基本级别了解 JavaScript 如何工作是理解 JS 如何处理异步的关键部分。</p> <p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c71c18aba93f464295e25594190184b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0ea80c2e8144a1c966a35f6adcb9315~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p>如图所示，调用堆栈是定位函数的位置。一旦函数被调用，函数将被推入堆栈。然而，异步函数不会立即被推入调用堆栈，而是会被推入<strong>任务队列(Task Queue)</strong>，并在调用堆栈为空后执行。将事件从任务队列传输到调用堆栈称为<strong>事件循环</strong>。</p> <h3 id="_6-如何理解事件委托"><a href="#_6-如何理解事件委托" class="header-anchor">#</a> 6. 如何理解事件委托</h3> <hr> <p>在 DOM 树上绑定事件监听器并使用 JS 事件处理程序是处理客户端事件响应的典型方法。 从理论上讲，我们可以将监听器附加到 HTML 中的任何 DOM 元素，但由于事件委派，这样做是浪费而且没必要的。</p> <p>** 什么是事件委托？**</p> <p>这是一种让父元素上的事件监听器也影响子元素的技巧。 通常，事件传播（<strong>捕获和冒泡</strong>）允许我们实现事件委托。 冒泡意味着当触发子元素（目标）时，也可以逐层触发该子元素的父元素，直到它碰到 DOM 绑定的原始监听器（当前目标）。 捕获属性将事件阶段转换为捕获阶段，让事件下移到元素; 因此，触发方向与冒泡阶段相反。 捕获的默认值为<code>false</code>。</p> <h3 id="_7-如何理解高阶函数"><a href="#_7-如何理解高阶函数" class="header-anchor">#</a> 7. 如何理解高阶函数</h3> <hr> <p>JavaScript 中的一切都是对象，包括函数。我们可以将变量作为参数传递给函数，函数也是如此。我们调用接受和或返回另一个函数称为高阶函数的函数。</p> <h3 id="_8-如何区分声明函数和表达式函数"><a href="#_8-如何区分声明函数和表达式函数" class="header-anchor">#</a> 8. 如何区分声明函数和表达式函数</h3> <hr> <p>csharp</p> <p><code>// 声明函数 function hello() { return &quot;HELLO&quot; } // 表达式函数 var h1 = function hello() { return &quot;HELLO&quot; }</code></p> <p>两个函数将在不同的时期定义。在解析期间定义声明，在运行时定义表达式;因此，如果我们控制台打印 <code>h1</code>，它将显示<code>HELLO</code>。</p> <h3 id="_9-解释原型继承是如何工作的"><a href="#_9-解释原型继承是如何工作的" class="header-anchor">#</a> 9.解释原型继承是如何工作的</h3> <hr> <p>JavaScript 不是一种面向对象的友好编程语言，但它仍然使用继承的思想来实现依赖关系，并使用许多内置函数使其灵活使用。了解原型继承的工作原理将使你很好地理解 JavaScript 知识，从而避免概念上的误用。</p> <p>最好在大脑中描绘一下 JavaScript 的整个机制，以了解原型继承。</p> <p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630486cb03af49d8a8680c000653f5b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p> <p>JavaScript 中有一个超级对象，所有对象都将从中继承。 <code>'__ proto__'</code>指向的对象的<code>Prototype</code>内部属性。 原型(prototype )包含一个构造函数，使对象能够从中创建实例。 <code>__proto__</code>始终存在于对象中，并且分层指向它所属的原型，直到<code>null</code>，这称为<strong>原型链</strong>。</p> <h3 id="_10-解释一下严格模式-strict-mode"><a href="#_10-解释一下严格模式-strict-mode" class="header-anchor">#</a> 10. 解释一下严格模式(strict mode)</h3> <hr> <p>严格模式用于标准化正常的 JavaScript 语义。严格模式可以嵌入到非严格模式中，关键字 <code>‘use strict’</code>。使用严格模式后的代码应遵循 JS 严格的语法规则。例如，分号在每个语句声明之后使用。</p> <h2 id="第六波"><a href="#第六波" class="header-anchor">#</a> 第六波</h2> <h3 id="_1-js中的垃圾回收机制"><a href="#_1-js中的垃圾回收机制" class="header-anchor">#</a> 1.js中的垃圾回收机制</h3> <blockquote><p>什么是内存泄漏</p></blockquote> <p>内存是运行时操作系统分配给浏览器的内存空间，对于正在运行的内存需要及时释放，如果不及时释放，内存会越来越高，轻则影响系统性能，重则导致进程崩溃。不在使用的内存没有及时释放，就叫做内存泄漏。</p> <p>影响内存泄漏的原因</p> <ul><li>全局的声明变量，解决：使用var let、const</li> <li>忘记关闭的定时器</li> <li>使用闭包</li></ul> <blockquote><p>垃圾回收机制</p></blockquote> <ul><li><p>标记清除</p> <p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p></li> <li><p>引用计数</p></li></ul> <p>​	另一种<strong>没那么常用的</strong>垃圾回收策略是<strong>引用计数</strong>（referencecounting）。其思路是对每个值都记录它被引用的次数。声明量	并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值	引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地	收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。但是会有循环引用的问题，导出出现bug.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/interview/随机题库-手写.html">
        随机题库-手写
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.ce2c2954.js" defer></script><script src="/blog/assets/js/2.245720e2.js" defer></script><script src="/blog/assets/js/133.c525dbfa.js" defer></script>
  </body>
</html>
