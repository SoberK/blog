(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{281:function(t,v,_){t.exports=_.p+"assets/img/image-2.56046193.png"},366:function(t,v,_){"use strict";_.r(v);var a=_(14),i=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"_10-你了解diff算法吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-你了解diff算法吗"}},[t._v("#")]),t._v(" 10.你了解diff算法吗？")]),t._v(" "),v("p",[t._v("1.vue中的diff算法称为patching算法，它由Snabbdom修改而来，虛拟DOM要想转化为真实DOM就需要通过patch方法转换。")]),t._v(" "),v("p",[t._v("2.vue中diff执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行render函数获得最新的虛拟DOM，然后执行patch函数，并传入新旧两次虛拟DOM，通过比对两者找到变化的地方，最后将其转化为对应的DOM操作。")]),t._v(" "),v("p",[t._v("patchVnode主要做了几个判断：")]),t._v(" "),v("ul",[v("li",[t._v("新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容")]),t._v(" "),v("li",[t._v("新节点和旧节点如果都有子节点，则处理比较更新子节点\n"),v("ul",[v("li",[t._v("只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点")]),t._v(" "),v("li",[t._v("只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除")])])])]),t._v(" "),v("p",[v("strong",[t._v("diff 分为三类比较：")])]),t._v(" "),v("p",[t._v("1.相同类型节点比较：只会对属性进行重设，从而实现节点的转变")]),t._v(" "),v("p",[t._v("2.不同类型节点比较：会直接删除旧的节点，创建新的节点代替。")]),t._v(" "),v("p",[t._v("3.列表节点比较：开发手动添加key,帮助react定位到正确的节点，减少dom操作次数。")]),t._v(" "),v("p",[t._v("1.虛拟dom顾名思义就是虛拟的dom对象，它本身就是一个Javascript对象，只不过它是通过不同的属性去描述一个视图结构。\n"),v("img",{attrs:{src:_(281)}})])])}),[],!1,null,null,null);v.default=i.exports}}]);