(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{380:function(t,e,v){"use strict";v.r(e);var s=v(14),u=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_20-简单说一下vuex理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-简单说一下vuex理解"}},[t._v("#")]),t._v(" 20.简单说一下vuex理解")]),t._v(" "),e("ol",[e("li",[t._v("vuex 是一个专为 vuejs 应用开发的状态管理模式 ＋ 库。它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")]),t._v(" "),e("li",[t._v("我们期待以一种简单的”单向数据流”的方式管理应用，即状态-＞视图-＞操作 单向循环的方式。但当我们的应用遇到多个组件共享状态时，比如：多个视图依赖于同一状态或者来自不同视图的行为需要变更同一状态。此时单向数据流的简洁性很容易被破坏。因此，我们有必要把组件的共享状态抽取出来，以一个全局单例模式管理。通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。这是vex存在的必要性，它和react生态中的redux之类是一个概念，")]),t._v(" "),e("li",[t._v("vuex 解决状态管理的同时引(入了不少概念：例如state、mutation、action等，是否需要引入还需要根据应用的实际情况衡量一下：如果不打算开发大型单页应用，使用vuex 反而是繁琐元余的，一个简单的 store模式就足够了。但是，如果要构建一个中大型单页应用，vuex 基本是标配.")]),t._v(" "),e("li",[t._v("我在使用vuex过程中感受到一些")])])])}),[],!1,null,null,null);e.default=u.exports}}]);