(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{321:function(t,e,l){"use strict";l.r(e);var n=l(14),u=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_16-说一下vue子组件和父组件的创建和挂在顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-说一下vue子组件和父组件的创建和挂在顺序"}},[t._v("#")]),t._v(" 16.说一下vue子组件和父组件的创建和挂在顺序")]),t._v(" "),e("ul",[e("li",[t._v("给结论\n"),e("ul",[e("li",[t._v("创建过程中自上而下，挂在过程中自下而上\n"),e("ul",[e("li",[t._v("Parent created")]),t._v(" "),e("li",[t._v("Child created")]),t._v(" "),e("li",[t._v("Child mounted")]),t._v(" "),e("li",[t._v("Parent mounted")])])])])]),t._v(" "),e("li",[t._v("说理由\n"),e("ul",[e("li",[t._v("之所以会这样，因为vue创建过程是一个递归，县创建父组件，有自组建会创建子组件，因此创建时现有父组件再有自组建，子组建首次创建时会添加到mouted钩子到列队，等patch结束后再执行他们，可见子组件的mountd钩子是先进入到队列中的，因此patch结束执行这些钩子时也先执行，后进先出")])])])])])}),[],!1,null,null,null);e.default=u.exports}}]);