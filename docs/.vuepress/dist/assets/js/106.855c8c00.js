(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{389:function(e,r,t){"use strict";t.r(r);var v=t(14),i=Object(v.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"_28-ref-和-reactive-有何差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_28-ref-和-reactive-有何差异"}},[e._v("#")]),e._v(" 28.ref 和 reactive 有何差异")]),e._v(" "),r("ul",[r("li",[e._v("可接受参数类型不同：ref 支持对象和单值，reactive 只支持对象")]),e._v(" "),r("li",[e._v("这是因为二者响应式数据实现的方式不同\n"),r("ul",[r("li",[e._v("ref 是通过一个中间对象 RefImpl 持有数据，并通过重写它的 set 和 get 方法实现数据劫持的，本质上依旧是通过 Object.defineProperty 对 RefImpl 的 value 属性进行劫持。")]),e._v(" "),r("li",[e._v("reactive 则是通过 Proxy 进行劫持的。Proxy 无法对基本数据类型进行操作，进而导致 reactive 在面对基本数据类型时的束手无策。")])])]),e._v(" "),r("li",[e._v("返回值类型不一样，一个返回refImpl一个返回proxy")]),e._v(" "),r("li",[e._v("访问数据方式不同：ref需要.value访问，reactive可以直接访问")]),e._v(" "),r("li",[e._v("原始对象的可变性不同\n"),r("ul",[r("li",[e._v("ref 的值变了，不影响响应式")]),e._v(" "),r("li",[e._v("reactive整个值变了就会影响响应式")])])]),e._v(" "),r("li",[e._v("ref如果要被watch监听需要设置deep:true,而reactive不需要")])])])}),[],!1,null,null,null);r.default=i.exports}}]);