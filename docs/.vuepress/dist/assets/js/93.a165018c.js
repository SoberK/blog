(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{374:function(v,e,t){"use strict";t.r(e);var n=t(14),o=Object(n.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"_34-v-once使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34-v-once使用场景"}},[v._v("#")]),v._v(" 34.v-once使用场景")]),v._v(" "),e("ol",[e("li",[v._v("v-once 是vue 的内置指令，作用是仅渲染指定组件或元素一次，并跳过末来对其更新。")]),v._v(" "),e("li",[v._v("如果我们有一些元素或者组件在初始化渲染之后不再需要变化，这种情况下适合使用 v-once，这样哪")]),v._v(" "),e("li",[v._v("怕这些数据变化，vue 也会跳过更新，是一种代码优化手段。")]),v._v(" "),e("li",[v._v("我们只需要作用的组件或元素上加上 v-once 即可。")]),v._v(" "),e("li",[v._v("vue3.2 之后，又增加了 v-memo 指令，可以有条件缓存部分模板并控制它们的更新，可以说控制力更强")]),v._v(" "),e("li",[v._v("编译器发现元素上面有 v-once 时，会将首次计算结果存入缓存对象，组件再次渲染时就会从缓存获取，从而避免再次计算。")])])])}),[],!1,null,null,null);e.default=o.exports}}]);