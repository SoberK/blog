(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{406:function(t,e,r){"use strict";r.r(e);var l=r(14),v=Object(l.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_45-再什么场景下会使用到嵌套路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_45-再什么场景下会使用到嵌套路由"}},[t._v("#")]),t._v(" 45.再什么场景下会使用到嵌套路由")]),t._v(" "),e("ul",[e("li",[t._v("概念和使用场景")]),t._v(" "),e("li",[t._v("使用方式")]),t._v(" "),e("li",[t._v("实现原理")])]),t._v(" "),e("ul",[e("li",[t._v("平时开发中，应用的有些界面是由多层级组件组合而来的，这种情况下，url 各部分通常对应某个嵌套的组件，vue-router 中可以使用嵌套路由表示这种关系")]),t._v(" "),e("li",[t._v("表现形式是在两个路由问切换时，它们有公用的视图内容。此时通常提取一个父组件，内部放上"),e("code",[t._v("<router-view>")]),t._v("，从而形成物理上的嵌套，和逻辑上的嵌套对应起来。定义嵌套路由时使用 children’属性组织嵌套\n关系")]),t._v(" "),e("li",[t._v("原理上是在 router-view 组件内部判断其所处嵌套层级的深度，将这个深度作为匹配组件数组 matched 的索引，获取对应渲染组件并渲染之")])])])}),[],!1,null,null,null);e.default=v.exports}}]);