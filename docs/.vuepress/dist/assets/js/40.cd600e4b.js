(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{320:function(v,t,_){"use strict";_.r(t);var e=_(14),r=Object(e.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"_1-了解typescript-吗-讲一下泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-了解typescript-吗-讲一下泛型"}},[v._v("#")]),v._v(" 1.了解TypeScript 吗，讲一下泛型？")]),v._v(" "),t("p",[v._v("泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。在 TypeScript 中，泛型不仅可以帮助我们保持代码的灵活性，同时也可以提高代码的重用性。")]),v._v(" "),t("h3",{attrs:{id:"_2-interface关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-interface关键字"}},[v._v("#")]),v._v(" 2.interface关键字")]),v._v(" "),t("p",[v._v("可以定义形状")]),v._v(" "),t("p",[v._v("用法：定义接口，类继承接口，类实现接口，接口继承接口")]),v._v(" "),t("p",[v._v("异同点：")]),v._v(" "),t("ol",[t("li",[v._v("都可以用来描述对象或函数的类型。")]),v._v(" "),t("li",[v._v("接口可以定义可选属性和只读属性，而类型别名也可以定义可选属性和只读属性")]),v._v(" "),t("li",[v._v("接口可以被类实现，而类型别名不能。")]),v._v(" "),t("li",[v._v("接口可以被扩展，而类型别名不能。")]),v._v(" "),t("li",[v._v("接口可以定义函数类型和索引类型，而类型别名不能。")]),v._v(" "),t("li",[v._v("类型别名可以使用交叉类型和联合类型，而接口不能。")]),v._v(" "),t("li",[v._v("类型别名可以使用映射类型和条件类型，而接口不能。")]),v._v(" "),t("li",[v._v("类型别名可以使用明确赋值断言，而接口不能。")]),v._v(" "),t("li",[v._v("类型别名可以继承其他类型别名，而接口只能继承其他接口。")])]),v._v(" "),t("h3",{attrs:{id:"_3-void和never区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-void和never区别"}},[v._v("#")]),v._v(" 3.void和never区别")]),v._v(" "),t("p",[v._v("void表示函数没有返回值，而never表示函数永远不会返回")]),v._v(" "),t("p",[v._v("nerver一般用来返回错误 throw")])])}),[],!1,null,null,null);t.default=r.exports}}]);