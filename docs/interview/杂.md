

### 1.浏览器是如何渲染页面的？

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程.

-------

整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

-------

渲染的第一步是**解析 HTML**。

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

-------

渲染的下一步是**样式计算**。

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

--------

接下来是**布局**，布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。

-----------

下一步是**分层**

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

---------

再下一步是**绘制**

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

------

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

----

分块完成后，进入**光栅化**阶段。

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

---------

最后一个阶段就是**画**了

合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

### 2.什么是 reflow？

reflow 的本质就是重新计算 layout 树。

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。

浏览器在反复权衡下，最终决定获取属性立即 reflow。

### 3.什么是 repaint？

repaint 的本质就是重新根据分层信息计算了绘制指令。

当改动了可见样式后，就需要重新计算，会引发 repaint。

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。

### 4.为什么 transform 的效率高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段

由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。



### 5.HTTP缓存、协商缓存、强缓存

在浏览器加载资源的时候，首先会根据请求头的`expires`和`cache-control`判断是否命中强缓存策略，判断是否向远程服务器请求资源还是去本地获取缓存资源。

强缓存：

+ #### Expires

  ​	这个是1.0的缓存，在浏览器第一个请求资源时，服务器端的响应头会附上`Expires`这个响应字段，当浏览器在下一次请求这个资源时会根据上次的`expires`字段是否使用缓存资源（当请求时间小于服务端返回的到期时间，直接使用缓存数据）

+ #### Cache-control

  有个问题，就是服务端客户端时间对不上有差距，所有加了一个cache-control字段，这个字段优先级高于expires，是相对时间

  实例值：max-age\s-maxage\private\public\no-store\no-chache

协商缓存：

+ 协商缓存是服务器来确定这个资源是否可用，

  来张图：

  ![image-20230323193921777](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20230323193921777.png)

  ##### Etag/If-None-Match

  > Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
  >
  > 当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304

  ##### Last-Modifed/If-Modified-Since

  > Last-Modifed 浏览器向服务器发送资源最后的修改时间
  >
  > 
  >
  > 当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。

  

  

  ### 6.get和post请求区别
  
  1.url 体现区别，get请求能在URL上体现，post不可以。
  
  2.长度限制，get请求有长度限制，但并非HTTP协议的限制，是浏览器和web服务器的限制，因此不同浏览器和web服务器限制成都不一样。
  
  3.缓存区别, get请求一般用于查询，可以不用每次都与数据库交互，利用缓存机制，post请求一般用于增删改操作，必须与数据库就行操作，所以不可用于缓存。
  
  其他的请求：
  
  | 主要方法 | 功能说明                               |
  | -------- | -------------------------------------- |
  | GET      | 获取资源                               |
  | POST     | 传输实体主体，一般用于向服务器提交数据 |
  | PUT      | 传输文件                               |
  | HEAD     | 获取报文首部                           |
  | DELETE   | 删除文件                               |
  | OPTIONS  | 询问服务器支持的方法                   |
  | TRACE    | 追踪路径                               |
  | CONNECT  | 要求用隧道协议连接                     |
  
  
  
  ### 7.跨域和解决方法
  
  + Jsonp、
  + webpack 配置proxy,
  + nginx 反向代理，
  + Cors: 后端需要在目标服务器http相应头 配置允许跨域： Access-control-Allow-origin: '
  
  
  
  ### 8.模块化发展历程
  
  IIFE：立即执行函数，在一个独立的作用域中执行代码，不会污染全局作用域和避免变量冲突。
  
  AMD： 用requireJS 来编写模块化，特点：依赖必须提前声明。
  
  CMD： 使用seaJS 来编写模块化，特点：支持动态引入依赖文件。
  
  CommonJS: nodeJS 内置的模块化。
  
  ES6的modules： es6引入的模块化。
  
  
  
  ### 9.TCP三次握手
  
  第一次：client -> server 服务端知道客户端有发送能力
  
  第二次：server -> client 客户端知道服务端游发送能力
  
  第三次：client -> server 让服务端知道客户端接受能力没问题
  
  其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。
  
  
  
  ### 10.为什么 0.1 + 0.2 不等于 0.3

与许多其他编程语言不同，JavaScript 并未定义不同类型的数字数据类型，而是始终遵循国际 IEEE 754 标准，将数字存储为`双精度浮点数`。

这种格式以 64 位存储数字，其中`数字（分数）存储在位 0 到 51 中`，指数存储在位 52 到 62 中，符号存储在位 63 中。

用科学计数法表示二进制 0.1 并只保留前 52 位



### 11. HTTP 和 HTTPS 

#### 1.http 和 https 的基本概念

http:http是服务器与客户端请求的一个应答标准Tcp,用于从www服务器传输超文本到本地浏览器的超文本传输协议

Https：https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

#### 2.http 和 https 的区别及优缺点？

+ http:80端口，https:443
+ Https 需要ca证书，
+ http是明文传输，https是加密传输】
+ https需要握手比较费时
+ https缓存不如http高效

#### 3.https 协议的工作原理

+ 客户端使用 https url 访问服务器，则要求 web 服务器`建立 ssl 链接`。
+ web 服务器接收到客户端的请求之后，会`将网站的证书（证书中包含了公钥），传输给客户端`。
+ 客户端和 web 服务器端开始`协商 SSL 链接的安全等级`，也就是加密等级。
+ 客户端浏览器通过双方协商一致的安全等级，`建立会话密钥`，然后通过网站的公钥来加密会话密钥，并传送给网站。
+ web 服务器`通过自己的私钥解密出会话密钥`。
+ web 服务器`通过会话密钥加密与客户端之间的通信`。



### 12.TCP和UDP的区别TCP是面向`链接`的，而UDP是面向无连接的。

+ TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。

+ TCP是面向`链接`的，而UDP是面向无连接的。

+ TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。

+ UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。

  

### 13.Cookie、sessionStorage、localStorage 的区别

**相同点**：

- 存储在客户端

**不同点**：

- cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
- cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
- cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地

### 14.从输入URL到页面加载的全过程

1、首先在浏览器中输入URL

2、查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。

- 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
- 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- ISP缓存：若上述均失败，继续向ISP搜索。

3、DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`。

4、建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接

5、发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器

6、服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器

7、关闭TCP连接：通过四次挥手释放TCP连接

8、浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：

- 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
- 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
- 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
- 布局（Layout）：计算出每个节点在屏幕中的位置
- 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

9、JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）



### 15.浏览器重绘与重排的区别？

- `重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
- `重绘(Repaint)`: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变



### 16.如何触发重排和重绘？

任何改变用来构建渲染树的信息都会导致一次重排或重绘：

- 添加、删除、更新DOM节点

- 通过display: none隐藏一个DOM节点-触发重排和重绘

- 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化

- 移动或者给页面中的DOM节点添加动画

- 添加一个样式表，调整样式属性

- 用户行为，例如调整窗口大小，改变字号，或者滚动。

  

### 17.如何避免重绘或者重排？

1. `集中改变样式`，不要一条一条地修改 DOM 的样式。
2. 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
3. 为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会 reflow 的。
4. 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
5. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
6. 动画开始`GPU`加速，`translate`使用`3D`变化
7. 提升为合成层



### 18.说说你对 XSS 的了解

英文全称是 `Cross Site Script`，`XSS`攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于`DOM XSS`

反射线：通过用户的输入的信息反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功，通常反射型`XSS`的恶意代码存在`URL`里，通过`URL`传递参数的功能，如网站搜索、跳转等

存储型:存储型 `XSS` 会把用户输入的数据“存储”在服务器端,比如表单中写入js,当渲染页面执行的时候，遇到script标签就会执行输入的脚本

基于`DOM XSS`：实际上，这种类型的`XSS`并非按照“数据是否保存在服务器端”来划分，`DOM Based XSS`从效果上来说也是反射型`XSS`。单独划分出来，是因为`DOM Based XSS` 的形成原因比较特别，发现它的安全专家专门提出了这种类型的`XSS`。`DOM 型 XSS`跟前两种`XSS`的区别：`DOM 型 XSS`攻击中，取出和执行恶意代码由浏览器端完成，属于前端`JavaScript`自身的安全漏洞，而其他两种`XSS`都属于服务端的安全漏洞。

### 19.`XSS`攻击防御

+ HttpOnly`
+ 输入检查 ：在`XSS`的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如`＜、＞、’、”`，做转义
+ 输出检查：和输入一样，转义

### 20.get请求传参长度的误区

+ HTTP 协议 未规定 GET 和POST的长度限制

+ GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度

+ 不同的浏览器和WEB服务器，限制的最大长度不一样

+ 要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte

### 21.补充get和post请求在缓存方面的区别

- get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。
- post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。

### 22.状态码

+ 400状态码：请求无效

+ 401状态码：当前请求需要用户验证，token过期

+ 403状态码：服务器已经得到请求，但是拒绝执行 getpost方法不对

  

  ### 23.Cookie如何防范XSS攻击

XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：

- httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。
- secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。
