<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 问题合集 | 翻手机壳</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.671fbdd0.css" as="style"><link rel="preload" href="/blog/assets/js/app.a90895f3.js" as="script"><link rel="preload" href="/blog/assets/js/2.245720e2.js" as="script"><link rel="preload" href="/blog/assets/js/72.286f7f3a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.06910aeb.js"><link rel="prefetch" href="/blog/assets/js/100.1c0909c5.js"><link rel="prefetch" href="/blog/assets/js/101.2d4c06df.js"><link rel="prefetch" href="/blog/assets/js/102.140faa04.js"><link rel="prefetch" href="/blog/assets/js/103.07f7e523.js"><link rel="prefetch" href="/blog/assets/js/104.bfeccefb.js"><link rel="prefetch" href="/blog/assets/js/105.7cfafd2c.js"><link rel="prefetch" href="/blog/assets/js/106.f56f57b7.js"><link rel="prefetch" href="/blog/assets/js/107.67312232.js"><link rel="prefetch" href="/blog/assets/js/108.d15658be.js"><link rel="prefetch" href="/blog/assets/js/109.2527fd2b.js"><link rel="prefetch" href="/blog/assets/js/11.1499847a.js"><link rel="prefetch" href="/blog/assets/js/110.ae87054b.js"><link rel="prefetch" href="/blog/assets/js/111.1e8783ee.js"><link rel="prefetch" href="/blog/assets/js/112.9d7c5c86.js"><link rel="prefetch" href="/blog/assets/js/113.ae7684ac.js"><link rel="prefetch" href="/blog/assets/js/114.6375999f.js"><link rel="prefetch" href="/blog/assets/js/115.f1602dcc.js"><link rel="prefetch" href="/blog/assets/js/116.07e6f5a0.js"><link rel="prefetch" href="/blog/assets/js/117.665b8efa.js"><link rel="prefetch" href="/blog/assets/js/118.62db89e7.js"><link rel="prefetch" href="/blog/assets/js/119.8d456501.js"><link rel="prefetch" href="/blog/assets/js/12.11695b79.js"><link rel="prefetch" href="/blog/assets/js/120.c0f57631.js"><link rel="prefetch" href="/blog/assets/js/121.1334108a.js"><link rel="prefetch" href="/blog/assets/js/122.8ea2057c.js"><link rel="prefetch" href="/blog/assets/js/123.0f13a0dc.js"><link rel="prefetch" href="/blog/assets/js/124.7145fb8d.js"><link rel="prefetch" href="/blog/assets/js/125.1c65514f.js"><link rel="prefetch" href="/blog/assets/js/126.fdf41409.js"><link rel="prefetch" href="/blog/assets/js/127.084feb31.js"><link rel="prefetch" href="/blog/assets/js/128.cdb870b3.js"><link rel="prefetch" href="/blog/assets/js/129.9947060b.js"><link rel="prefetch" href="/blog/assets/js/13.b99ebeae.js"><link rel="prefetch" href="/blog/assets/js/130.507380f8.js"><link rel="prefetch" href="/blog/assets/js/131.8483f470.js"><link rel="prefetch" href="/blog/assets/js/132.48eda00e.js"><link rel="prefetch" href="/blog/assets/js/133.890cab04.js"><link rel="prefetch" href="/blog/assets/js/134.182fc87a.js"><link rel="prefetch" href="/blog/assets/js/135.3f6f9992.js"><link rel="prefetch" href="/blog/assets/js/136.a8beae75.js"><link rel="prefetch" href="/blog/assets/js/137.6293ff7e.js"><link rel="prefetch" href="/blog/assets/js/138.a1158cd4.js"><link rel="prefetch" href="/blog/assets/js/139.3b6e4b6a.js"><link rel="prefetch" href="/blog/assets/js/14.752c486e.js"><link rel="prefetch" href="/blog/assets/js/140.8bbc0098.js"><link rel="prefetch" href="/blog/assets/js/141.be631151.js"><link rel="prefetch" href="/blog/assets/js/142.1ec8d66c.js"><link rel="prefetch" href="/blog/assets/js/143.87d66b83.js"><link rel="prefetch" href="/blog/assets/js/144.3bf1b5d8.js"><link rel="prefetch" href="/blog/assets/js/15.10fe3ddd.js"><link rel="prefetch" href="/blog/assets/js/16.0bd0cec6.js"><link rel="prefetch" href="/blog/assets/js/17.bbaca713.js"><link rel="prefetch" href="/blog/assets/js/18.0c3ebf05.js"><link rel="prefetch" href="/blog/assets/js/19.165ad86d.js"><link rel="prefetch" href="/blog/assets/js/20.bc35dfdb.js"><link rel="prefetch" href="/blog/assets/js/21.924f6507.js"><link rel="prefetch" href="/blog/assets/js/22.244e0067.js"><link rel="prefetch" href="/blog/assets/js/23.00df31d9.js"><link rel="prefetch" href="/blog/assets/js/24.4b9b7f02.js"><link rel="prefetch" href="/blog/assets/js/25.a741bb3d.js"><link rel="prefetch" href="/blog/assets/js/26.8c45f22c.js"><link rel="prefetch" href="/blog/assets/js/27.f60f8cf6.js"><link rel="prefetch" href="/blog/assets/js/28.a9609e60.js"><link rel="prefetch" href="/blog/assets/js/29.34150e06.js"><link rel="prefetch" href="/blog/assets/js/3.1b134545.js"><link rel="prefetch" href="/blog/assets/js/30.9e6734ff.js"><link rel="prefetch" href="/blog/assets/js/31.df4e080f.js"><link rel="prefetch" href="/blog/assets/js/32.b48acea2.js"><link rel="prefetch" href="/blog/assets/js/33.7e32252b.js"><link rel="prefetch" href="/blog/assets/js/34.aef675db.js"><link rel="prefetch" href="/blog/assets/js/35.6688711a.js"><link rel="prefetch" href="/blog/assets/js/36.dedc6c7e.js"><link rel="prefetch" href="/blog/assets/js/37.622234dc.js"><link rel="prefetch" href="/blog/assets/js/38.fa0412d9.js"><link rel="prefetch" href="/blog/assets/js/39.bc1d7791.js"><link rel="prefetch" href="/blog/assets/js/4.9225c9a0.js"><link rel="prefetch" href="/blog/assets/js/40.d9f961db.js"><link rel="prefetch" href="/blog/assets/js/41.66f84121.js"><link rel="prefetch" href="/blog/assets/js/42.e174f1ad.js"><link rel="prefetch" href="/blog/assets/js/43.f4fcc418.js"><link rel="prefetch" href="/blog/assets/js/44.ff572f24.js"><link rel="prefetch" href="/blog/assets/js/45.ad780474.js"><link rel="prefetch" href="/blog/assets/js/46.eddc1479.js"><link rel="prefetch" href="/blog/assets/js/47.aaf42df3.js"><link rel="prefetch" href="/blog/assets/js/48.b238770e.js"><link rel="prefetch" href="/blog/assets/js/49.54268f03.js"><link rel="prefetch" href="/blog/assets/js/5.7dce9bf1.js"><link rel="prefetch" href="/blog/assets/js/50.771d2f46.js"><link rel="prefetch" href="/blog/assets/js/51.2c943ade.js"><link rel="prefetch" href="/blog/assets/js/52.33067f68.js"><link rel="prefetch" href="/blog/assets/js/53.62ed136b.js"><link rel="prefetch" href="/blog/assets/js/54.c2c15564.js"><link rel="prefetch" href="/blog/assets/js/55.b08d3ba6.js"><link rel="prefetch" href="/blog/assets/js/56.de82384d.js"><link rel="prefetch" href="/blog/assets/js/57.4e3bcbe0.js"><link rel="prefetch" href="/blog/assets/js/58.3f5c9512.js"><link rel="prefetch" href="/blog/assets/js/59.0cd95b2b.js"><link rel="prefetch" href="/blog/assets/js/6.0585bb02.js"><link rel="prefetch" href="/blog/assets/js/60.38cdf119.js"><link rel="prefetch" href="/blog/assets/js/61.0ed89757.js"><link rel="prefetch" href="/blog/assets/js/62.500478fa.js"><link rel="prefetch" href="/blog/assets/js/63.0b1e693c.js"><link rel="prefetch" href="/blog/assets/js/64.f8f922ae.js"><link rel="prefetch" href="/blog/assets/js/65.e40ea993.js"><link rel="prefetch" href="/blog/assets/js/66.b98aa65e.js"><link rel="prefetch" href="/blog/assets/js/67.0446e928.js"><link rel="prefetch" href="/blog/assets/js/68.dd5dc370.js"><link rel="prefetch" href="/blog/assets/js/69.6b02f4d0.js"><link rel="prefetch" href="/blog/assets/js/7.c67efc8b.js"><link rel="prefetch" href="/blog/assets/js/70.e08cc0ad.js"><link rel="prefetch" href="/blog/assets/js/71.5586ae4f.js"><link rel="prefetch" href="/blog/assets/js/73.b1134ada.js"><link rel="prefetch" href="/blog/assets/js/74.295fffd2.js"><link rel="prefetch" href="/blog/assets/js/75.37b3225e.js"><link rel="prefetch" href="/blog/assets/js/76.e1b8bc0c.js"><link rel="prefetch" href="/blog/assets/js/77.ea94eb75.js"><link rel="prefetch" href="/blog/assets/js/78.f0408fb3.js"><link rel="prefetch" href="/blog/assets/js/79.09bf9c1d.js"><link rel="prefetch" href="/blog/assets/js/8.762692b1.js"><link rel="prefetch" href="/blog/assets/js/80.d62b2a0e.js"><link rel="prefetch" href="/blog/assets/js/81.b2744e5e.js"><link rel="prefetch" href="/blog/assets/js/82.10bc5396.js"><link rel="prefetch" href="/blog/assets/js/83.7b3d0d97.js"><link rel="prefetch" href="/blog/assets/js/84.40fc6557.js"><link rel="prefetch" href="/blog/assets/js/85.1f696526.js"><link rel="prefetch" href="/blog/assets/js/86.f8c2a083.js"><link rel="prefetch" href="/blog/assets/js/87.662b0c22.js"><link rel="prefetch" href="/blog/assets/js/88.bcb8db6f.js"><link rel="prefetch" href="/blog/assets/js/89.0c6362cf.js"><link rel="prefetch" href="/blog/assets/js/9.3bc9f0ae.js"><link rel="prefetch" href="/blog/assets/js/90.08cc0e3f.js"><link rel="prefetch" href="/blog/assets/js/91.6881ba9f.js"><link rel="prefetch" href="/blog/assets/js/92.d75eeecd.js"><link rel="prefetch" href="/blog/assets/js/93.6a3259da.js"><link rel="prefetch" href="/blog/assets/js/94.bcd8f45a.js"><link rel="prefetch" href="/blog/assets/js/95.79652da6.js"><link rel="prefetch" href="/blog/assets/js/96.c7633fdc.js"><link rel="prefetch" href="/blog/assets/js/97.a7ebc07b.js"><link rel="prefetch" href="/blog/assets/js/98.0c3c04e4.js"><link rel="prefetch" href="/blog/assets/js/99.916de0f5.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.671fbdd0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">翻手机壳</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/read/无痛自律.html" class="nav-link">
  读书
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/design/单例模式.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="/blog/interview/ms/第七章 工作经验.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/read/无痛自律.html" class="nav-link">
  读书
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>随机题库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2周面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ts相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js相关</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/interview/js/js.html" aria-current="page" class="active sidebar-link">js 问题合集</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-精度问题" class="sidebar-link">js 精度问题</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#作用域和闭包" class="sidebar-link">作用域和闭包</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-数据类型" class="sidebar-link">JS 数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-类型判断" class="sidebar-link">JS 类型判断</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-的深拷贝和浅拷贝的方法" class="sidebar-link">JS 的深拷贝和浅拷贝的方法</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#this-的指向问题" class="sidebar-link">this 的指向问题</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-原型和原型链" class="sidebar-link">JS 原型和原型链</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#_9-null-和-undefined-区别" class="sidebar-link">9.null 和 undefined 区别</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#函数柯里化、偏函数、纯函数、高阶函数" class="sidebar-link">函数柯里化、偏函数、纯函数、高阶函数</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#节流防抖" class="sidebar-link">节流防抖</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#箭头函数和普通函数区别" class="sidebar-link">箭头函数和普通函数区别</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#new-运算符的实现机制" class="sidebar-link">new 运算符的实现机制</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#es6-中新增的-set、map-两种数据结构怎么理解" class="sidebar-link">ES6 中新增的 Set、Map 两种数据结构怎么理解?</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#说说你对函数式编程的理解-以及优缺点" class="sidebar-link">说说你对函数式编程的理解，以及优缺点？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#null-和-undefined-有什么区别" class="sidebar-link">null 和 undefined 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#类的创建和继承" class="sidebar-link">类的创建和继承</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#事件流、如何让事件先冒泡后捕获、事件委托" class="sidebar-link">事件流、如何让事件先冒泡后捕获、事件委托</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#mouseover-和-mouseenter-的区别" class="sidebar-link">mouseover 和 mouseenter 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-的各种位置-比如-clientheight-offsetheight-scrollheight-以及-scrolltop-offsettop-clienttop-的区别" class="sidebar-link">js 的各种位置，比如 clientHeight,offsetHeight,scrollHeight,以及 scrollTop, offsetTop,clientTop 的区别？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-原型-原型链-继承" class="sidebar-link">js 原型，原型链，继承</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#严格模式有什么特点" class="sidebar-link">严格模式有什么特点</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#js-的垃圾回收机制-引用计数有什么本质问题" class="sidebar-link">js 的垃圾回收机制？引用计数有什么本质问题？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#html5-drag-api" class="sidebar-link">HTML5 drag api</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#cookie、sessionstorage、localstorage-的区别" class="sidebar-link">Cookie、sessionStorage、localStorage 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#web-worker" class="sidebar-link">web worker</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#iframe-是什么-有什么缺点" class="sidebar-link">iframe 是什么？有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#doctype-作用-严格模式与混杂模式如何区分-它们有何意义" class="sidebar-link">Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#click-在-ios-上有-300ms-延迟-原因及如何解决" class="sidebar-link">click 在 ios 上有 300ms 延迟，原因及如何解决？</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#解释一下变量的提升" class="sidebar-link">解释一下变量的提升</a></li><li class="sidebar-sub-header"><a href="/blog/interview/js/js.html#如何区分声明函数和表达式函数" class="sidebar-link">如何区分声明函数和表达式函数</a></li></ul></li><li><a href="/blog/interview/js/事件循环.html" class="sidebar-link">事件循环</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-问题合集"><a href="#js-问题合集" class="header-anchor">#</a> js 问题合集</h1> <h2 id="js-精度问题"><a href="#js-精度问题" class="header-anchor">#</a> js 精度问题</h2> <p>主要是因为 js 采用了双精度浮点数进行计算标准，小数位只能存 64 位，这意味着某些十进制数在转换为二进制时不能精确地表示，使用 big.js 或者 decimeal.js 来解决或者使用 toFixed 来表示</p> <h2 id="作用域和闭包"><a href="#作用域和闭包" class="header-anchor">#</a> 作用域和闭包</h2> <p>作用域</p> <ul><li>全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</li> <li>函数作用域：函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</li> <li>块级作用域：ES6 引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在大括号中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</li></ul> <blockquote><p>什么是作用链</p></blockquote> <p>当访问一个变量时，解释器会首先在当前作用域中查找标识符，如果没找到，就去父作用域找，直到找到该变量的标识符或没找到为止。这条寻找的链路就叫作用域链</p> <blockquote><p>什么是闭包</p></blockquote> <p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数当中声明的变量；当调用通过外部函数返回的内部函数时，即使此时外部函数已经执行结束，但是内部函数所引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包</p> <blockquote><p>闭包怎么产生的</p></blockquote> <p>当函数存在对其所在词法作用域的引用，而该函数被拿到当前词法作用域外执行，此时就产生了闭包。</p> <blockquote><p>在工作中，哪些地方使用到了闭包</p></blockquote> <ul><li>return 一个函数</li> <li>函数作为参数</li> <li>IIFE 自执行函数</li></ul> <blockquote><p>为什么要使用闭包？/ 闭包的好处？</p></blockquote> <ul><li>保护函数的私有变量不受外部干扰。形成不销毁的栈内存</li> <li>把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li></ul> <blockquote><p>闭包变量怎么回收呢？</p></blockquote> <ul><li><p>如果是全局变量被作为闭包变量的话，则该闭包变量会一直保存到页面关闭。（因为全局上下文会一直存在，不会被回收，除非页面关闭）</p></li> <li><p>如果是局部变量被作为闭包变量的话，下面分两种情况讨论</p> <ul><li><p>立马执行时会自动回收</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token operator">++</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//11</span>
</code></pre></div></li> <li><p>不回立马被执行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token operator">++</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1</span>
<span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
</code></pre></div></li></ul></li></ul> <h2 id="js-数据类型"><a href="#js-数据类型" class="header-anchor">#</a> JS 数据类型</h2> <ul><li><p>原始值：</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>undefined</li> <li>null</li> <li>symbol</li> <li>Bigint</li></ul></li> <li><p>引用类型</p> <ul><li>OBject</li> <li>Array</li> <li>RegExp</li> <li>Date</li> <li>Math</li> <li>Function</li></ul></li></ul> <p>主要说下 bitint,bigint 是 Es2020 出现的，主要弥补 number 的精度丢失的异常，再最后使用 n，来标识，也可用 BigInt 方法来写的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token number">12312312312312n</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">12312312312312</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="js-类型判断"><a href="#js-类型判断" class="header-anchor">#</a> JS 类型判断</h2> <ul><li>typeof</li> <li>instanceof 所有引用类型，</li> <li>Object.prototype.toString.call() 判断浏览器内置对象</li> <li>Constructor 对 number 和 null 无效</li></ul> <h2 id="js-的深拷贝和浅拷贝的方法"><a href="#js-的深拷贝和浅拷贝的方法" class="header-anchor">#</a> JS 的深拷贝和浅拷贝的方法</h2> <ul><li>Object.assign(目标对象,源对象)</li> <li>[...arr]</li> <li>Array.protype.concat()</li> <li>JSON.parse(JSON.stringify())</li> <li>concat</li> <li>slice</li></ul> <h2 id="this-的指向问题"><a href="#this-的指向问题" class="header-anchor">#</a> this 的指向问题</h2> <ul><li><p>默认调用，指向 window</p></li> <li><p>对象调用，指向该对象</p></li> <li><p>做构造函数使用，指向实例对象</p></li> <li><p>箭头函数，执行函数所在的作用域</p></li> <li><p>Call,apply,bind 指向传入的第一个参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">pa<span class="token punctuation">,</span> pb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//和call差不多，但是不会执行</span>
</code></pre></div></li></ul> <h2 id="js-原型和原型链"><a href="#js-原型和原型链" class="header-anchor">#</a> JS 原型和原型链</h2> <blockquote><p>什么事原型对象</p></blockquote> <p>每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型对象，每一个对象都会从原型&quot;继承&quot;属性。</p> <blockquote><p>函数的原型和对象的原型：</p></blockquote> <ul><li><p>每个函数都有一个 prototype 属性，该属性指向函数的原型</p></li> <li><p>每个对象都有一个<strong>proto</strong>属性，该属性指向对象的原型</p></li></ul> <blockquote><p>什么是原型链</p></blockquote> <p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这条查找的路径就叫原型链</p> <h2 id="_9-null-和-undefined-区别"><a href="#_9-null-和-undefined-区别" class="header-anchor">#</a> 9.null 和 undefined 区别</h2> <blockquote><p>简单点理解： undefined 表示值不存在，null 表示值存在但是为空，没有意义；</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>null == undefined // true
null === undefined // fasle
// typeof null 为 Object, typeof undefined 为 undefined
</code></pre></div><h2 id="函数柯里化、偏函数、纯函数、高阶函数"><a href="#函数柯里化、偏函数、纯函数、高阶函数" class="header-anchor">#</a> 函数柯里化、偏函数、纯函数、高阶函数</h2> <ul><li>函数柯里化：将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。</li> <li>偏函数：固定多个参数，并将剩余的参数作为单一的参数的函数，并返回接受余下的参数</li> <li>纯函数：没有任何副作用的函数，输入和输出使用是一个值</li> <li>高阶函数：将参数当做函数传入</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">const</span> add <span class="token operator">=</span> function <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> function <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> y
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> add1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">3</span>
</code></pre></div><h2 id="节流防抖"><a href="#节流防抖" class="header-anchor">#</a> 节流防抖</h2> <p>防抖： 每次有请求是继续延长时间，如：输入框输入请求，延迟 1 秒钟，一秒内还有请求继续延迟
节流：固定个时间请求。滚动滚轮，拖拽等高频事件</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 防抖</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 节流</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canRun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    canRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="箭头函数和普通函数区别"><a href="#箭头函数和普通函数区别" class="header-anchor">#</a> 箭头函数和普通函数区别</h2> <ul><li>不能 new</li> <li>this 指向</li> <li>不能使用 arguments</li> <li>没有原型属性</li> <li>不能当作 generator 函数，不能使用 yeid 关键字</li> <li>this 指向不同</li> <li>箭头函数没有原型 prototype</li> <li>返回对象字面量时需要使用括号</li> <li>箭头函数的 this 永远不会变，call、apply、bind 也无法改变</li></ul> <h2 id="new-运算符的实现机制"><a href="#new-运算符的实现机制" class="header-anchor">#</a> new 运算符的实现机制</h2> <ol><li>首先创建了一个新的<code>空对象</code></li> <li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li> <li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li> <li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol> <h2 id="es6-中新增的-set、map-两种数据结构怎么理解"><a href="#es6-中新增的-set、map-两种数据结构怎么理解" class="header-anchor">#</a> ES6 中新增的 Set、Map 两种数据结构怎么理解?</h2> <p><code>Set</code>没有重复的值，我们一般称为集合,强引用，不回被垃圾回收</p> <p>​ 方法：has、add、delete、clear
​ 遍历方法：keys()、values()、entries()、forEach()
​ 常用的方法：Array.from(new Set([1,1,2,3,5]))</p> <p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型，强引用，不回被垃圾回收</p> <p>​ 和 object 不同，key 可以为任何值，
​ 方法：set、get、has、size、delete、clear
​ 遍历方法：keys()、values()、entries()、forEach()
​ 下面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示 键值对的数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Author&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p> <ul><li>没有遍历操作的<code>API</code></li> <li>没有<code>size</code>属性</li></ul> <p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值
<code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失
<code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合
在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p> <ul><li>没有遍历操作的<code>API</code></li> <li>没有<code>clear</code>清空方法</li></ul> <p><code>WeakMap</code>只接受对象或这 symbol 作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p> <p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p> <h2 id="说说你对函数式编程的理解-以及优缺点"><a href="#说说你对函数式编程的理解-以及优缺点" class="header-anchor">#</a> 说说你对函数式编程的理解，以及优缺点？</h2> <p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</p> <ul><li>高阶函数：函数作为参数</li> <li>纯函数：没有副作用</li> <li>柯里化：多元函数转为一元函数的过程，
<ul><li>关于柯里化函数的意义如下：
<ul><li>让纯函数更纯，每次接受一个参数，松散解耦</li> <li>惰性执行</li></ul></li></ul></li></ul> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li> <li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</li> <li>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</li> <li>隐性好处。减少代码量，提高维护性</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点：</h4> <ul><li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</li> <li>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</li> <li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li></ul> <h2 id="null-和-undefined-有什么区别"><a href="#null-和-undefined-有什么区别" class="header-anchor">#</a> null 和 undefined 有什么区别？</h2> <p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p> <p>undefined 代表的含义是未定义，null 代表的含义是空对象</p> <p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p> <h2 id="类的创建和继承"><a href="#类的创建和继承" class="header-anchor">#</a> 类的创建和继承</h2> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <ul><li>特点：基于原型链，既是父类的实例，也是子类的实例</li> <li>缺点：无法实现多继承</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="构造继承"><a href="#构造继承" class="header-anchor">#</a> 构造继承</h3> <ul><li>特点：可以实现多继承</li> <li>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h3> <p>相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p> <ul><li>特点：可以继承实例属性/方法，也可以继承原型属性/方法</li> <li>缺点：调用了两次父类构造函数，生成了两份实例</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="寄生组合继承"><a href="#寄生组合继承" class="header-anchor">#</a> 寄生组合继承</h3> <p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个没有实例方法的类</span>
  <span class="token keyword">var</span> <span class="token function-variable function">Super</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">Super</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">//将实例作为子类的原型</span>
  <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Test Code</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><h2 id="事件流、如何让事件先冒泡后捕获、事件委托"><a href="#事件流、如何让事件先冒泡后捕获、事件委托" class="header-anchor">#</a> 事件流、如何让事件先冒泡后捕获、事件委托</h2> <p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。</p> <ul><li>事件捕获阶段</li> <li>处于目标阶段</li> <li>事件冒泡阶段</li></ul> <p><strong>addEventListener</strong>，最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p> <p>如何让事件先冒泡后捕获：</p> <p>在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p> <ul><li>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</li></ul> <ul><li>最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</li> <li>较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</li></ul> <h2 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="header-anchor">#</a> mouseover 和 mouseenter 的区别</h2> <ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout</li> <li>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</li></ul> <h2 id="js-的各种位置-比如-clientheight-offsetheight-scrollheight-以及-scrolltop-offsettop-clienttop-的区别"><a href="#js-的各种位置-比如-clientheight-offsetheight-scrollheight-以及-scrolltop-offsettop-clienttop-的区别" class="header-anchor">#</a> js 的各种位置，比如 clientHeight,offsetHeight,scrollHeight,以及 scrollTop, offsetTop,clientTop 的区别？</h2> <ul><li>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</li> <li>offsetHeight：表示可视区域的高度，包含了 border 和滚动条</li> <li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</li> <li>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</li> <li>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</li></ul> <h2 id="js-原型-原型链-继承"><a href="#js-原型-原型链-继承" class="header-anchor">#</a> js 原型，原型链，继承</h2> <p>原型链，是实现 js 的基础方式，所有的构造函数都有一个原型对象，原型的 construct 属性指向了构造函数。这是一个循环的闭合链圈，如果我们将 construct 指向另一个构造函数，而另一个构造函数的 construct 再指向另外一个构造函数，这样就在实例和原型之间构造了一条原型链。</p> <p>原型的基本结构</p> <div class="language- extra-class"><pre class="language-text"><code>function Lop(){
	this.name = '1'
}
Lop.prototype.age = '2'
new Lop()

Lop
	name:2
	prototype:{
		constructor: Lop
	}

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function Lop(){
this.name = 'Lop'
}
Lop.prototype.age = '23'
function Lob(){

}
Lob.prototype = new Lop();
let lob = new Lob()
console.log(lob)
console.log(lob.name)
console.log(lob.age)

</code></pre></div><p>原型链的问题</p> <ol><li>引用类型的对象有个问题，他会修改原型上的数据。列入</li></ol> <div class="language- extra-class"><pre class="language-text"><code>    		function Lop(){
            this.name = 'Lop'
        }
        Lop.prototype.age = ['23']

        function Lob(){
            this.natallme = '187cm'
        }
        Lob.prototype = new Lop();
        Lob.prototype.constructor = Lob
        let lob = new Lob()
        let lob2 = new Lob()
        lob.age.push('2')
        console.log(lob2.age) //['23', '2']
</code></pre></div><p>这样明显不对的。</p> <ol start="2"><li>盗用构造函数（经典进程或者叫对象伪装）</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function Lop(){
 	this.name = 'Lop'
 }
 Lop.prototype.age = ['23']
function Lob(){
  Lop.call(this);
  this.natallme = '187cm'
}
let lob = new Lob()
let lob2 = new Lob()

</code></pre></div><p>缺点：不能访问父级的 prototype</p> <ol start="3"><li>组合继承（盗用构造函数+原型继承）</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function Lop(){
            this.name = ['Lop']
        }
        Lop.prototype.age = ['23']

        function Lob(){
            Lop.call(this); //继承之后能够让数组也能重新计算。
            this.natallme = '187cm'
        }
        Lob.prototype = new Lop() //用来能访问父级的原型
        let lob = new Lob()
        let lob2 = new Lob()
        lob.name.push('2')
        console.log(lob)
        console.log(lob.name)(2) ['Lop', '2']
        console.log(lob2.name)['Lop']
        console.log(lob2.age)['23']


</code></pre></div><h2 id="严格模式有什么特点"><a href="#严格模式有什么特点" class="header-anchor">#</a> 严格模式有什么特点</h2> <ol><li>全局变量必须先声明才能使用</li> <li>禁止删除变量或函数</li> <li>禁止 &quot;this&quot; 关键字指向全局对象</li> <li>禁止使用 with 语句</li> <li>禁止使用 eval() 函数</li> <li>禁止使用 arguments.callee 和 arguments.caller 属性</li> <li>禁止使用 arguments 对象的 length 属性</li> <li>函数参数不能重名</li> <li>禁止使用八进制数</li></ol> <h2 id="js-的垃圾回收机制-引用计数有什么本质问题"><a href="#js-的垃圾回收机制-引用计数有什么本质问题" class="header-anchor">#</a> js 的垃圾回收机制？引用计数有什么本质问题？</h2> <p>垃圾产生</p> <ul><li>对象不再被引用 例如，当一个函数执行完毕后，其中创建的局部变量将成为垃圾，因为它们无法再被访问到</li> <li>对象之间形成循环引用</li> <li>动态创建的对象没有被及时销毁 循环或递归等情况下，如果没有正确地释放内存，垃圾会不断积累。</li> <li>内存泄漏</li></ul> <p>垃圾回收算法：</p> <ul><li>引用计数:通过跟踪每个对象被引用的次数来确定对象是否为垃圾。
<ul><li>当一个对象被创建时，其引用计数器初始化为 1。</li> <li>当该对象被其他对象引用时，引用计数器加 1。</li> <li>当该对象不再被其他对象引用时，引用计数器减 1。</li> <li>当引用计数器减至 0 时，意味着该对象不再被引用，可以被垃圾收集器回收。
<blockquote><p>存在的问题:当两个或多个对象相互引用时，它们的引用计数都不为零,即使它们已经不再被其他对象引用，也无法被回收。这导致内存泄漏，因为这些对象仍然占据内存空间，却无法被释放。</p></blockquote></li></ul></li> <li>标记-清除:算法通过标记不再使用的对象，然后清除这些对象的内存空间，以便后续的内存分配使用。
<ul><li>标记阶段：在标记阶段，垃圾回收器会对内存中的所有对象进行遍历，从根对象开始（通常是全局对象）<strong><em>递归地遍历对象的引用关系</em></strong>。对于每个被访问到的对象，垃圾回收器会给它打上标记，表示该对象是可达的，即不是垃圾。这个过程确保了所有可达对象都会被标记。</li> <li>清除阶段：在清除阶段，垃圾回收器会遍历整个内存，对于没有标记的对象，即被判定为垃圾的对象，会被立即回收，释放内存空间。这样，只有被标记的对象会被保留在内存中，而垃圾对象会被清除。
<blockquote><p>垃圾回收过程中的停顿：标记-清除算法会暂停程序的执行，进行垃圾回收操作。当堆中对象较多时，可能会导致明显的停顿，影响用户体验。
内存碎片化：标记-清除算法会在回收过程中产生大量的不连续的、碎片化的内存空间。这可能导致后续的内存分配难以找到足够大的连续内存块，从而使得内存的利用率降低。</p></blockquote></li></ul></li></ul> <h2 id="html5-drag-api"><a href="#html5-drag-api" class="header-anchor">#</a> HTML5 drag api</h2> <ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。</li> <li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li> <li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li> <li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li> <li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li> <li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li> <li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</li></ul> <h2 id="cookie、sessionstorage、localstorage-的区别"><a href="#cookie、sessionstorage、localstorage-的区别" class="header-anchor">#</a> Cookie、sessionStorage、localStorage 的区别</h2> <p>共同点：都是保存在浏览器端，并且是同源的</p> <ul><li>Cookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）</li> <li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</li> <li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</li></ul> <p>补充说明一下 cookie 的作用：</p> <ul><li>保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li> <li>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便</li> <li>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用 cookie 来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li></ul> <h2 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> web worker</h2> <p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p> <p>如何创建 web worker：</p> <ul><li>检测浏览器对于 web worker 的支持性</li> <li>创建 web worker 文件（js，回传函数等）</li> <li>创建 web worker 对象</li></ul> <h2 id="iframe-是什么-有什么缺点"><a href="#iframe-是什么-有什么缺点" class="header-anchor">#</a> iframe 是什么？有什么缺点？</h2> <p>定义：iframe 元素会创建包含另一个文档的内联框架 提示：可以将提示文字放在之间，来提示某些不支持 iframe 的浏览器</p> <p>缺点：</p> <ul><li>会阻塞主页面的 onload 事件</li> <li>搜索引擎无法解读这种页面，不利于 SEO</li> <li>iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</li></ul> <h2 id="doctype-作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#doctype-作用-严格模式与混杂模式如何区分-它们有何意义" class="header-anchor">#</a> Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h2> <p>Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p> <ul><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li> <li>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</li></ul> <h2 id="click-在-ios-上有-300ms-延迟-原因及如何解决"><a href="#click-在-ios-上有-300ms-延迟-原因及如何解决" class="header-anchor">#</a> click 在 ios 上有 300ms 延迟，原因及如何解决？</h2> <h3 id="_1-粗暴型-禁用缩放"><a href="#_1-粗暴型-禁用缩放" class="header-anchor">#</a> (1)粗暴型，禁用缩放</h3> <p>routeros</p> <p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt;</code></p> <h3 id="_2-利用-fastclick-其原理是"><a href="#_2-利用-fastclick-其原理是" class="header-anchor">#</a> (2)利用 FastClick，其原理是：</h3> <p>检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉</p> <h2 id="解释一下变量的提升"><a href="#解释一下变量的提升" class="header-anchor">#</a> 解释一下变量的提升</h2> <hr> <p>变量的提升是 JavaScript 的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。</p> <p>javascript</p> <p><code>var x = 1 console.log(x + '——' + y) // 1——undefined var y = 2</code></p> <h2 id="如何区分声明函数和表达式函数"><a href="#如何区分声明函数和表达式函数" class="header-anchor">#</a> 如何区分声明函数和表达式函数</h2> <hr> <p>csharp</p> <p><code>// 声明函数 function hello() { return &quot;HELLO&quot; } // 表达式函数 var h1 = function hello() { return &quot;HELLO&quot; }</code></p> <p>两个函数将在不同的时期定义。在解析期间定义声明，在运行时定义表达式;因此，如果我们控制台打印 <code>h1</code>，它将显示<code>HELLO</code>。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/interview/ts/基础问题.html" class="prev">
        Ts 面试
      </a></span> <span class="next"><a href="/blog/interview/js/事件循环.html">
        事件循环
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a90895f3.js" defer></script><script src="/blog/assets/js/2.245720e2.js" defer></script><script src="/blog/assets/js/72.286f7f3a.js" defer></script>
  </body>
</html>
