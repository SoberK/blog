{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{307:function(a,t,e){\"use strict\";e.r(t);var s=e(14),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[t(\"h4\",{attrs:{id:\"_1、js内存泄漏如何检测-场景有哪些\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、js内存泄漏如何检测-场景有哪些\"}},[a._v(\"#\")]),a._v(\" 1、JS内存泄漏如何检测？场景有哪些\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"什么是垃圾回收机制\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"在函数被执行完了，再也用不到的数据或者变量，算法会清除\")])])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"垃圾回收机制的算法\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"引用计数方式（ 之前），但是循环引用会出现问题\")])]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"let a = {x:100}\\nlet a1 = a;\\na = 10;\\na1 = null;\\n//此时{x:100}没有变量指向了，那么标记指向的数为0，那么就被清楚\\n但是有个问题\\n\\nconst obj1 = {};\\nconst obj2 = {}\\nobj1.a = obj2;\\nobj2.a = obj1;\\n进行了循环引用，这样计数方式就没有用了\\n\")])])]),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"标记清除（现代）\")]),a._v(\" \"),t(\"p\",[a._v(\"就是在window根下面循环遍历，只要找得到就保留，找不到就清楚\")])])])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"连环问：闭包是内存泄漏嘛？\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"内存泄漏是非预期的情况，但是闭包他是完全符合我们的预期的，所以是合理的情况。\")])])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_1-1-js内存泄漏如何检测\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-js内存泄漏如何检测\"}},[a._v(\"#\")]),a._v(\" 1.1 js内存泄漏如何检测？\")]),a._v(\" \"),t(\"p\",[a._v(\"使用performance调试工具来检测\")]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_1-2-内存泄漏的场景\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-内存泄漏的场景\"}},[a._v(\"#\")]),a._v(\" 1.2 内存泄漏的场景\")]),a._v(\" \"),t(\"p\",[a._v(\"被全局变量、函数引用、组件销毁时未清除\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"window.arr =this.arr\\n\")])])]),t(\"p\",[a._v(\"被全局事件、定时器引用，组件销毁时未清除\")]),a._v(\" \"),t(\"div\",{staticClass:\"language-javascript extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"setInterval\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"=>\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n  console\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"log\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"this\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),a._v(\"arr\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),a._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),a._v(\"\\n\\nwindow\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),a._v(\"addEventListern\\n\")])])]),t(\"p\",[a._v(\"被自定义事件引用，组件销毁时未清除\")]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_1-3-weakmap-和weakset\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-3-weakmap-和weakset\"}},[a._v(\"#\")]),a._v(\" 1.3 weakMap 和weakSet\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"weakMap的成员只能是对象，而不能是其他类型的值。\")]),a._v(\" \"),t(\"li\",[a._v(\"WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_2-01-浏览器和nodejs的事件循环有什么关系\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-01-浏览器和nodejs的事件循环有什么关系\"}},[a._v(\"#\")]),a._v(\" 2.01 浏览器和nodejs的事件循环有什么关系\")]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_2、单线程和异步\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、单线程和异步\"}},[a._v(\"#\")]),a._v(\" 2、单线程和异步\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"单线程知识点\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"js是单线程\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"浏览器中js执行和dom渲染共用一个线程\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"异步\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"宏任务（setTimeout、serInterval，网络请求）\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"微任务（promise、async/await）\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"微任务在下一轮DOM渲染之前执行，宏任务再之后执行（简单的说就是先执行js上下文，再执行微任务，渲染dom，最后是宏任务）\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"       console.log('start')     //1\\n       const p = document.createElement('p')\\n       p.innerHTML ='12312'\\n       document.body.appendChild(p)   //4\\n\\n       setTimeout(()=>{\\n        console.log('timeout') //5\\n        alert('宏任务 setTimeout')\\n       })\\n       Promise.resolve().then(()=>{\\n        console.log('promise')  //3\\n        alert('微任务 promise')\\t//3\\n       })\\n\\n       console.log('end')   //2\\n       \\n       \\n       \\n\")])])])])])])])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"事件循环 EventLoop（浏览器）\")]),a._v(\" \"),t(\"p\",[a._v(\"![image-20220706224829526](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20220706224829526.png)\")])])]),a._v(\" \"),t(\"p\",[a._v(\"​\\t\\t\"),t(\"strong\",[a._v(\"先执行同步操作，遇到微任务，先放在微任务队列，遇到宏任务，放在宏任务队列，此时执行完同步操作，先执行微任务（队列先进先出），微任务执行完毕后，渲染dom，再执行宏任务队列，都执行完毕后，Event Loop将会继续监听\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_2-1-nodejs异步\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-nodejs异步\"}},[a._v(\"#\")]),a._v(\" 2.1 nodejs异步\")]),a._v(\" \"),t(\"ul\",[t(\"li\")]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_3、虚拟dom真的很快嘛\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、虚拟dom真的很快嘛\"}},[a._v(\"#\")]),a._v(\" 3、虚拟dom真的很快嘛？\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"vdome并不快，js直接操作Dom更块\")]),a._v(\" \"),t(\"li\",[a._v(\"但是数据驱动视图要有更合适的技术方案，不能全部DOM重建\")]),a._v(\" \"),t(\"li\",[a._v(\"Vdom就是目前最合适的技术方案（并不是他快，而是合适）\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_4、遍历数组-for和foreach那个更快\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、遍历数组-for和foreach那个更快\"}},[a._v(\"#\")]),a._v(\" 4、遍历数组，for和forEach那个更快？\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"for 更快\")]),a._v(\" \"),t(\"li\",[a._v(\"forEach每次都要创建一个函数来调用，而for不会创建函数\")]),a._v(\" \"),t(\"li\",[a._v(\"总结：越低级的代码，性能往往越好\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_5、请描述jsbridge-什么是js-bridge\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、请描述jsbridge-什么是js-bridge\"}},[a._v(\"#\")]),a._v(\" 5、请描述JSBridge ？什么是JS Bridge？\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"url schema   比如 weixin://\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"JS无法调用native ApI\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"需要通过一些特定的格式来调用\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"这些格式统称JS -Bridge 例如微信sdk\")])])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_6、requestanimationframe和requestidlecallback的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6、requestanimationframe和requestidlecallback的区别\"}},[a._v(\"#\")]),a._v(\" 6、requestAnimationFrame和requestIdleCallback的区别\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"requestAnimationFrame是高优的\")]),a._v(\" \"),t(\"li\",[a._v(\"requestIdleCallback是低优的\")]),a._v(\" \"),t(\"li\",[a._v(\"都属于宏任务，因为都是在dom渲染完毕后执行，但是高优的先执行，低优的后执行\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_7、vue的生命周期做了什么\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7、vue的生命周期做了什么\"}},[a._v(\"#\")]),a._v(\" 7、vue的生命周期做了什么\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"beforeCreate\\n\"),t(\"ul\",[t(\"li\",[a._v(\"创建了一个空白的VUE实例\")]),a._v(\" \"),t(\"li\",[a._v(\"Data 和metho尚未被初始化，不可使用\")])])]),a._v(\" \"),t(\"li\",[a._v(\"created\\n\"),t(\"ul\",[t(\"li\",[a._v(\"vue的实例被创建完了，完成了响应式的绑定\")]),a._v(\" \"),t(\"li\",[a._v(\"data method都已经初始化完成，可调用\")]),a._v(\" \"),t(\"li\",[a._v(\"尚未开始渲染模版\")])])]),a._v(\" \"),t(\"li\",[a._v(\"beforeMount\\n\"),t(\"ul\",[t(\"li\",[a._v(\"编译模版，调用reder生成vdom\")]),a._v(\" \"),t(\"li\",[a._v(\"还没有开始渲染dom\")])])]),a._v(\" \"),t(\"li\",[a._v(\"mounted\\n\"),t(\"ul\",[t(\"li\",[a._v(\"完成Dom\")]),a._v(\" \"),t(\"li\",[a._v(\"组件创建完成\")]),a._v(\" \"),t(\"li\",[a._v(\"开始由创建阶段进入运行阶段\")])])]),a._v(\" \"),t(\"li\",[a._v(\"updated\\n\"),t(\"ul\",[t(\"li\",[a._v(\"data发生变化，且dom更新完成\")]),a._v(\" \"),t(\"li\",[a._v(\"（不要再update中修改data，会造成死循环）\")])])]),a._v(\" \"),t(\"li\",[a._v(\"beforeUnmont\\n\"),t(\"ul\",[t(\"li\",[a._v(\"组件进入销毁阶段\")]),a._v(\" \"),t(\"li\",[a._v(\"可以出、解绑一些全局事件、自定义事件\")])])]),a._v(\" \"),t(\"li\",[a._v(\"unmounted\\n\"),t(\"ul\",[t(\"li\",[a._v(\"组件被销毁了\")]),a._v(\" \"),t(\"li\",[a._v(\"所有自组建也被销毁了\")])])]),a._v(\" \"),t(\"li\",[a._v(\"Keep-alive的actived和deactiveed\\n\"),t(\"ul\",[t(\"li\",[a._v(\"缓存组件被激活\")])])])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_8、vue什么时候操作dom比较合适\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8、vue什么时候操作dom比较合适\"}},[a._v(\"#\")]),a._v(\" 8、Vue什么时候操作dom比较合适\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"mounted和updated都不能保证自组建全部挂在完成\")]),a._v(\" \"),t(\"li\",[a._v(\"要放在$nextTick下执行\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_9、ajax放在那个生命周期那个比较合适\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9、ajax放在那个生命周期那个比较合适\"}},[a._v(\"#\")]),a._v(\" 9、ajax放在那个生命周期那个比较合适\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"created和mounted都可以\")]),a._v(\" \"),t(\"li\",[a._v(\"推荐mounted\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_10、vue3的composition-api生命周期有何区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10、vue3的composition-api生命周期有何区别\"}},[a._v(\"#\")]),a._v(\" 10、vue3的composition API生命周期有何区别\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"用setup代替了beforeCreated和created\")]),a._v(\" \"),t(\"li\",[a._v(\"使用hooks的形式\")])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_11、vue2vue3-react-三者diff算法有何区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11、vue2vue3-react-三者diff算法有何区别\"}},[a._v(\"#\")]),a._v(\" 11、vue2vue3 react 三者diff算法有何区别？\")]),a._v(\" \"),t(\"p\",[a._v(\"先说下diff算法\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"diff算法很早就有\")]),a._v(\" \"),t(\"li\",[a._v(\"github 中pull request就有diff\")]),a._v(\" \"),t(\"li\",[a._v(\"如果严格diff两棵树，时间复杂度O(n^3),不可用\")]),a._v(\" \"),t(\"li\",[a._v(\"tree diff的优化：（优化后的时间复杂度为O(n)）\\n\"),t(\"ul\",[t(\"li\",[a._v(\"之比较同意层级，不比较跨级\")]),a._v(\" \"),t(\"li\",[a._v(\"tag不同则删除重建\")]),a._v(\" \"),t(\"li\",[a._v(\"子节点通过key区分\")])])])]),a._v(\" \"),t(\"h4\",{attrs:{id:\"_12、vue-router-memoryhistory-v4之前叫做abstract-history\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12、vue-router-memoryhistory-v4之前叫做abstract-history\"}},[a._v(\"#\")]),a._v(\" 12、vue-router memoryHistory V4之前叫做abstract history\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"Hash 使用createHash\")]),a._v(\" \"),t(\"li\",[a._v(\"webHistory  使用createWebHistory\")]),a._v(\" \"),t(\"li\",[a._v(\"MemoryHistory 使用createMemoryHistory\")])])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}