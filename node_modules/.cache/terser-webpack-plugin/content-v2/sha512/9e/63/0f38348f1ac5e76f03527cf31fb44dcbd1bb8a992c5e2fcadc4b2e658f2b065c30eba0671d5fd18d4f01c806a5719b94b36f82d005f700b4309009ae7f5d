{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{352:function(e,r,t){\"use strict\";t.r(r);var o=t(14),i=Object(o.a)({},(function(){var e=this,r=e._self._c;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h3\",{attrs:{id:\"_43-vue3为什么用proxy代替defineproperty\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_43-vue3为什么用proxy代替defineproperty\"}},[e._v(\"#\")]),e._v(\" 43.vue3为什么用proxy代替defineProperty\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"属性拦截的集中方式\")]),e._v(\" \"),r(\"li\",[e._v(\"defineProperty的问题\")]),e._v(\" \"),r(\"li\",[e._v(\"Proxy的优点\")]),e._v(\" \"),r(\"li\",[e._v(\"其他考量\")])]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"JS中做属性拦截常见的方式有三：：defineProperty， getter/setters 和Proxies.\")]),e._v(\" \"),r(\"li\",[e._v(\"vue2中使用 defineproperty 的原因是，2013年时只能用这种方式。由于该AP!存在一些局限性，比如对于数组的拦截有问题，为此vue需要专门为数组响应式做一套实现。另外不能拦截那些新增、删除属性；最后defineproperty、方案在初始化时需要深度递归遍历待处理的对象才能对它进行完全拦截，明显增加了初始化的时间。\")]),e._v(\" \"),r(\"li\",[e._v(\"以上兩点在Proxy出现之后迎刃而解，不仅可以对数组拦截，还能对Map、 Set拦截：另外Prowy拦截也是懒处理行为，如果用户没有访问嵌套对象，那么也不会实施拦截，这就让初始化的速度和内存占用都改\\n善了。\")]),e._v(\" \"),r(\"li\",[e._v(\"当然Proxy是有兼容性问题的，I\")]),e._v(\" \"),r(\"li\",[e._v(\"E完全不支持，所以如果需要化兼容就不合适\")])])])}),[],!1,null,null,null);r.default=i.exports}}]);","extractedComments":[]}