{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{340:function(t,s,r){\"use strict\";r.r(s);var e=r(14),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h3\",{attrs:{id:\"_33-attrs和-listeners\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_33-attrs和-listeners\"}},[t._v(\"#\")]),t._v(\" 33.$attrs和$listeners\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[t._v(\"我们可能会有一些属性和事件没有在 props 中定义，这类称为非属性特性，结合 v-bind 指令可以直接透传给内部的子组件。\")])]),t._v(\" \"),s(\"li\",[s(\"p\",[t._v('这类“属性透传” 常常用于包装高阶组件时往内部传递属性，常用于爷孙组件之间传参。比如我在扩展A组件时创建了组件 B组件，然后在C组件中使用 B，此时传递给C 的属性中只有 props 里面声明的属性是给B使用的，其他的都是A 需要的，此时就可以利用 v-bind=\"$attrs\"透传下去。')])]),t._v(\" \"),s(\"li\",[s(\"p\",[t._v(\"最常见用法是结合 v-bind 做展开；$attrs 本身不是响应式的，除非访问的属性本身是响应式对象。\")])]),t._v(\" \"),s(\"li\",[s(\"p\",[t._v(\"vue2 中使用listeners获取事件，oue3中已移除，均合并到 attrs中，使用起来更简单了。\")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}