---
title: 综合面试题
date: 2022-12-12 14:50:00
category: 面试题
tag: js
# password: 123789
# abstract: 这里有东西被加密了，需要输入密码查看哦。
# message: 您好，这里需要密码。
# wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。
# wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。
---

# 前端基础

## 1、HTTP/HTML/浏览器

  ### 1.1说一下 http 和 https
    
+  (1)http 和 https 的基本概念
  
    http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服 务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传 输协议，它可以使浏览器更加高效，使网络传输减少。
    
    https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。
    https 协议的主要作用是:建立一个信息安全通道，来确保数组的传输，确保网站的真实 性。
+ (2)http 和 https 的区别?
    http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议 传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传 输和身份认证的网络协议，比 http 协议的安全性更高。
    主要的区别如下:
    Https 协议需要 ca 证书，费用较高。
    http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443
    http 的连接很简单，是无状态的;HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传 输、身份认证的网络协议，比 http 协议安全。
+ (3)https 协议的工作原理
    客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。 客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
    web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回或 者说传输给客户端。
    客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加 密会话密钥，并传送给网站。
    web 服务器通过自己的私钥解密出会话密钥。
    web 服务器通过会话密钥加密与客户端之间的通信。

+ (4)https 协议的优点
    使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。
    HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻 击的成本。
    谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。

+ (5)https 协议的缺点

    https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
    https 缓存不如 http 高效，会增加数据开销。
    SSL 证书也需要钱，功能越强大的证书费用越高。
    SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。

  ### 1.2   请描述 Tcp 三次握手和四次挥手
    - 先建立链接（确保双方都有首发消息的能力）
      - 在传输内容（发一个 get 请求）
      - 网络链接是 TCP 链接，传输协议是 HTTP 协议
    - 三次握手分别是（发起链接）
      - clinet 发包请求建立链接， server 接包 server：有 clint 要找我， （在不在啊？）
      - server 发包 ，client 节包 ，clinet：server 已经收到信息了（在的，我在）
      - Client 发送，server 接包 ，server：client 要准备发送了（我准备发送快递去你家了）
    - 四次挥手（断开链接）
      - clinet 发包，server 接包 ，server: clinet 已请求结束
      - server 发包，clinet 接包 ,clinet :server 已收到，我等待他关闭
      - server 发包，clinet 接包，clinet : server 此时可以关闭链接了(在数据完全发送完毕后发送挥手)
      - client 发包，server 接包，server：可以关闭了

    扩展：
    + 三次握手为什么两次不行
      + 只进行两次握手，不能确保客户端和服务器端都具有接收和发送能力的能力。两次握手之后，只能确认服务端有接收的能力，不能确认服务器端具有发送能力。
      + 如果是两次握手，还会出现下面的这种情况：如果客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。重传的请求收到了，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释以后到某个时间才到达服务器，此时服务端误认为客户端又发出一次新的请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务器端发出确认，就建立新的连接了，此时客户端忽略服务器发来的确认，也不发送数据，则服务器一直等待客户端发送数据，浪费资源。
    + 为什需要四次挥手呢？
      + 因为服务器端可能只有未发送完的数据，所以只能先发送一个ACK报文告诉客户端，你发送的FIN报文我收到了，待服务器端将数据发送完毕后，再发送FIN报文。
  
    
    ### 1.3 UDP协和和Http协议

    - http 在应用层
    - tcp、udp 是在传输层
    - tcp 的特点
      - 3 次握手
      - 4 次挥手
      - 稳定传输
    - udp 的特点
      - 无连接
      - 无断开
      - 不稳定传输，但传输效率高
      - 如视屏会议，语音通话

    ### 1.4 说一下 web Quality(无障碍)

    + 能够被残障人士使用的网站才能称得上一个易用的(易访问的)网站。 残障人士指的是那些带有残疾或者身体不健康的用户。使用 alt 属性:```<img src="person.jpg" alt="this is a person"/>``` 有时候浏览器会无法显示图像。具体的原因有:用户关闭了图像显示浏览器是不支持图形显示的迷你浏览器 浏览器是语音浏览器(供盲人和弱视人群使用)如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。

    ### 1.5 几个很实用的 BOM 属性对象方法?
    + location
      + location.href-- 返回或设置当前文档的 URL
      + location.search -- 返回 URL 中的查询字符串部分。例
  如 http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu 返回包括(?)后面的内 容?id=5&name=dreamdu
      + location.hash -- 返回 URL#后面的内容，如果没有#，返回空
      + location.host -- 返回 URL 中的域名部分，例如 www.dreamdu.com
      + location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com
      + location.pathname -- 返回 URL 的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返 回/xhtml/
      + location.port -- 返回 URL 中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回 8080
      + location.protocol -- 返回 URL 中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返 回(//)前面的内容 http:
      + location.assign -- 设置当前文档的 URL
      + location.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url);
      + location.reload() -- 重载当前页面
    + history
      + history.go() -- 前进或后退指定的页面数 history.go(num); 
      + history.back() -- 后退一页
      + history.forward() -- 前进一页
    + Navigator
      + navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字 符串)
      + navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

    ### 1.6 drag api
    + dragstart:事件主体是被拖放元素，在开始拖放被拖放元素时触发，。 
    + darg:事件主体是被拖放元素，在正在拖放被拖放元素时触发。 
    + dragenter:事件主体是目标元素，在被拖放元素进入某元素时触发。 
    + dragover:事件主体是目标元素，在被拖放在某元素内移动时触发。 
    + dragleave:事件主体是目标元素，在被拖放元素移出目标元素是触发。 
    + drop:事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 
    + dragend:事件主体是被拖放元素，在整个拖放操作结束时触发
    + 实现元素拖动
        ```
        <div class="droptarget" ondrop="drop(event)" ondragover="allowDrop(event)">
        <p ondragstart="dragStart(event)" " draggable="true" id="dragtarget">拖动我!</p>
        </div>
        <div class="droptarget" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
        <script>
        function dragStart(event) {
            event.dataTransfer.setData("Text", event.target.id);
        }
        function allowDrop(event) {
            event.preventDefault();
        }
        function drop(event) {
            event.preventDefault();
            var data = event.dataTransfer.getData("Text");
            event.target.appendChild(document.getElementById(data));
            document.getElementById("demo").innerHTML = "p 元素已被拖动";
        }
        </script>
        ```
        主要是 ondragstart 事件和 ondrop事件 ondragover事件（阻止默认事件）

        ### 1.7说下http2.0
        + 首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议 简要概括:http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。 提升访问速度(可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0) 允许多路复用:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改 善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限 制(连接数量)，超过限制会被阻塞。二进制分帧:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二 进制编码首部压缩服务器端推送
        
        ### 1.8 fetch 发送 2 次请求的原因

        + fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功? 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的 请求。如果不需要options请求，直接让后端遇到options请求直接返回就可以了，前端不做处理

        ### 1.9 web worker
        + 在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后， 页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你 的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就 不会阻塞主线程了。

        ### 1.10 对 HTML 语义化标签的理解
        HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签。

        ### 1.11 iframe 是什么?有什么缺点?

        定义:iframe 元素会创建包含另一个文档的内联框架 提示:可以将提示文字放在```<iframe></iframe>```之间，来提示某些不支持 iframe 的浏览器 

        缺点:
            会阻塞主页面的 onload 事件，搜索引擎无法解读这种页面，不利于 SEO
            iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

        ### 1.12 Doctype 作用?严格模式与混杂模式如何区分?它们有何意义?

        Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严 格模式和混杂模式。严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

        ### 1.13 Cookie 如何防范 XSS 攻击
        XSS(跨站脚本攻击)是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些 攻击，需要在 HTTP 头部配上，set-cookie:httponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。 结果应该是这样的```:Set-Cookie=<cookie-value>```

        ### 1.14 CSRF 攻击
        跨站请求伪造，是一种对网站的恶意利用。比如说你登录了一个普通网站，然后CSRF攻击者在你已经登录目标网站之后，诱使你访问一个恶意网站，那个恶意网站就可能会冒充你的身份来进行一些操作。（防御：1、重要的数据采用post进行接收，2、验证http referer字段，该字段记录了此次http请求的来源地址，3、使用验证码，只要涉及到数据交互就先进行验证码验证）

        ### 1.15 click 在 ios 上有 300ms 延迟，原因及如何解决?
        
        有三秒延迟因为之前的ios都是小屏幕，都需要双击来放大查看网页，这300ms延迟就是监听双击的中间区间。（1）所以直接在meta标签种设置user-sacable 为no即可。（2）用第三方库，fastClick。

        ### 1.16 addEventListener 参数
        addEventListener(event, function, useCapture)。其中，event 指定事件名;function 指定要事件触发时执行的函数;useCapture 指定事件 是否在捕获或冒泡阶段执行。

        ### 1.17 事件冒泡和和捕获
        + （1）事件捕获：由微软公司提出来的，事件从文档根节点（Document 对象）流向目标节点，途中会经过目标节点的各个父级节点，并在这些节点上触发捕获事件，直至到达事件的目标节点

        + （2）事件冒泡：由网景公司提出，与事件捕获相反，事件会从目标节点流向文档根节点，途中会经过目标节点的各个父级节点，并在这些节点上触发捕获事件，直至到达文档的根节点。整个过程就像水中的气泡一样，从水底向上运动
        + w3c 为了规范所以制定了先捕获后冒泡
        + 组织事件冒泡和下沉```e.stopPropagation()```

        ### 1.18 讲讲304

        304:如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容(自 上次访问以来或者根据请求的条件)并没有改变，则服务器应当返回这个 304 状态码

        ### 1.19 强缓存、协商缓存什么时候用哪个
        在第一次请求时，服务器会将页面最后修改时间通过Last-Modified标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个Etag，并发送给客户端。

        [第二次请求如图](https://segmentfault.com/img/bVuuo2)
        
        ### 1.20 前端优化
        降低请求量:合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度:预解析 DNS，减少域名数，并行加载，CDN 分发。缓存:HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。 渲染:JS/CSS 优化，加载顺序，服务端渲染，pipeline。



## 2、CSS
### 2.1 如何画一个三角形

```
div {
    width:0px;
    height:0px;
    border-top:10px solid red; border-right:10px solid transparent; border-bottom:10px solid transparent; border-left:10px solid transparent;
}
```

### 1.2 说一下浏览器缓存

缓存分为两种:强缓存和协商缓存，根据响应的 header 内容来决定。 强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话， cache-control 的优先级高于 expires。协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match

### 1.3 HTML5的新元素
首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section 等语义 化标签，在表单方面，为了增强表单，为 input 增加了 color，emial,data ,range 等类型， 在存储方面，提供了 sessionStorage，localStorage,和离线存储，通过这些存储方式方便数 据在客户端的存储和获取，在多媒体方面规定了音频和视频元素 audio 和 vedio，另外还 有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。

### 1.4 （重要）在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么? 
输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻 找缓存，查看缓存中是否有记录，缓存的查找记录为:浏览器缓存-》系统缓存-》路由 器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务 器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http 请 求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数 据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层， 数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载 相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html 代码的后面，之 后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成 后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和 排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析 DOM 的过 程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一 般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache-Control 和 Expires 的区别 在于 Cache-Control 使用相对时间，Expires 使用的是基于服务器 端的绝对时间，因为存 在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先 查看 是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修 改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match 的值交给 服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。

### 1.5 盒子模型
+ 怪异盒子模型（ie） content的宽高 = content+padding+border
+ 标准盒子模型 宽高等于content的宽高

### 1.6 画一条0.5px的线
+ 采用 border-image 的方式
+ 采用 transform: scale()的方式

### 1.7 link和import标签的区别

+ link属于html标签，而@import是css提供的
+ 页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。 
+ link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。
+ link 方式样式的权重高于@import 的。

### 1.8 transition 和 animation 的区别

Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值，他们 的主要区别是 transition 需要触发一个事件才能改变属性，而 animation 不需要触发任何 事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从 from .... to，而 animation 可以一帧一帧的。

### 1.9 BFC 块级格式化上下文
块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。 BFC 区域不会与 float box 重叠
那些元素会生成BFC：
+ float 不为 none 的元素
+ position 为 fixed 和 absolute 的元素
+ display 为 inline-block、table-cell、table-caption，flex，
+ inline-flex 的元素 overflow 不为 visible 的元素

### 1.10 关于 JS 动画和 css3 动画的差异性
    
渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和 opacity， 这时整个 CSS 动画得以在 compositor trhead 完成(而 JS 动画则会在 main thread 执行，然 后出发 compositor thread 进行下一步操作)，特别注意的是如果改变 transform 和 opacity 是不会 layout 或者 paint 的。
区别:
+ 功能涵盖面，JS 比 CSS 大
+ 实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定 对帧速表现不好的低版本浏览器，css3 可以做到自然降级
+ css 动画有天然事件支持
+ css3 有兼容性问题

### 1.11 多行元素的文本省略号

```
display: -webkit-box; 
-webkit-box-orient:vertical;
-webkit-line-clamp:3;
overflow:hidden;
```

### 1.12 双边距重叠问题(外边距折叠）
    多个相邻(兄弟或者父子关系)普通流的块元素垂直方向 marigin 会重叠 折叠的结果为: 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。

### 1.13 浮动清除
+ .clear{clear:both;}
+ 
## 3、JS


# 前端核心
## 1、服务端编程
## 2、AJAX
## 3、移动web开发


# 前端进阶
## 1、前端工程化
## 2、Vue2
## 3、Vue3