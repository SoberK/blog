---
title: 提升 - 深度知识
date: 2022-08-13 10:24:31
category: 提升
tag: js
# password: 123789
# abstract: 这里有东西被加密了，需要输入密码查看哦。
# message: 您好，这里需要密码。
# wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。
# wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。
---

#### 1、垃圾回收 GC

- 什么是垃圾回收机制

  - 在函数被执行完了，再也用不到的数据或者变量，算法会清除

- 垃圾回收机制的算法

  - 计数方式（之前）

  ```
  let a = {x:100}
  let a1 = a;
  a = 10;
  a1 = null;
  //此时{x:100}没有变量指向了，那么标记指向的数为0，那么就被清楚
  但是有个问题

  const obj1 = {};
  const obj2 = {}
  obj1.a = obj2;
  obj2.a = obj1;
  进行了循环引用，这样计数方式就没有用了
  ```

  - 标记清除（现代）

#### 2、单线程和异步

- 单线程知识点

  - js 是单线程

  - 浏览器中 js 执行和 dom 渲染共用一个线程

  - 异步

    - 宏任务（setTimeout、serInterval）

    - 微任务（promise、async/await）

    - 微任务在下一轮 DOM 渲染之前执行，宏任务再之后执行（简单的说就是先执行 js 上下文，再执行微任务，渲染 dom，最后是宏任务）

      ```
             console.log('start')     //1
             const p = document.createElement('p')
             p.innerHTML ='12312'
             document.body.appendChild(p)   //4

             setTimeout(()=>{
              console.log('timeout') //5
              alert('宏任务 setTimeout')
             })
             Promise.resolve().then(()=>{
              console.log('promise')  //3
              alert('微任务 promise')	//3
             })

             console.log('end')   //2



      ```

- 事件循环 EventLoop（浏览器）

  ![image-20220706224829526](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20220706224829526.png)

​ **先执行同步操作，遇到微任务，先放在微任务队列，遇到宏任务，放在宏任务队列，此时执行完同步操作，先执行微任务（队列先进先出），微任务执行完毕后，渲染 dom，再执行宏任务队列，都执行完毕后，Event Loop 将会继续监听**

#### 3、虚拟 dom 真的很快嘛？

- vdome 并不快，js 直接操作 Dom 更块
- 但是数据驱动视图要有更合适的技术方案，不能全部 DOM 重建
- Vdom 就是目前最合适的技术方案（并不是他快，而是合适）

#### 4、遍历数组，for 和 forEach 那个更快？

- for 更快
- forEach 每次都要创建一个函数来调用，而 for 不会创建函数
- 总结：越低级的代码，性能往往越好

#### 5、请描述 JSBridge ？什么是 JS Bridge？

- url schema

- JS 无法调用 native ApI
- 需要通过一些特定的格式来调用
- 这些格式统称 JS -Bridge 例如微信 sdk

#### 6、requestAnimationFrame 和 requestIdleCallback 的区别

- requestAnimationFrame 是高优的
- requestIdleCallback 是低优的
- 都属于宏任务，因为都是在 dom 渲染完毕后执行，但是高优的先执行，低优的后执行

#### 7、vue 的生命周期做了什么

- beforeCreate
  - 创建了一个空白的 VUE 实例
  - Data 和 metho 尚未被初始化，不可使用
- created
  - vue 的实例被创建完了，完成了响应式的绑定
  - data method 都已经初始化完成，可调用
  - 尚未开始渲染模版
- beforeMount
  - 编译模版，调用 reder 生成 vdom
  - 还没有开始渲染 dom
- mounted
  - 完成 Dom
  - 组件创建完成
  - 开始由创建阶段进入运行阶段
- updated
  - data 发生变化，且 dom 更新完成
  - （不要再 update 中修改 data，会造成死循环）
- beforeUnmont
  - 组件进入销毁阶段
  - 可以出、解绑一些全局事件、自定义事件
- unmounted
  - 组件被销毁了
  - 所有自组建也被销毁了
- Keep-alive 的 actived 和 deactiveed
  - 缓存组件被激活

#### 8、Vue 什么时候操作 dom 比较合适

- mounted 和 updated 都不能保证自组建全部挂在完成
- 要放在$nextTick 下执行

#### 9、ajax 放在那个生命周期那个比较合适

- created 和 mounted 都可以
- 推荐 mounted

#### 10、vue3 的 composition API 生命周期有何区别

- 用 setup 代替了 beforeCreated 和 created
- 使用 hooks 的形式

#### 11、vue2vue3 react 三者 diff 算法有何区别？

-

#### 12、vue-router memoryHistory V4 之前叫做 abstract history

- Hash 使用 createHash
- webHistory 使用 createWebHistory
- MemoryHistory 使用 createMemoryHistory
