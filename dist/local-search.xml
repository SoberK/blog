<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue系列 - reative和toRef以及toRefs</title>
    <link href="/2022/08/17/vue%E7%B3%BB%E5%88%97%20-%20reative%E5%92%8CtoRef%E4%BB%A5%E5%8F%8AtoRefs/"/>
    <url>/2022/08/17/vue%E7%B3%BB%E5%88%97%20-%20reative%E5%92%8CtoRef%E4%BB%A5%E5%8F%8AtoRefs/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-reative-和-toRef-以及-toRefs"><a href="#vue-系列-reative-和-toRef-以及-toRefs" class="headerlink" title="vue 系列 - reative 和 toRef 以及 toRefs"></a>vue 系列 - reative 和 toRef 以及 toRefs</h1><h2 id="使基本类型变成响应式数据的方法-ref"><a href="#使基本类型变成响应式数据的方法-ref" class="headerlink" title="使基本类型变成响应式数据的方法 ref"></a>使基本类型变成响应式数据的方法 ref</h2><ul><li>reative<ul><li>使整个对象边成响应式对象</li><li>但是直接取出来响应会失效，所以会用到 otRef 和 toRefs</li></ul></li><li>toRef<ul><li>获取某个属性，取出来之后该属性还是具有响应式</li><li>写法（ts）：<code>const fooRef=toRef&lt;stateType,&quot;foo&quot;&gt;(state,&quot;foo&quot;);</code></li></ul></li><li>toRefs<ul><li>把其中的属性全部结构处理成响应式的数据，如果是多重结构，那么这个数据还是响应式的数据</li><li>写法（ts）：<code>const &#123;foo,bar,obj&#125; = toRefs&lt;stateType&gt;(state);</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - ref和unref</title>
    <link href="/2022/08/17/vue%E7%B3%BB%E5%88%97%20-%20ref%E5%92%8Cunref/"/>
    <url>/2022/08/17/vue%E7%B3%BB%E5%88%97%20-%20ref%E5%92%8Cunref/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-ref-和-unref"><a href="#vue-系列-ref-和-unref" class="headerlink" title="vue 系列 - ref 和 unref"></a>vue 系列 - ref 和 unref</h1><h2 id="使基本类型变成响应式数据的方法-ref"><a href="#使基本类型变成响应式数据的方法-ref" class="headerlink" title="使基本类型变成响应式数据的方法 ref"></a>使基本类型变成响应式数据的方法 ref</h2><ul><li>如果传入对象的话，内部会自动转换 reative 方法全部转换</li><li>提供了 Ref 类型断言</li><li>使用 unref 去返回一个 ref 之前的基本类型，不能转换 reative</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">Function useState<span class="hljs-variable">&lt;State extends string&gt;</span>(initial:State)&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> =ref(initial )as Ref<span class="hljs-variable">&lt;State&gt;</span>// <span class="hljs-keyword">state</span>.value -&gt; State extends stringreturnstate<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="使响应式数据变为基本数据-unref"><a href="#使响应式数据变为基本数据-unref" class="headerlink" title="使响应式数据变为基本数据 unref"></a>使响应式数据变为基本数据 unref</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">unwrapped</span> <span class="hljs-operator">=</span> unref(x)；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - Suspense</title>
    <link href="/2022/08/16/vue%E7%B3%BB%E5%88%97%20-%20Suspense/"/>
    <url>/2022/08/16/vue%E7%B3%BB%E5%88%97%20-%20Suspense/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-Suspense"><a href="#vue-系列-Suspense" class="headerlink" title="vue 系列 - Suspense"></a>vue 系列 - Suspense</h1><p>在使用异步组件的时候，为了获得更好的交互体验，新增了 Suspense,Suspense 有两个插槽一个是#default 一个是#fallback，其中 fallback 就是在异步请求的时候展示的插槽</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>  父组件</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;Vite + Vue&quot;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span></span><br><span class="language-xml">    loading......</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/HelloWorld.vue&#x27;</span>));</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">defineProps&lt;&#123; <span class="hljs-attr">msg</span>: string &#125;&gt;()</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">featchData</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Vite + Vue&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">3000</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">await</span> <span class="hljs-title function_">featchData</span>()</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - vue3新特性</title>
    <link href="/2022/08/15/vue%E7%B3%BB%E5%88%97%20-%20vue3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/08/15/vue%E7%B3%BB%E5%88%97%20-%20vue3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-vue3-新特性"><a href="#vue-系列-vue3-新特性" class="headerlink" title="vue 系列 - vue3 新特性"></a>vue 系列 - vue3 新特性</h1><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>组合式 api ，允许开发者使用导入函数的方式来替代配置类型开发。</p><ul><li>主要添加了 Reactivity API，例如 ref()and reactive()，它允许我们直接创建反应状态、计算状态和观察者。</li><li>声明周期钩子</li><li>依赖注入</li></ul><h3 id="为什么使用组合-API"><a href="#为什么使用组合-API" class="headerlink" title="为什么使用组合 API"></a>为什么使用组合 API</h3><h4 id="更好的逻辑重用"><a href="#更好的逻辑重用" class="headerlink" title="更好的逻辑重用"></a>更好的逻辑重用</h4><p>解决了 mixins 的所有缺点，mixins 的缺点如果多个，主要重点在逻辑重用。</p><h4 id="更灵活的代码"><a href="#更灵活的代码" class="headerlink" title="更灵活的代码"></a>更灵活的代码</h4><p>在编写 options api 时候，我们会在不同的生命周期、data、以及 methos 等 options 中配置不通的逻辑代码，这样会使代码变得复杂。逻辑混淆在一起，对于阅读开发以及后期维护，都会是很难进行的。 在使用 compositionApi 的时候，我们可以将重点放在一起，并且能够提取到不同的文件中。这种减少重构的摩擦是维护大型项目的关键。</p><h4 id="更好的类型断言"><a href="#更好的类型断言" class="headerlink" title="更好的类型断言"></a>更好的类型断言</h4><p>在 ts 的开发时，提供了不通的类型，方便开发者使用</p><h4 id="更小的生产包和更少的开销"><a href="#更小的生产包和更少的开销" class="headerlink" title="更小的生产包和更少的开销"></a>更小的生产包和更少的开销</h4><p><code>&lt;script setup&gt;</code> 更高效，更易于缩小，这事因为 scrip setup 被编译成内连在同一<code>&lt;script setup&gt;</code>代码范围内的函数，没有了实例代理，所以代码更小</p><h2 id="SFC-Composition-API-Syntax-Sugar"><a href="#SFC-Composition-API-Syntax-Sugar" class="headerlink" title="SFC Composition API Syntax Sugar"></a>SFC Composition API Syntax Sugar</h2><p>提供了一些编译的语法糖，<code>&lt;script setup&gt;</code>推荐在 sfc 和 composition Api 开发时使用</p><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>在某些场景下，我们需要标签的渲染位置有所改变，比如 modal，在子组件中，我们想要把页面渲染在 body 层级，而不是子组件中，此时我们就可以用到<code>&lt;Teleport&gt;</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;Teleport to=<span class="hljs-string">&quot;body&quot;</span>&gt;<br>  &lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;open&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">modal</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">p</span>&gt;<span class="hljs-symbol">Hello</span> <span class="hljs-symbol">from</span> <span class="hljs-symbol">the</span> <span class="hljs-symbol">modal</span>!&lt;/<span class="hljs-symbol">p</span>&gt;<br>    &lt;<span class="hljs-symbol">button</span> @<span class="hljs-symbol">click</span>=&quot;<span class="hljs-symbol">open</span> = <span class="hljs-symbol">false</span>&quot;&gt;<span class="hljs-symbol">Close</span>&lt;/<span class="hljs-symbol">button</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">Teleport</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><p>支持多个跟标签</p><h2 id="Emits-Component-Option"><a href="#Emits-Component-Option" class="headerlink" title="Emits Component Option"></a>Emits Component Option</h2><p>添加 emits 属性验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">emits</span>: &#123;<br>    <span class="hljs-comment">// no validation</span><br>    <span class="hljs-attr">click</span>: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-comment">// with validation</span><br>    <span class="hljs-attr">submit</span>: <span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (payload.<span class="hljs-property">email</span> &amp;&amp; payload.<span class="hljs-property">password</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Invalid submit event payload!`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createRenderer-API-from-vue-x2F-runtime-core-to-create-custom-renderers"><a href="#createRenderer-API-from-vue-x2F-runtime-core-to-create-custom-renderers" class="headerlink" title="createRenderer API from @vue&#x2F;runtime-core to create custom renderers"></a>createRenderer API from @vue&#x2F;runtime-core to create custom renderers</h2><p>自定义渲染器</p><h2 id="SFC-State-driven-CSS-Variables-v-bind-in-lt-style-gt"><a href="#SFC-State-driven-CSS-Variables-v-bind-in-lt-style-gt" class="headerlink" title="SFC State-driven CSS Variables (v-bind in &lt;style&gt;)"></a>SFC State-driven CSS Variables (v-bind in <code>&lt;style&gt;</code>)</h2><p>SfC css 变量,css 可以支持 v-bind 语法，直接和变量绑定，这样更简单的去绑定 css 样式<br>setup 写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> red = <span class="hljs-string">&quot;red&quot;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#app</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">v-bind</span>(red);</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>options 写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">time</span>: <span class="hljs-number">1000</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">them</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">red</span>: <span class="hljs-string">&quot;red&quot;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#app</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">v-bind</span>(<span class="hljs-string">&quot;them.red&quot;</span>);</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>注意如果 red 是多层的引用类型的，则需要在变量中使用引号给包裹住</p><h2 id="SFC-lt-style-scoped-gt-can-now-include-global-rules-or-rules-that-target-only-slotted-content"><a href="#SFC-lt-style-scoped-gt-can-now-include-global-rules-or-rules-that-target-only-slotted-content" class="headerlink" title="SFC &lt;style scoped&gt;  can now include global rules or rules that target only slotted content"></a>SFC <code>&lt;style scoped&gt; </code> can now include global rules or rules that target only slotted content</h2><p>vue 的深度选择器的语法变化</p><ul><li><p>v2</p><ul><li><code>&gt;&gt;&gt;</code></li><li><code>/deep/</code></li></ul></li><li><p>v3</p><ul><li><code>::v-deep()</code> 或者 <code>:deep()</code></li><li>默认情况下，从父级传入的插槽内容不再受子级样式的影响。相反，孩子现在需要使用新的::v-slotted()伪元素来专门针对插槽内容</li><li>新的伪元素<code>::v-global()</code>可用于在<code>&lt;style scoped&gt;</code>块内应用全局规则：</li></ul><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren">::<span class="hljs-variable">v</span><span class="hljs-operator">-</span><span class="hljs-variable">deep</span> .<span class="hljs-property">bar</span> &#123;&#125; <span class="hljs-comment">//不推荐</span><br>::<span class="hljs-variable">v</span><span class="hljs-operator">-</span><span class="hljs-title function_">deep</span>(.<span class="hljs-params">bar</span>) &#123;&#125;<br>::<span class="hljs-variable">v</span><span class="hljs-operator">-</span><span class="hljs-title function_">slotted</span>(.<span class="hljs-params">foo</span>) &#123;&#125;<br>::<span class="hljs-variable">v</span><span class="hljs-operator">-</span><span class="hljs-title function_">global</span>(.<span class="hljs-params">foo</span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Suspense-experimental"><a href="#Suspense-experimental" class="headerlink" title="Suspense experimental"></a>Suspense experimental</h2><p>新标签<code>&lt;Suspense /&gt;</code>,具体使用后面会说到</p>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - 权限控制</title>
    <link href="/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-权限控制"><a href="#vue-系列-权限控制" class="headerlink" title="vue 系列 - 权限控制"></a>vue 系列 - 权限控制</h1><p>思路:</p><ul><li><p>权限管理需求分析：页面和按钮权限</p></li><li><p>权限管理的实现方案：后端方案和前端方案</p><ul><li><p>前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个 asyncRoutes 数组，需要认证的页面在其路由的 meta 中添加一个 roles 字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过 router.addRoutes(accessRoutes)方式动态添加路由即可。</p></li><li><p>后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过 addRoutes 动态添加路由信息</p></li><li><p>按钮权限的控制通常会实现一个指令，例如 v-permission，将按钮要求角色通过值传给 v-permission 指令，在指令的 moutned 钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。</p></li></ul></li><li><p>各自的优缺点</p><ul><li>纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - one-way data flow</title>
    <link href="/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20one-way%20date%20flow/"/>
    <url>/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20one-way%20date%20flow/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-单向数据流"><a href="#vue-系列-单向数据流" class="headerlink" title="vue 系列 - 单向数据流"></a>vue 系列 - 单向数据流</h1><ul><li>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</li><li>场景：<ul><li>当作初始值<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">props: [<span class="hljs-symbol">&#x27;initialCounter</span>&#x27;],<br>data: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    counter: this.initialCounter<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>当作要进行转换<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">props: [<span class="hljs-symbol">&#x27;initialCounter</span>&#x27;],<br>data: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    counter: this.initialCounter<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果确实像改变这个值的话，我们应该使用某个属性去 emit，或者使用双向数据绑定来实现</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue系列 - mixins和extends</title>
    <link href="/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20mixins%E5%92%8Cextends/"/>
    <url>/2022/08/14/vue%E7%B3%BB%E5%88%97%20-%20mixins%E5%92%8Cextends/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-系列-mixins-和-extends"><a href="#vue-系列-mixins-和-extends" class="headerlink" title="vue 系列 - mixins 和 extends"></a>vue 系列 - mixins 和 extends</h1><h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>用来混入一个对象，在被混入的对象中是可以调用 mixins 中的对象，mixins 可以混入多个，如果有多个生命周期，生命周期将会同时进行,如果 data 中都有相同的属性，则访问的 data 中的属性是当前的组件.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,<br>  <span class="hljs-attr">mixins</span>:[mixins,mixins2],<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;App created&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span>)<br>  &#125;,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">time</span>:<span class="hljs-number">1000</span>,<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mixin created&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">time</span>: <span class="hljs-number">2000</span>,<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">结果同时打印：<br>  “<span class="hljs-keyword">mixin</span> created”<br>  “App created”<br></code></pre></td></tr></table></figure><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>用法和 mixins 类似，不多赘述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,<br>  <span class="hljs-attr">exntends</span>:,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;App created&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span>)<br>  &#125;,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">time</span>:<span class="hljs-number">1000</span>,<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;extend created&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">time</span>: <span class="hljs-number">2000</span>,<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">结果同时打印：<br>  “<span class="hljs-keyword">extend</span> created”<br>  “App created”<br></code></pre></td></tr></table></figure><h2 id="mixins-和-extends、以及-vue-mixins-的区别"><a href="#mixins-和-extends、以及-vue-mixins-的区别" class="headerlink" title="mixins 和 extends、以及 vue.mixins 的区别"></a>mixins 和 extends、以及 vue.mixins 的区别</h2><ul><li>他们之间的权重：vue.mixins&gt;extends&gt;mixins&gt;当前组件。</li><li>mixins 可以有多个，使用数组隔开，他们之间运行的先后顺序取决于数组的先后顺序</li><li>extneds 只能有一个</li></ul><h2 id="vue-mixin"><a href="#vue-mixin" class="headerlink" title="vue.mixin"></a>vue.mixin</h2><p>vue.mixin 是一个全局 api，如果在全局引入了该对象，全局都可以访问到该对象，不推荐使用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Vue.<span class="hljs-keyword">mixin</span>(<span class="hljs-keyword">mixin</span>)<br></code></pre></td></tr></table></figure><h2 id="vue-extend"><a href="#vue-extend" class="headerlink" title="vue.extend"></a>vue.extend</h2><p>vue.extned 和上面所说的混入盖联没有任何关系，主要的用于组件的开发.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> testComponent = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;extend test&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> extendComponent = <span class="hljs-keyword">new</span> <span class="hljs-title function_">testComponent</span>().$mount()<br></code></pre></td></tr></table></figure><h2 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h2><ul><li>vue3<ul><li>选项式 一样</li><li>组合式 没有 mixin，使用组合式 api 来替代</li><li>vu3 的全局 vue.mixin 变为了实例方法（app.mixin）而不是 vue2 中的静态方法(vue.mixin)</li><li></li></ul></li></ul><h2 id="拓展问题：如果想要扩展一个组件怎么做？"><a href="#拓展问题：如果想要扩展一个组件怎么做？" class="headerlink" title="拓展问题：如果想要扩展一个组件怎么做？"></a>拓展问题：如果想要扩展一个组件怎么做？</h2><ul><li>按照逻辑扩展和内容扩展来列举，逻辑扩展有：mixins、extends、composition api；内容扩展有 slots；</li><li>分别说出他们使用方法、场景差异和问题。</li><li>作为扩展，还可以说说 vue3 中新引入的 composition api 带来的变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查漏补缺 - .1+0.2===0.3嘛？</title>
    <link href="/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20.1+0.2===0.3%E5%98%9B%EF%BC%9F/"/>
    <url>/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20.1+0.2===0.3%E5%98%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="0-1-0-2-x3D-x3D-x3D-0-3-嘛？"><a href="#0-1-0-2-x3D-x3D-x3D-0-3-嘛？" class="headerlink" title="0.1+0.2&#x3D;&#x3D;&#x3D;0.3 嘛？"></a>0.1+0.2&#x3D;&#x3D;&#x3D;0.3 嘛？</h1><h3 id="基本概念：Number-是浮点数，表示小数会有精度损失。"><a href="#基本概念：Number-是浮点数，表示小数会有精度损失。" class="headerlink" title="基本概念：Number 是浮点数，表示小数会有精度损失。"></a>基本概念：Number 是浮点数，表示小数会有精度损失。</h3><h3 id="递进：浮点数标识规则"><a href="#递进：浮点数标识规则" class="headerlink" title="递进：浮点数标识规则"></a>递进：浮点数标识规则</h3>]]></content>
    
    
    <categories>
      
      <category>查漏补缺</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查漏补缺 - 数字超过最大限制的如何处理？</title>
    <link href="/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20%E6%95%B0%E5%AD%97%E8%B6%85%E8%BF%87%E6%9C%80%E5%A4%A7%E9%99%90%E5%88%B6%E7%9A%84%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/"/>
    <url>/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20%E6%95%B0%E5%AD%97%E8%B6%85%E8%BF%87%E6%9C%80%E5%A4%A7%E9%99%90%E5%88%B6%E7%9A%84%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="数字超过最大限制的如何处理？"><a href="#数字超过最大限制的如何处理？" class="headerlink" title="数字超过最大限制的如何处理？"></a>数字超过最大限制的如何处理？</h1><h3 id="核心：超出部分要用高精度处理方法"><a href="#核心：超出部分要用高精度处理方法" class="headerlink" title="核心：超出部分要用高精度处理方法"></a>核心：超出部分要用高精度处理方法</h3><blockquote><p>原因：计算机不能正常存储庞大的数字，这时候就将数字一位一位拆开，存储到数组中，用一个数组表示一个数字，这样的一个数字就是高精度数。高精度算法能处理高精度数各种运算的算法，但又因其特殊性，故从普通数的算法中分离，自成一家。</p></blockquote><h4 id="常用的-js-工具"><a href="#常用的-js-工具" class="headerlink" title="常用的 js 工具"></a>常用的 js 工具</h4><ul><li>BigInt</li><li>BigDecimal</li><li>JSON-BigInt</li></ul>]]></content>
    
    
    <categories>
      
      <category>查漏补缺</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查漏补缺 - 构造函数返回的值与new实例关系</title>
    <link href="/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E5%80%BC%E4%B8%8Enew%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/08/13/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E5%80%BC%E4%B8%8Enew%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数返回的值与-new-实例关系"><a href="#构造函数返回的值与-new-实例关系" class="headerlink" title="构造函数返回的值与 new 实例关系"></a>构造函数返回的值与 new 实例关系</h1><p>new 一个构造函数，如果函数返回 return {}、return null 、return 1,return true 会发生什么情况?</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">newNull</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">null&#125;</span>    //返回 ｛｝<br><span class="hljs-keyword">function</span> <span class="hljs-title">newUndefined</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">undefined&#125;</span>    //返回 ｛｝<br><span class="hljs-keyword">function</span> <span class="hljs-title">newNumber</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">1&#125;</span>    //返回 ｛｝<br><span class="hljs-keyword">function</span> <span class="hljs-title">newBoolean</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">true&#125;</span>    //返回 ｛｝<br><span class="hljs-keyword">function</span> <span class="hljs-title">newSymbol</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">Symbol()&#125;</span>    //返回 ｛｝<br><span class="hljs-keyword">function</span> <span class="hljs-title">newObject</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">&#123;a:1&#125;&#125;</span>    //返回 &#123;a:<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">newArray</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-type">[1,2]&#125;</span>    //返回 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><blockquote><p>由此得出结论，基本返回的是基本类型返回空对象，如果返回引用类型返回的就是返回的值</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>查漏补缺</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提升 - 工作经验</title>
    <link href="/2022/08/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    <url>/2022/08/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="1、H5-页面如何进行首屏优化"><a href="#1、H5-页面如何进行首屏优化" class="headerlink" title="1、H5 页面如何进行首屏优化"></a>1、H5 页面如何进行首屏优化</h4><ul><li>路由懒加载<ul><li>使用 SPA</li><li>路由拆分，首先保证首页加载</li></ul></li><li>服务端 ssr<ul><li>传统前后台分离渲染过</li><li>Ssr 渲染页面过程简单，所有性能好</li><li>如果是纯 H5 页面，ssr 是性能优化的中级方案</li></ul></li><li>App 预取<ul><li>如果 H5 在 App WebView 中展示，可使用 App 预取</li><li>用户访问列表页时，App 预加载文章首屏内容</li><li>用户进入 H5 页，直接从 App 中获取内容，瞬间展示首屏</li></ul></li><li>分页</li><li>图片懒加载<ul><li>针对详情页</li><li>默认值展示文本内容，让后触发图片的懒加载</li><li>提前设置图片尺寸，尽量只重绘不重排</li></ul></li><li>Hybrid<ul><li>提前将 html、js、css 下载到 app 内部，</li><li>在 app webview 中使用 file&#x2F;&#x2F;:协议直接加载页面文件</li><li>再用 ajax 获取内容并展示</li></ul></li></ul><h4 id="2、后端放回-10w-条数据，前端怎么展示"><a href="#2、后端放回-10w-条数据，前端怎么展示" class="headerlink" title="2、后端放回 10w 条数据，前端怎么展示"></a>2、后端放回 10w 条数据，前端怎么展示</h4><ul><li>设计不合理，本省技术方案设计就不合理</li><li>主动和面试官共同此事</li><li>非要这么做，那么寻找解决方案<ul><li>js 处理的话，dom 渲染会非常卡</li><li>自定义中间层</li><li>虚拟列表<ul><li>只渲染可是区域的 dom</li><li>其他隐藏的区域不展示，只用 div 的高度</li><li>随着滚动条的滚动控制展示，不在可是区域的不展示</li><li>第三方控件<ul><li>Vue-virtual-scroll-list</li><li>React-virtualiszed</li></ul></li></ul></li></ul></li></ul><h4 id="3、前端常用的设计模式有那些？并说明使用场景（javascript-设计模式系统讲解与应用）"><a href="#3、前端常用的设计模式有那些？并说明使用场景（javascript-设计模式系统讲解与应用）" class="headerlink" title="3、前端常用的设计模式有那些？并说明使用场景（javascript 设计模式系统讲解与应用）"></a>3、前端常用的设计模式有那些？并说明使用场景（javascript 设计模式系统讲解与应用）</h4><ul><li><p>设计原则</p><ul><li>最重要的思想：开放封闭原则</li><li>对扩展开放</li><li>对修改封闭</li></ul></li><li><p>工厂模式</p><ul><li><p>用一个工厂函数，来创建实例，影藏 new</p></li><li><p>如 jq 的$函数</p></li><li><p>&#96;&#96;&#96;<br> class Foo{}<br>    function factory(a,b,c){<br>        return new Foo();<br>    }<br>    const f &#x3D; factory(1,2,3)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 单列模式<br><br><span class="hljs-bullet">  -</span> 全局唯一的实例（无法生成第二个）<br><br><span class="hljs-bullet">  -</span> 如 vuex、redux、store<br><br><span class="hljs-bullet">  -</span> 如全局唯一的 dialog model<br><br></code></pre></td></tr></table></figure><p>class SingleTon{<br>private static instance:SignleTon|null &#x3D; null<br>private constructor(){}<br>public static getInstance(): SingleTon {<br>    if(install){<br>            returnthis.instance<br>    }<br>     this.instance  &#x3D; new SingleTon()<br>     return this.instance<br>}<br>fn10(){}<br>fn20(){}<br>}<br>const s &#x3D; SingleTon.getInstance()<br>s.fn1()<br>s. fn2()<br>cost s1 &#x3D; SingleTon.getInstance()<br>c&#x3D;&#x3D;&#x3D; c1 &#x2F;&#x2F;false</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><br>- 代理模式<br><br>  - Proxy<br>  - vue3 的设计就是一种场景<br><br>- 观察者模式<br><br>  - 一个主题，一个观察者，主题变后，触发观察者执行<br><br>- 发布订阅模式<br><br>  - ```<br>    event.on(<span class="hljs-string">&#x27;event-key&#x27;</span>,<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;&#125;)<br>    event.emit(<span class="hljs-string">&#x27;event-key&#x27;</span>,<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>装饰器模式</p><ul><li>员工能不变，增加一些新功能</li><li>es 和 typescript 的 Decorator</li></ul></li></ul><h3 id="4、观察者模式和发布订阅模式之间的区别"><a href="#4、观察者模式和发布订阅模式之间的区别" class="headerlink" title="4、观察者模式和发布订阅模式之间的区别"></a>4、观察者模式和发布订阅模式之间的区别</h3><p>![image-20220712144315734](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220712144315734.png)</p><ul><li>观察者模式<ul><li>Subject 和 Observer 直接绑定，没有中间媒介</li><li>如 addeventListener</li></ul></li><li>发布订阅<ul><li>是 publish 和 observer 互不相识，需要中间媒介</li><li>如 eventBus</li></ul></li></ul><h4 id="5、你在实际工作中，做过那些-vue-优化"><a href="#5、你在实际工作中，做过那些-vue-优化" class="headerlink" title="5、你在实际工作中，做过那些 vue 优化"></a>5、你在实际工作中，做过那些 vue 优化</h4><ul><li>v-if 和 v-show</li><li>v-for 使用 key</li><li>使用 compted 缓存</li><li>keep-alive 缓存组件</li><li>异步组件</li><li>路由懒加载</li><li>服务端渲染 ssr</li></ul><h4 id="6、你在实际工作中，做过那些-vue-的坑"><a href="#6、你在实际工作中，做过那些-vue-的坑" class="headerlink" title="6、你在实际工作中，做过那些 vue 的坑"></a>6、你在实际工作中，做过那些 vue 的坑</h4><ul><li>内存泄漏<ul><li>全局变量、全局事件、全局定时器、自定义时间没有销毁导致内存泄漏</li></ul></li><li>Vue2<ul><li>data 新增要使用 vue.set</li><li>data 删除的时候要用 vue.delete</li><li>无法直接修改数据，arr[index] &#x3D; value</li></ul></li><li>路由切换到 scroll 到顶部<ul><li>spa 的通病</li><li>如列表页，滚到第二屏幕，点击进入详情页</li><li>在返回到列表也就 scroll 到顶部<ul><li>在列表缓存到 scroll 位置和数据，返回时候直接滚动到原来的位置</li><li>MPA+app webview</li></ul></li></ul></li></ul><h4 id="7、如何统一监听-vue-的报错？"><a href="#7、如何统一监听-vue-的报错？" class="headerlink" title="7、如何统一监听 vue 的报错？"></a>7、如何统一监听 vue 的报错？</h4><ul><li><p>window.onerror</p><ul><li><p>全局监听所有 js 错误</p></li><li><p>但他是 js 级别的，识别不了 vue 组件信息</p></li><li><p>捕捉一些 vue 监听不到的错误</p></li></ul></li><li><p>errorCaptured 生命周期</p><ul><li>监听所有下级组件的报错信息</li><li>返回 false 不会想下级捕获</li></ul></li><li><p>erroHandler</p><ul><li>app.config.errorHandler &#x3D; ( error,vm,info)</li></ul></li></ul><h4 id="8、h5-很慢，你改如何排查新能问题"><a href="#8、h5-很慢，你改如何排查新能问题" class="headerlink" title="8、h5 很慢，你改如何排查新能问题"></a>8、h5 很慢，你改如何排查新能问题</h4><ul><li><p>前端性能指标(performance)</p><ul><li><p>first paint （FP）（第一次渲染）</p></li><li><p>First contentful paint（FCP）（第一次有内容的渲染）</p></li><li><p>first meaningful paint (已弃用，第一次有意义的渲染)</p></li><li><p>DomContentLoaded（DCL）</p></li><li><p>largest Contentful paint （LCP）</p></li><li><p>Load （L）</p></li></ul></li><li><p>Lighthouse</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">npm i lighthouse -g<br>lighthouse http:<span class="hljs-string">//www.baidu.com</span> <span class="hljs-params">--view</span> <span class="hljs-params">--presst</span><br></code></pre></td></tr></table></figure></li><li><p>分析是网页加载慢还是渲染慢</p><ul><li>网页加载慢<ul><li>优化服务器硬件配置，使用 cdn</li><li>路由懒加载，大组建异步加载-减少主包的体积</li><li>优化 http 缓存策略</li></ul></li><li>如果渲染慢<ul><li>优化服务端接口（如 Ajax 获取数据慢）</li><li>继续分析，优化前端组件内部的逻辑（参考 Vue React 优化）</li><li>服务端渲染 SSR</li></ul></li></ul></li></ul><h4 id="9、准备一个开发遇到的问题"><a href="#9、准备一个开发遇到的问题" class="headerlink" title="9、准备一个开发遇到的问题"></a>9、准备一个开发遇到的问题</h4><p>。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提升 - 深度知识</title>
    <link href="/2022/08/13/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/08/13/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="1、垃圾回收-GC"><a href="#1、垃圾回收-GC" class="headerlink" title="1、垃圾回收 GC"></a>1、垃圾回收 GC</h4><ul><li><p>什么是垃圾回收机制</p><ul><li>在函数被执行完了，再也用不到的数据或者变量，算法会清除</li></ul></li><li><p>垃圾回收机制的算法</p><ul><li>计数方式（之前）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> a = &#123;x:<span class="hljs-number">100</span>&#125;<br><span class="hljs-keyword">let</span> a1 = a;<br>a = <span class="hljs-number">10</span>;<br>a1 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//此时&#123;x:100&#125;没有变量指向了，那么标记指向的数为0，那么就被清楚</span><br>但是有个问题<br><br><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123;&#125;<br>obj1.a = obj2;<br>obj2.a = obj1;<br>进行了循环引用，这样计数方式就没有用了<br></code></pre></td></tr></table></figure><ul><li>标记清除（现代）</li></ul></li></ul><h4 id="2、单线程和异步"><a href="#2、单线程和异步" class="headerlink" title="2、单线程和异步"></a>2、单线程和异步</h4><ul><li><p>单线程知识点</p><ul><li><p>js 是单线程</p></li><li><p>浏览器中 js 执行和 dom 渲染共用一个线程</p></li><li><p>异步</p><ul><li><p>宏任务（setTimeout、serInterval）</p></li><li><p>微任务（promise、async&#x2F;await）</p></li><li><p>微任务在下一轮 DOM 渲染之前执行，宏任务再之后执行（简单的说就是先执行 js 上下文，再执行微任务，渲染 dom，最后是宏任务）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)     <span class="hljs-comment">//1</span><br>const <span class="hljs-selector-tag">p</span> = document<span class="hljs-selector-class">.createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.innerHTML</span> =<span class="hljs-string">&#x27;12312&#x27;</span><br>document<span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.appendChild</span>(p)   <span class="hljs-comment">//4</span><br><br><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">(()</span></span>=&gt;&#123;<br> console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>) <span class="hljs-comment">//5</span><br> <span class="hljs-built_in">alert</span>(<span class="hljs-string">&#x27;宏任务 setTimeout&#x27;</span>)<br>&#125;)<br>Promise<span class="hljs-selector-class">.resolve</span>()<span class="hljs-selector-class">.then</span>(()=&gt;&#123;<br> console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;promise&#x27;</span>)  <span class="hljs-comment">//3</span><br> <span class="hljs-built_in">alert</span>(<span class="hljs-string">&#x27;微任务 promise&#x27;</span>)<span class="hljs-comment">//3</span><br>&#125;)<br><br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;end&#x27;</span>)   <span class="hljs-comment">//2</span><br><br><br><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>事件循环 EventLoop（浏览器）</p><p>![image-20220706224829526](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220706224829526.png)</p></li></ul><p>​ <strong>先执行同步操作，遇到微任务，先放在微任务队列，遇到宏任务，放在宏任务队列，此时执行完同步操作，先执行微任务（队列先进先出），微任务执行完毕后，渲染 dom，再执行宏任务队列，都执行完毕后，Event Loop 将会继续监听</strong></p><h4 id="3、虚拟-dom-真的很快嘛？"><a href="#3、虚拟-dom-真的很快嘛？" class="headerlink" title="3、虚拟 dom 真的很快嘛？"></a>3、虚拟 dom 真的很快嘛？</h4><ul><li>vdome 并不快，js 直接操作 Dom 更块</li><li>但是数据驱动视图要有更合适的技术方案，不能全部 DOM 重建</li><li>Vdom 就是目前最合适的技术方案（并不是他快，而是合适）</li></ul><h4 id="4、遍历数组，for-和-forEach-那个更快？"><a href="#4、遍历数组，for-和-forEach-那个更快？" class="headerlink" title="4、遍历数组，for 和 forEach 那个更快？"></a>4、遍历数组，for 和 forEach 那个更快？</h4><ul><li>for 更快</li><li>forEach 每次都要创建一个函数来调用，而 for 不会创建函数</li><li>总结：越低级的代码，性能往往越好</li></ul><h4 id="5、请描述-JSBridge-？什么是-JS-Bridge？"><a href="#5、请描述-JSBridge-？什么是-JS-Bridge？" class="headerlink" title="5、请描述 JSBridge ？什么是 JS Bridge？"></a>5、请描述 JSBridge ？什么是 JS Bridge？</h4><ul><li><p>url schema</p></li><li><p>JS 无法调用 native ApI</p></li><li><p>需要通过一些特定的格式来调用</p></li><li><p>这些格式统称 JS -Bridge 例如微信 sdk</p></li></ul><h4 id="6、requestAnimationFrame-和-requestIdleCallback-的区别"><a href="#6、requestAnimationFrame-和-requestIdleCallback-的区别" class="headerlink" title="6、requestAnimationFrame 和 requestIdleCallback 的区别"></a>6、requestAnimationFrame 和 requestIdleCallback 的区别</h4><ul><li>requestAnimationFrame 是高优的</li><li>requestIdleCallback 是低优的</li><li>都属于宏任务，因为都是在 dom 渲染完毕后执行，但是高优的先执行，低优的后执行</li></ul><h4 id="7、vue-的生命周期做了什么"><a href="#7、vue-的生命周期做了什么" class="headerlink" title="7、vue 的生命周期做了什么"></a>7、vue 的生命周期做了什么</h4><ul><li>beforeCreate<ul><li>创建了一个空白的 VUE 实例</li><li>Data 和 metho 尚未被初始化，不可使用</li></ul></li><li>created<ul><li>vue 的实例被创建完了，完成了响应式的绑定</li><li>data method 都已经初始化完成，可调用</li><li>尚未开始渲染模版</li></ul></li><li>beforeMount<ul><li>编译模版，调用 reder 生成 vdom</li><li>还没有开始渲染 dom</li></ul></li><li>mounted<ul><li>完成 Dom</li><li>组件创建完成</li><li>开始由创建阶段进入运行阶段</li></ul></li><li>updated<ul><li>data 发生变化，且 dom 更新完成</li><li>（不要再 update 中修改 data，会造成死循环）</li></ul></li><li>beforeUnmont<ul><li>组件进入销毁阶段</li><li>可以出、解绑一些全局事件、自定义事件</li></ul></li><li>unmounted<ul><li>组件被销毁了</li><li>所有自组建也被销毁了</li></ul></li><li>Keep-alive 的 actived 和 deactiveed<ul><li>缓存组件被激活</li></ul></li></ul><h4 id="8、Vue-什么时候操作-dom-比较合适"><a href="#8、Vue-什么时候操作-dom-比较合适" class="headerlink" title="8、Vue 什么时候操作 dom 比较合适"></a>8、Vue 什么时候操作 dom 比较合适</h4><ul><li>mounted 和 updated 都不能保证自组建全部挂在完成</li><li>要放在$nextTick 下执行</li></ul><h4 id="9、ajax-放在那个生命周期那个比较合适"><a href="#9、ajax-放在那个生命周期那个比较合适" class="headerlink" title="9、ajax 放在那个生命周期那个比较合适"></a>9、ajax 放在那个生命周期那个比较合适</h4><ul><li>created 和 mounted 都可以</li><li>推荐 mounted</li></ul><h4 id="10、vue3-的-composition-API-生命周期有何区别"><a href="#10、vue3-的-composition-API-生命周期有何区别" class="headerlink" title="10、vue3 的 composition API 生命周期有何区别"></a>10、vue3 的 composition API 生命周期有何区别</h4><ul><li>用 setup 代替了 beforeCreated 和 created</li><li>使用 hooks 的形式</li></ul><h4 id="11、vue2vue3-react-三者-diff-算法有何区别？"><a href="#11、vue2vue3-react-三者-diff-算法有何区别？" class="headerlink" title="11、vue2vue3 react 三者 diff 算法有何区别？"></a>11、vue2vue3 react 三者 diff 算法有何区别？</h4><ul><li></li></ul><h4 id="12、vue-router-memoryHistory-V4-之前叫做-abstract-history"><a href="#12、vue-router-memoryHistory-V4-之前叫做-abstract-history" class="headerlink" title="12、vue-router memoryHistory V4 之前叫做 abstract history"></a>12、vue-router memoryHistory V4 之前叫做 abstract history</h4><ul><li>Hash 使用 createHash</li><li>webHistory 使用 createWebHistory</li><li>MemoryHistory 使用 createMemoryHistory</li></ul>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提升 - 知识广度</title>
    <link href="/2022/08/13/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%9F%A5%E8%AF%86%E5%B9%BF%E5%BA%A6/"/>
    <url>/2022/08/13/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%9F%A5%E8%AF%86%E5%B9%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="1、网络请求中，token-和-cookie-有什么区别"><a href="#1、网络请求中，token-和-cookie-有什么区别" class="headerlink" title="1、网络请求中，token 和 cookie 有什么区别"></a>1、网络请求中，token 和 cookie 有什么区别</h4><ul><li><p>cookie</p><ul><li><p>HTTP 无状态，每次请求都要带 token，已帮助识别身份</p></li><li><p>服务端也可以像客户端 set-cookie,cookie 大小限制 4kb</p></li><li><p>默认有跨域限制：不可以跨域共享、传递 cookie</p></li><li><p>html5 之前长被用于存储</p></li><li><p>现代浏览器开始禁止第三方 cookie</p></li></ul></li><li><p>session</p></li></ul><p>![image-20220710153630513](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220710153630513.png)</p><ul><li>token<ul><li>cookie 是 Http 规范，二 token 是自定义传递</li><li>cookie 会默认被浏览器存储，而 token 徐自己存储</li><li>token 默认没有跨域限制</li></ul></li><li>答案<ul><li>cookieHttp 标准，跨域限制，配合 session 使用</li><li>token 无标准，无跨域限制，使用 JWT</li></ul></li></ul><h4 id="2、session-和-jwt-那个更好"><a href="#2、session-和-jwt-那个更好" class="headerlink" title="2、session 和 jwt 那个更好"></a>2、session 和 jwt 那个更好</h4><ul><li>session<ul><li>优点<ul><li>易于学习</li><li>用户信息存储再服务端的，可快速封禁某个用户</li></ul></li><li>缺点<ul><li>占用服务内存，硬件成本过高</li><li>多进程，多服务器时，不好同步-需使用第三方缓存，如 redis</li><li>默认有跨域限制</li></ul></li></ul></li><li>jwt<ul><li>优点<ul><li>不占用服务端内存</li><li>多进程，多服务器不收影响</li></ul></li><li>缺点<ul><li>用户信息存储在客户端，无法快速封禁某某用户</li><li>万一服务端密钥被泄漏，贼用户信息全部丢失</li><li>token 体积一般会大于 cookie，会增加请求的数据量</li></ul></li></ul></li><li>答案：<ul><li>如果又严格管理用户信息的需求，推荐 session</li><li>如果没有特殊要求，则使用 jwt</li></ul></li></ul><h4 id="3、移动端-H5-click-事件的-300ms-延迟"><a href="#3、移动端-H5-click-事件的-300ms-延迟" class="headerlink" title="3、移动端 H5 click 事件的 300ms 延迟"></a>3、移动端 H5 click 事件的 300ms 延迟</h4><ul><li><p>起因：满足 double tap to zoom</p></li><li><p>fastClick 原理</p><ul><li>监听 touchEnd 事件 ，touchStart touchEnd 优于 ckick 触发</li><li>使用自定义 dom 事件，模拟一个 click 事件</li><li>把默认的 click 事件禁止掉</li></ul></li><li><p>现在浏览器的优化，只要浏览器有 width&#x3D;device-width 后就不会存在这个问题</p></li></ul><h4 id="4、UDP-协和和-Http-协议"><a href="#4、UDP-协和和-Http-协议" class="headerlink" title="4、UDP 协和和 Http 协议"></a>4、UDP 协和和 Http 协议</h4><ul><li>http 在应用层</li><li>tcp、udp 是在传输层</li><li>tcp 的特点<ul><li>3 次握手</li><li>4 次挥手</li><li>稳定传输</li></ul></li><li>udp 的特点<ul><li>无连接</li><li>无断开</li><li>不稳定传输，但传输效率高</li><li>如视屏会议，语音通话</li></ul></li></ul><h4 id="5、Http-协议-1-0-和-1-1、2-0-的区别"><a href="#5、Http-协议-1-0-和-1-1、2-0-的区别" class="headerlink" title="5、Http 协议 1.0 和 1.1、2.0 的区别"></a>5、Http 协议 1.0 和 1.1、2.0 的区别</h4><ul><li>1.0<ul><li>最基础的 http 协议</li><li>只支持 get、和 post</li></ul></li><li>1.1<ul><li>缓存策略</li><li>支持长连接，一次 tcp 请求链接多次请求</li><li>断点续传、状态 206</li><li>支持 put delete 等</li></ul></li><li>2.0<ul><li>压缩 header ，减少体积</li><li>多路复用，一次 tcp 链接可以多个 http 并行请求</li></ul></li></ul><h4 id="6、什么事-Https-中间人攻击？如何预防"><a href="#6、什么事-Https-中间人攻击？如何预防" class="headerlink" title="6、什么事 Https 中间人攻击？如何预防"></a>6、什么事 Https 中间人攻击？如何预防</h4><ul><li>http 是明文传输</li><li>https 流程</li></ul><p>![image-20220710212125392](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220710212125392.png)</p><h4 id="7、script-的-defer-和-async-有什么区别"><a href="#7、script-的-defer-和-async-有什么区别" class="headerlink" title="7、script 的 defer 和 async 有什么区别"></a>7、script 的 defer 和 async 有什么区别</h4><ul><li>正常<ul><li>先渲染，遇到了 js，先加载在运行，最后在接着渲染<ul><li>js 放在头部：第一种情况就是刚刚说的，先渲染后加载执行，最后接着渲染</li><li>js 放在尾部，直接渲染完毕后在加载执行</li></ul></li></ul></li><li>defer 延迟<ul><li>渲染和加载 js 同步执行，最后在执行 js</li></ul></li><li>async 异步<ul><li>渲染和加载 js 同步执行，再阻断渲染，执行 js，最后恢复渲染</li></ul></li><li>绿色是渲染，蓝色是加载，红色是执行</li><li>![image-20220711104033398](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220711104033398.png)</li></ul><h4 id="8、preload-和-prefetch"><a href="#8、preload-和-prefetch" class="headerlink" title="8、preload 和 prefetch"></a>8、preload 和 prefetch</h4><ul><li><p>链接的是不同的地址只是方式不一样</p></li><li><p>Preload 资源在当前页面使用，会优先加载</p></li><li><p>prefetch 资源在未来页面使用，会空闲事现在</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">link</span> rel=<span class="hljs-string">&quot;preload&quot;</span> href<span class="hljs-params">...</span>. /&gt;<br>&lt;<span class="hljs-keyword">link</span> rel=<span class="hljs-string">&quot;prefetch&quot;</span> href<span class="hljs-params">...</span>. /&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="9、dns-prefetch-和-preconnect"><a href="#9、dns-prefetch-和-preconnect" class="headerlink" title="9、dns-prefetch 和 preconnect"></a>9、dns-prefetch 和 preconnect</h4><ul><li><p>链接的是同一个地址</p></li><li><p>dns-prefetch 预查询</p></li><li><p>Preconnect 预链接</p></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;link rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;dns-prefetch&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://fonts.com&quot;</span> /&gt;<br>&lt;link rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;preconnect&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://fonts.com&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="10、你知道那些前端攻击？该如何预防？"><a href="#10、你知道那些前端攻击？该如何预防？" class="headerlink" title="10、你知道那些前端攻击？该如何预防？"></a>10、你知道那些前端攻击？该如何预防？</h4><ul><li>XSS<ul><li>Cross site script 跨站脚本攻击</li><li>手段：黑客蒋 js 代码插入到网页页面中，渲染事执行 js 代码</li><li>预防：特殊字符替换</li></ul></li><li>Csrf<ul><li>Cross site request Forgery 跨域请求伪造</li><li>手段：黑客诱导用户去访问另一个网站的接口，伪造请求</li><li>预防：严格控制跨域+验证码机制</li></ul></li><li>点击劫持<ul><li>click jacking</li><li>手段：诱导界面上蒙一个透明的 ifream，诱导用户点击</li><li>预防：严格控制跨域</li></ul></li><li>DDos<ul><li>Distribute denial-of-seervice 分布式拒绝服务</li><li>手段：分布式的、大规模的流量访问，是服务器瘫痪</li><li>预防：软件层面不能做，需要硬件防御（如阿里的 WAF）</li></ul></li><li>SQL 注入<ul><li>手段：黑客提交 SQl 语句，破坏数据库</li><li>预防：处理输入内容，替换特殊字符</li></ul></li></ul><h4 id="11、描述从输入-Url-到页面展示的完整过程"><a href="#11、描述从输入-Url-到页面展示的完整过程" class="headerlink" title="11、描述从输入 Url 到页面展示的完整过程"></a>11、描述从输入 Url 到页面展示的完整过程</h4><ul><li>网络请求<ul><li>DNS 查询，建立 TCP 链接</li><li>浏览器发送 Http 请求</li><li>收到请求响应，得到 HTML 源码</li></ul></li><li>解析<ul><li>Html 构建 dom 树</li><li>css 构建 cssom 数</li><li>两者结合，行程 render tree</li></ul></li><li>渲染<ul><li>计算 dom 尺寸，定位，最后渲染到页面‘</li><li>遇到 js 可能会执行</li><li>异步 css，图片可能重复渲染</li></ul></li><li>答案：<ul><li>网路请求：dns 解析，http 请求</li><li>解析：dom 树，cssom 树，rendertree 生成</li><li>渲染：计算绘制，同事执行 js</li></ul></li></ul><h4 id="12、重绘、和重排"><a href="#12、重绘、和重排" class="headerlink" title="12、重绘、和重排"></a>12、重绘、和重排</h4><ul><li>重绘 repaint<ul><li>元素外观改变，如颜色、背景色</li><li>但元素的尺寸、定位不变、不会影响到其他元素的位置</li></ul></li><li>重排 reflow<ul><li>重新计算尺寸和布局，可能会影响其他元素的位置</li><li>如元素的高度增加，可能会使相邻的元素位置下移</li></ul></li><li>区别：重排比重绘更消耗资源</li><li>减少重排的方法<ul><li>集中修改样式，或直接切换 css class</li><li>修改之前先设置 display:none,脱离文档流</li><li>使用 BFC 特性，不影响其他元素位置</li><li>频繁出发使用防抖节流</li><li>使用 createDocumentFragment 批量操作 dom</li><li>优化动画，使用 css 和 requestAnimationFrame</li></ul></li></ul><h4 id="13、BFC"><a href="#13、BFC" class="headerlink" title="13、BFC"></a>13、BFC</h4><ul><li>块级格式化上下文</li><li>内部元素无论如何改动，都不会影响其他元素的位置</li><li>触发条件<ul><li>根节点<html></li><li>Float: left&#x2F;right</li><li>Overflow:auto&#x2F;scroll&#x2F;hidden</li><li>Display:inline-block&#x2F;flex&#x2F;table&#x2F;table-cell</li><li>Position:absolute;fixed</li></ul></li></ul><h4 id="14、如何实现网页多标签通讯？（a-页面列表点到-b-详情中，b-页面修改值后通知-a-页面去修改状态，而不是刷新页面）"><a href="#14、如何实现网页多标签通讯？（a-页面列表点到-b-详情中，b-页面修改值后通知-a-页面去修改状态，而不是刷新页面）" class="headerlink" title="14、如何实现网页多标签通讯？（a 页面列表点到 b 详情中，b 页面修改值后通知 a 页面去修改状态，而不是刷新页面）"></a>14、如何实现网页多标签通讯？（a 页面列表点到 b 详情中，b 页面修改值后通知 a 页面去修改状态，而不是刷新页面）</h4><ul><li><p>使用 websocket</p><ul><li>需要服务端提供支持，成本高</li><li>可以跨域</li></ul></li><li><p>通过 localstorage 通讯</p><ul><li><p>同域、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;storage&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>通过 sharedWord 通讯</p><ul><li>sharedWorker 是 webwork 的一种</li><li>webWorker 可以开启子进程，但不能操作 dom</li><li>sharedWorker 可单独开启一个进程，用于同域页面通讯</li></ul></li></ul><h4 id="15、网页和-ifream-直接的通讯"><a href="#15、网页和-ifream-直接的通讯" class="headerlink" title="15、网页和 ifream 直接的通讯"></a>15、网页和 ifream 直接的通讯</h4><ul><li>使用 postMessage 通讯</li><li>注意跨域的限制和判断</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">window</span>.ifream1.content.postMessage(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br><span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>,function(<span class="hljs-keyword">event</span>)&#123;<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">event</span>.origin) <span class="hljs-comment">//来源</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">event</span>.data) <span class="hljs-comment">//数据</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提升 - 基础知识</title>
    <link href="/2022/08/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Ajax、fetch、Axios-的区别？"><a href="#1、Ajax、fetch、Axios-的区别？" class="headerlink" title="1、Ajax、fetch、Axios 的区别？"></a>1、Ajax、fetch、Axios 的区别？</h4><ul><li><p>ajax 是一种技术统称，最原生的 api 是 XMLHttpRequest</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">featch</span>(<span class="hljs-params">methods: <span class="hljs-built_in">string</span>, URL: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve: (arg0: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span>, reject: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">xhr</span>: <span class="hljs-title class_">XMLHttpRequest</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        xhr.<span class="hljs-title function_">open</span>(methods, <span class="hljs-variable constant_">URL</span>, <span class="hljs-literal">false</span>);<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>        xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Fetch 是一个具体的 api</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(url: RequestInfo | URL) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">fetch(url).then(res</span> =&gt; res.json());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Axios 是第三方的一个库</p></li></ul><h4 id="2、节流和防抖"><a href="#2、节流和防抖" class="headerlink" title="2、节流和防抖"></a>2、节流和防抖</h4><p>节流 throotle：限制执行频率，有节奏的执行 （一般用于拖拽，滚动）</p><p>防抖 debounce：闲置执行次数，多次密集的触发只执行一次（一般用于输入框）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay=<span class="hljs-number">200</span></span>)&#123;<br>                <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-keyword">if</span>(time)&#123;<br>                        <span class="hljs-built_in">clearTimeout</span>(time);<br>                    &#125;<br>                    time = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn)<br>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>);<br>                    &#125;,delay);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay=<span class="hljs-number">200</span></span>)&#123;<br>                <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-keyword">if</span>(time)&#123;<br>                       <span class="hljs-keyword">return</span><br>                    &#125;<br>                    time = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>);<br>                        time = <span class="hljs-number">0</span>;<br>                    &#125;,delay);<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h4 id="3、px、-、vh、rem、em"><a href="#3、px、-、vh、rem、em" class="headerlink" title="3、px、%、vh、rem、em"></a>3、px、%、vh、rem、em</h4><ul><li>px 绝对像素</li><li>rem 更元素的 rem</li><li>Vmin vmax 取最大值</li></ul><h4 id="4、箭头函数特点"><a href="#4、箭头函数特点" class="headerlink" title="4、箭头函数特点"></a>4、箭头函数特点</h4><ul><li>没有 arguments</li><li>无法通过 apply、call 来改变 this 的指向</li><li>无法通过 new 来实例化函数</li><li>this 永远指向</li></ul><p>​ 特例：在 class 中就可以</p><p>​</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>getName:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> this.name<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、请描述-Tcp-三次握手和四次挥手"><a href="#5、请描述-Tcp-三次握手和四次挥手" class="headerlink" title="5、请描述 Tcp 三次握手和四次挥手"></a>5、请描述 Tcp 三次握手和四次挥手</h4><ul><li>先建立链接（确保双方都有首发消息的能力）</li><li>在传输内容（发一个 get 请求）</li><li>网络链接是 TCP 链接，传输协议是 HTTP 协议</li><li>三次握手分别是（发起链接）<ul><li>clinet 发包请求建立链接， server 接包 server：有 clint 要找我， （在不在啊？）</li><li>server 发包 ，client 节包 ，clinet：server 已经收到信息了（在的，我在）</li><li>Cllient 发送，server 接包 ，server：client 要准备发送了（我准备发送快递去你家了）</li></ul></li><li>四次挥手（断开链接）<ul><li>clinet 发包，server 接包 ，server: clinet 已请求结束</li><li>server 发包，clinet 接包 ,clinet :server 已收到，我等待他关闭</li><li>server 发包，clinet 接包，clinet : server 此时可以关闭链接了</li><li>client 发包，server 接包，server：可以关闭了</li></ul></li></ul><p>![image-20220703154853522](&#x2F;Users&#x2F;fanrongkong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220703154853522.png)</p><h4 id="6、for…of-和-for…in-的区别"><a href="#6、for…of-和-for…in-的区别" class="headerlink" title="6、for…of 和 for…in 的区别"></a>6、for…of 和 for…in 的区别</h4><ul><li>for in 用于可枚举的数据，比如对象、数组、字符串，得到 key，就是有 Object.getOwnPropertyDescriptors 中有 enumerable:true 的</li><li>for…of 用于可迭代数据，比如数组、字符串、Map、Set,得到 value，就是部署了 Symbol.iterator 接口的</li></ul><h4 id="7、for-await…-of-的用处"><a href="#7、for-await…-of-的用处" class="headerlink" title="7、for await…..of 的用处"></a>7、for await…..of 的用处</h4><p>用于遍历多个 promise，类似 promise.all</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pro</span>(<span class="hljs-params">a</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">reslove</span>=&gt;</span>&#123;<br>               <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                   <span class="hljs-title function_">reslove</span>(a)<br>               &#125;,<span class="hljs-number">1000</span>)<br>           &#125;)<br>       &#125;<br><br>       (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">let</span> p1 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">100</span>);<br>           <span class="hljs-comment">// console.log(p1)</span><br>           <span class="hljs-keyword">let</span> p2 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">200</span>);<br>           <span class="hljs-comment">// console.log(p2)</span><br>           <span class="hljs-keyword">let</span> p3 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">300</span>);<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3)<br>           <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span>  (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> [p1,p2,p3])&#123;<br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)<br>           &#125;<br>       &#125;)()<br></code></pre></td></tr></table></figure><p>扩展，这个时候是同时执行，相当于并发，但是如果要一个一个的去实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pro</span>(<span class="hljs-params">a</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">reslove</span>=&gt;</span>&#123;<br>               <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                   <span class="hljs-title function_">reslove</span>(a)<br>               &#125;,<span class="hljs-number">1000</span>)<br>           &#125;)<br>       &#125;<br><br>       (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">let</span> p1 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">100</span>);<br>           <span class="hljs-comment">// console.log(p1)</span><br>           <span class="hljs-keyword">let</span> p2 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">200</span>);<br>           <span class="hljs-comment">// console.log(p2)</span><br>           <span class="hljs-keyword">let</span> p3 =  <span class="hljs-title function_">pro</span>(<span class="hljs-number">300</span>);<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3)<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>])&#123;<br>              <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pro</span>(val);<br>           &#125;<br>       &#125;)()<br></code></pre></td></tr></table></figure><h4 id="8、offsetHeight"><a href="#8、offsetHeight" class="headerlink" title="8、offsetHeight"></a>8、offsetHeight</h4><ul><li>offsetHeight &#x3D; border+padding + content</li><li>ClientHeight &#x3D; padding + content</li><li>scrollHeight &#x3D; padding + 实际内容尺寸</li></ul><h4 id="9、vue-的-watch-和-computed-区别"><a href="#9、vue-的-watch-和-computed-区别" class="headerlink" title="9、vue 的 watch 和 computed 区别"></a>9、vue 的 watch 和 computed 区别</h4><ul><li>watch 是查看数据的变化，二 computed 是通过某个值去生成一个新的值，所监听的值会有变化，计算的值就会跟这变化</li><li>computed 用于计算产出新的数据，有缓存，使用 method 当作 computed 来用，methods 是没有缓存的，</li></ul><h4 id="10、-attrs和-listeners（试试）"><a href="#10、-attrs和-listeners（试试）" class="headerlink" title="10、$attrs和$listeners（试试）"></a>10、$attrs和$listeners（试试）</h4><ul><li>$attrs是获取父级所有的属性，在vue3的时候代理了$listeners 方法</li><li>$listeners 是获取父级所有的事件，在 vue3 的时候移除了改属性</li></ul><h4 id="11、event-bus-总线"><a href="#11、event-bus-总线" class="headerlink" title="11、event bus 总线"></a>11、event bus 总线</h4><ul><li>Vue2 的话直接 new vue 就可以了</li><li>vue3 的话用第三方库，event-emitter</li></ul><h4 id="12、-parent"><a href="#12、-parent" class="headerlink" title="12、$parent"></a>12、$parent</h4><ul><li>可以获取父级的组件</li></ul><h4 id="13、provide-、inject"><a href="#13、provide-、inject" class="headerlink" title="13、provide 、inject"></a>13、provide 、inject</h4><ul><li><p>静态数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">provide:&#123;<br>inf:<span class="hljs-string">&#x27;aaa&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>动态数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">info</span>:<span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="14、vuex-的-mutation-和-action-的区别"><a href="#14、vuex-的-mutation-和-action-的区别" class="headerlink" title="14、vuex 的 mutation 和 action 的区别"></a>14、vuex 的 mutation 和 action 的区别</h4><ul><li>mutation 是原子操作，必须是同步代码</li><li>action 可以包含多个 mutation，可以包含异步代码</li></ul><h4 id="15、JS-严格模式的有什么特点"><a href="#15、JS-严格模式的有什么特点" class="headerlink" title="15、JS 严格模式的有什么特点"></a>15、JS 严格模式的有什么特点</h4><ul><li><p>全局变量必须先申明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br>n = <span class="hljs-number">1</span>；非严格可以，严格不可以<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>禁止使用 with</p></li><li><p>创建 eval 作用域,eval 有单独的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var x = 20;console.log(x)&#x27;</span>) <span class="hljs-comment">//20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure></li><li><p>禁止 this 指向 window</p></li><li><p>函数参数不能重名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x,x,t</span>)&#123; <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="16、Http-跨域请求时为何发送-options-请求"><a href="#16、Http-跨域请求时为何发送-options-请求" class="headerlink" title="16、Http 跨域请求时为何发送 options 请求"></a>16、Http 跨域请求时为何发送 options 请求</h4><ul><li>跨域是因为浏览器的同源策略限制导致的，一般限制 Ajax 请求</li><li>不会限制<Link> 、<img>、<script>、<ifream> 加载第三方资源</li><li>解决跨域方法：<ul><li>JSONP：通过 script 请求接口![image-20220704222235967](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20220704222235967.png)</li><li>服务端设置</li></ul></li><li>答案：<ul><li>options 请求是跨域请求之前的预检查（检查是 get、post、delete.....）</li><li>浏览器自行发起的，无需我们干预</li><li>不会影响实际的功能</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
