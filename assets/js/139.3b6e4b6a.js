(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{421:function(_,v,t){"use strict";t.r(v);var e=t(14),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"_1-浏览器是如何渲染页面的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器是如何渲染页面的"}},[_._v("#")]),_._v(" 1.浏览器是如何渲染页面的？")]),_._v(" "),v("p",[_._v("当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。")]),_._v(" "),v("p",[_._v("在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程.")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画")]),_._v(" "),v("p",[_._v("每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。")]),_._v(" "),v("p",[_._v("这样，整个渲染流程就形成了一套组织严密的生产流水线。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("渲染的第一步是"),v("strong",[_._v("解析 HTML")]),_._v("。")]),_._v(" "),v("p",[_._v("解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。")]),_._v(" "),v("p",[_._v("如果主线程解析到"),v("code",[_._v("link")]),_._v("位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。")]),_._v(" "),v("p",[_._v("如果主线程解析到"),v("code",[_._v("script")]),_._v("位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。")]),_._v(" "),v("p",[_._v("第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("渲染的下一步是"),v("strong",[_._v("样式计算")]),_._v("。")]),_._v(" "),v("p",[_._v("主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。")]),_._v(" "),v("p",[_._v("在这一过程中，很多预设值会变成绝对值，比如"),v("code",[_._v("red")]),_._v("会变成"),v("code",[_._v("rgb(255,0,0)")]),_._v("；相对单位会变成绝对单位，比如"),v("code",[_._v("em")]),_._v("会变成"),v("code",[_._v("px")])]),_._v(" "),v("p",[_._v("这一步完成后，会得到一棵带有样式的 DOM 树。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("接下来是"),v("strong",[_._v("布局")]),_._v("，布局完成后会得到布局树。")]),_._v(" "),v("p",[_._v("布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。")]),_._v(" "),v("p",[_._v("大部分时候，DOM 树和布局树并非一一对应。")]),_._v(" "),v("p",[_._v("比如"),v("code",[_._v("display:none")]),_._v("的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("下一步是"),v("strong",[_._v("分层")])]),_._v(" "),v("p",[_._v("主线程会使用一套复杂的策略对整个布局树中进行分层。")]),_._v(" "),v("p",[_._v("分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。")]),_._v(" "),v("p",[_._v("滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过"),v("code",[_._v("will-change")]),_._v("属性更大程度的影响分层结果。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("再下一步是"),v("strong",[_._v("绘制")])]),_._v(" "),v("p",[_._v("主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。")]),_._v(" "),v("p",[_._v("合成线程首先对每个图层进行分块，将其划分为更多的小区域。")]),_._v(" "),v("p",[_._v("它会从线程池中拿取多个线程来完成分块工作。")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("分块完成后，进入"),v("strong",[_._v("光栅化")]),_._v("阶段。")]),_._v(" "),v("p",[_._v("合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。")]),_._v(" "),v("p",[_._v("GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。")]),_._v(" "),v("p",[_._v("光栅化的结果，就是一块一块的位图")]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("最后一个阶段就是"),v("strong",[_._v("画")]),_._v("了")]),_._v(" "),v("p",[_._v("合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。")]),_._v(" "),v("p",[_._v("指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。")]),_._v(" "),v("p",[_._v("变形发生在合成线程，与渲染主线程无关，这就是"),v("code",[_._v("transform")]),_._v("效率高的本质原因。")]),_._v(" "),v("p",[_._v("合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。")]),_._v(" "),v("h3",{attrs:{id:"_2-什么是-reflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是-reflow"}},[_._v("#")]),_._v(" 2.什么是 reflow？")]),_._v(" "),v("p",[_._v("reflow 的本质就是重新计算 layout 树。")]),_._v(" "),v("p",[_._v("当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。")]),_._v(" "),v("p",[_._v("为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。")]),_._v(" "),v("p",[_._v("也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。")]),_._v(" "),v("p",[_._v("浏览器在反复权衡下，最终决定获取属性立即 reflow。")]),_._v(" "),v("h3",{attrs:{id:"_3-什么是-repaint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是-repaint"}},[_._v("#")]),_._v(" 3.什么是 repaint？")]),_._v(" "),v("p",[_._v("repaint 的本质就是重新根据分层信息计算了绘制指令。")]),_._v(" "),v("p",[_._v("当改动了可见样式后，就需要重新计算，会引发 repaint。")]),_._v(" "),v("p",[_._v("由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。")]),_._v(" "),v("h3",{attrs:{id:"_4-为什么-transform-的效率高"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么-transform-的效率高"}},[_._v("#")]),_._v(" 4.为什么 transform 的效率高？")]),_._v(" "),v("p",[_._v("因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段")]),_._v(" "),v("p",[_._v("由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。")]),_._v(" "),v("h3",{attrs:{id:"_5-http缓存、协商缓存、强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-http缓存、协商缓存、强缓存"}},[_._v("#")]),_._v(" 5.HTTP缓存、协商缓存、强缓存")]),_._v(" "),v("p",[_._v("在浏览器加载资源的时候，首先会根据请求头的"),v("code",[_._v("expires")]),_._v("和"),v("code",[_._v("cache-control")]),_._v("判断是否命中强缓存策略，判断是否向远程服务器请求资源还是去本地获取缓存资源。")]),_._v(" "),v("p",[_._v("强缓存：")]),_._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"expires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[_._v("#")]),_._v(" Expires")]),_._v(" "),v("p",[_._v("​\t这个是1.0的缓存，在浏览器第一个请求资源时，服务器端的响应头会附上"),v("code",[_._v("Expires")]),_._v("这个响应字段，当浏览器在下一次请求这个资源时会根据上次的"),v("code",[_._v("expires")]),_._v("字段是否使用缓存资源（当请求时间小于服务端返回的到期时间，直接使用缓存数据）")])]),_._v(" "),v("li",[v("h4",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[_._v("#")]),_._v(" Cache-control")]),_._v(" "),v("p",[_._v("有个问题，就是服务端客户端时间对不上有差距，所有加了一个cache-control字段，这个字段优先级高于expires，是相对时间")]),_._v(" "),v("p",[_._v("实例值：max-age\\s-maxage\\private\\public\\no-store\\no-chache")])])]),_._v(" "),v("p",[_._v("协商缓存：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("协商缓存是服务器来确定这个资源是否可用，")]),_._v(" "),v("p",[_._v("来张图：")]),_._v(" "),v("p",[_._v("![image-20230323193921777](/Users/fanrongkong/Library/Application Support/typora-user-images/image-20230323193921777.png)")]),_._v(" "),v("h5",{attrs:{id:"etag-if-none-match"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[_._v("#")]),_._v(" Etag/If-None-Match")]),_._v(" "),v("blockquote",[v("p",[_._v("Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。")]),_._v(" "),v("p",[_._v("当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304")])]),_._v(" "),v("h5",{attrs:{id:"last-modifed-if-modified-since"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#last-modifed-if-modified-since"}},[_._v("#")]),_._v(" Last-Modifed/If-Modified-Since")]),_._v(" "),v("blockquote",[v("p",[_._v("Last-Modifed 浏览器向服务器发送资源最后的修改时间")]),_._v(" "),v("p",[_._v("当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。")])]),_._v(" "),v("h3",{attrs:{id:"_6-get和post请求区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-get和post请求区别"}},[_._v("#")]),_._v(" 6.get和post请求区别")]),_._v(" "),v("p",[_._v("1.url 体现区别，get请求能在URL上体现，post不可以。")]),_._v(" "),v("p",[_._v("2.长度限制，get请求有长度限制，但并非HTTP协议的限制，是浏览器和web服务器的限制，因此不同浏览器和web服务器限制成都不一样。")]),_._v(" "),v("p",[_._v("3.缓存区别, get请求一般用于查询，可以不用每次都与数据库交互，利用缓存机制，post请求一般用于增删改操作，必须与数据库就行操作，所以不可用于缓存。")]),_._v(" "),v("p",[_._v("其他的请求：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主要方法")]),_._v(" "),v("th",[_._v("功能说明")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("GET")]),_._v(" "),v("td",[_._v("获取资源")])]),_._v(" "),v("tr",[v("td",[_._v("POST")]),_._v(" "),v("td",[_._v("传输实体主体，一般用于向服务器提交数据")])]),_._v(" "),v("tr",[v("td",[_._v("PUT")]),_._v(" "),v("td",[_._v("传输文件")])]),_._v(" "),v("tr",[v("td",[_._v("HEAD")]),_._v(" "),v("td",[_._v("获取报文首部")])]),_._v(" "),v("tr",[v("td",[_._v("DELETE")]),_._v(" "),v("td",[_._v("删除文件")])]),_._v(" "),v("tr",[v("td",[_._v("OPTIONS")]),_._v(" "),v("td",[_._v("询问服务器支持的方法")])]),_._v(" "),v("tr",[v("td",[_._v("TRACE")]),_._v(" "),v("td",[_._v("追踪路径")])]),_._v(" "),v("tr",[v("td",[_._v("CONNECT")]),_._v(" "),v("td",[_._v("要求用隧道协议连接")])])])]),_._v(" "),v("h3",{attrs:{id:"_7-跨域和解决方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-跨域和解决方法"}},[_._v("#")]),_._v(" 7.跨域和解决方法")]),_._v(" "),v("ul",[v("li",[_._v("Jsonp、")]),_._v(" "),v("li",[_._v("webpack 配置proxy,")]),_._v(" "),v("li",[_._v("nginx 反向代理，")]),_._v(" "),v("li",[_._v("Cors: 后端需要在目标服务器http相应头 配置允许跨域： Access-control-Allow-origin: '")])]),_._v(" "),v("h3",{attrs:{id:"_8-模块化发展历程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-模块化发展历程"}},[_._v("#")]),_._v(" 8.模块化发展历程")]),_._v(" "),v("p",[_._v("IIFE：立即执行函数，在一个独立的作用域中执行代码，不会污染全局作用域和避免变量冲突。")]),_._v(" "),v("p",[_._v("AMD： 用requireJS 来编写模块化，特点：依赖必须提前声明。")]),_._v(" "),v("p",[_._v("CMD： 使用seaJS 来编写模块化，特点：支持动态引入依赖文件。")]),_._v(" "),v("p",[_._v("CommonJS: nodeJS 内置的模块化。")]),_._v(" "),v("p",[_._v("ES6的modules： es6引入的模块化。")]),_._v(" "),v("h3",{attrs:{id:"_9-tcp三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-tcp三次握手"}},[_._v("#")]),_._v(" 9.TCP三次握手")]),_._v(" "),v("p",[_._v("第一次：client -> server 服务端知道客户端有发送能力")]),_._v(" "),v("p",[_._v("第二次：server -> client 客户端知道服务端游发送能力")]),_._v(" "),v("p",[_._v("第三次：client -> server 让服务端知道客户端接受能力没问题")]),_._v(" "),v("p",[_._v("其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。")]),_._v(" "),v("h3",{attrs:{id:"_10-为什么-0-1-0-2-不等于-0-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-为什么-0-1-0-2-不等于-0-3"}},[_._v("#")]),_._v(" 10.为什么 0.1 + 0.2 不等于 0.3")])])]),_._v(" "),v("p",[_._v("与许多其他编程语言不同，JavaScript 并未定义不同类型的数字数据类型，而是始终遵循国际 IEEE 754 标准，将数字存储为"),v("code",[_._v("双精度浮点数")]),_._v("。")]),_._v(" "),v("p",[_._v("这种格式以 64 位存储数字，其中"),v("code",[_._v("数字（分数）存储在位 0 到 51 中")]),_._v("，指数存储在位 52 到 62 中，符号存储在位 63 中。")]),_._v(" "),v("p",[_._v("用科学计数法表示二进制 0.1 并只保留前 52 位")]),_._v(" "),v("h3",{attrs:{id:"_11-http-和-https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-http-和-https"}},[_._v("#")]),_._v(" 11. HTTP 和 HTTPS")]),_._v(" "),v("h4",{attrs:{id:"_1-http-和-https-的基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http-和-https-的基本概念"}},[_._v("#")]),_._v(" 1.http 和 https 的基本概念")]),_._v(" "),v("p",[_._v("http:http是服务器与客户端请求的一个应答标准Tcp,用于从www服务器传输超文本到本地浏览器的超文本传输协议")]),_._v(" "),v("p",[_._v("Https：https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。")]),_._v(" "),v("h4",{attrs:{id:"_2-http-和-https-的区别及优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-和-https-的区别及优缺点"}},[_._v("#")]),_._v(" 2.http 和 https 的区别及优缺点？")]),_._v(" "),v("ul",[v("li",[_._v("http:80端口，https:443")]),_._v(" "),v("li",[_._v("Https 需要ca证书，")]),_._v(" "),v("li",[_._v("http是明文传输，https是加密传输】")]),_._v(" "),v("li",[_._v("https需要握手比较费时")]),_._v(" "),v("li",[_._v("https缓存不如http高效")])]),_._v(" "),v("h4",{attrs:{id:"_3-https-协议的工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-https-协议的工作原理"}},[_._v("#")]),_._v(" 3.https 协议的工作原理")]),_._v(" "),v("ul",[v("li",[_._v("客户端使用 https url 访问服务器，则要求 web 服务器"),v("code",[_._v("建立 ssl 链接")]),_._v("。")]),_._v(" "),v("li",[_._v("web 服务器接收到客户端的请求之后，会"),v("code",[_._v("将网站的证书（证书中包含了公钥），传输给客户端")]),_._v("。")]),_._v(" "),v("li",[_._v("客户端和 web 服务器端开始"),v("code",[_._v("协商 SSL 链接的安全等级")]),_._v("，也就是加密等级。")]),_._v(" "),v("li",[_._v("客户端浏览器通过双方协商一致的安全等级，"),v("code",[_._v("建立会话密钥")]),_._v("，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),_._v(" "),v("li",[_._v("web 服务器"),v("code",[_._v("通过自己的私钥解密出会话密钥")]),_._v("。")]),_._v(" "),v("li",[_._v("web 服务器"),v("code",[_._v("通过会话密钥加密与客户端之间的通信")]),_._v("。")])]),_._v(" "),v("h3",{attrs:{id:"_12-tcp和udp的区别tcp是面向链接的-而udp是面向无连接的。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-tcp和udp的区别tcp是面向链接的-而udp是面向无连接的。"}},[_._v("#")]),_._v(" 12.TCP和UDP的区别TCP是面向"),v("code",[_._v("链接")]),_._v("的，而UDP是面向无连接的。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("TCP仅支持"),v("code",[_._v("单播传输")]),_._v("，UDP 提供了单播，多播，广播的功能。")])]),_._v(" "),v("li",[v("p",[_._v("TCP是面向"),v("code",[_._v("链接")]),_._v("的，而UDP是面向无连接的。")])]),_._v(" "),v("li",[v("p",[_._v("TCP的三次握手保证了连接的"),v("code",[_._v("可靠性")]),_._v("; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。")])]),_._v(" "),v("li",[v("p",[_._v("UDP的"),v("code",[_._v("头部开销")]),_._v("比TCP的更小，数据"),v("code",[_._v("传输速率更高")]),_._v("，"),v("code",[_._v("实时性更好")]),_._v("。")])])]),_._v(" "),v("h3",{attrs:{id:"_13-cookie、sessionstorage、localstorage-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-cookie、sessionstorage、localstorage-的区别"}},[_._v("#")]),_._v(" 13.Cookie、sessionStorage、localStorage 的区别")]),_._v(" "),v("p",[v("strong",[_._v("相同点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("存储在客户端")])]),_._v(" "),v("p",[v("strong",[_._v("不同点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+")]),_._v(" "),v("li",[_._v("cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除")]),_._v(" "),v("li",[_._v("cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地")])]),_._v(" "),v("h3",{attrs:{id:"_14-从输入url到页面加载的全过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-从输入url到页面加载的全过程"}},[_._v("#")]),_._v(" 14.从输入URL到页面加载的全过程")]),_._v(" "),v("p",[_._v("1、首先在浏览器中输入URL")]),_._v(" "),v("p",[_._v("2、查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。")]),_._v(" "),v("ul",[v("li",[_._v("浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；")]),_._v(" "),v("li",[_._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；")]),_._v(" "),v("li",[_._v("路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；")]),_._v(" "),v("li",[_._v("ISP缓存：若上述均失败，继续向ISP搜索。")])]),_._v(" "),v("p",[_._v("3、DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。"),v("code",[_._v("DNS服务器是基于UDP的，因此会用到UDP协议")]),_._v("。")]),_._v(" "),v("p",[_._v("4、建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接")]),_._v(" "),v("p",[_._v("5、发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器")]),_._v(" "),v("p",[_._v("6、服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器")]),_._v(" "),v("p",[_._v("7、关闭TCP连接：通过四次挥手释放TCP连接")]),_._v(" "),v("p",[_._v("8、浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：")]),_._v(" "),v("ul",[v("li",[_._v("构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象")]),_._v(" "),v("li",[_._v("构建CSS规则树：生成CSS规则树（CSS Rule Tree）")]),_._v(" "),v("li",[_._v("构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）")]),_._v(" "),v("li",[_._v("布局（Layout）：计算出每个节点在屏幕中的位置")]),_._v(" "),v("li",[_._v("绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。")])]),_._v(" "),v("p",[_._v("9、JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）")]),_._v(" "),v("h3",{attrs:{id:"_15-浏览器重绘与重排的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-浏览器重绘与重排的区别"}},[_._v("#")]),_._v(" 15.浏览器重绘与重排的区别？")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("重排/回流（Reflow）")]),_._v("：当"),v("code",[_._v("DOM")]),_._v("的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。")]),_._v(" "),v("li",[v("code",[_._v("重绘(Repaint)")]),_._v(": 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变")])]),_._v(" "),v("h3",{attrs:{id:"_16-如何触发重排和重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-如何触发重排和重绘"}},[_._v("#")]),_._v(" 16.如何触发重排和重绘？")]),_._v(" "),v("p",[_._v("任何改变用来构建渲染树的信息都会导致一次重排或重绘：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("添加、删除、更新DOM节点")])]),_._v(" "),v("li",[v("p",[_._v("通过display: none隐藏一个DOM节点-触发重排和重绘")])]),_._v(" "),v("li",[v("p",[_._v("通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化")])]),_._v(" "),v("li",[v("p",[_._v("移动或者给页面中的DOM节点添加动画")])]),_._v(" "),v("li",[v("p",[_._v("添加一个样式表，调整样式属性")])]),_._v(" "),v("li",[v("p",[_._v("用户行为，例如调整窗口大小，改变字号，或者滚动。")])])]),_._v(" "),v("h3",{attrs:{id:"_17-如何避免重绘或者重排"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-如何避免重绘或者重排"}},[_._v("#")]),_._v(" 17.如何避免重绘或者重排？")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("集中改变样式")]),_._v("，不要一条一条地修改 DOM 的样式。")]),_._v(" "),v("li",[_._v("不要把 DOM 结点的属性值放在循环里当成循环里的变量。")]),_._v(" "),v("li",[_._v("为动画的 HTML 元件使用 "),v("code",[_._v("fixed")]),_._v(" 或 "),v("code",[_._v("absoult")]),_._v(" 的 "),v("code",[_._v("position")]),_._v("，那么修改他们的 CSS 是不会 reflow 的。")]),_._v(" "),v("li",[_._v("不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。")]),_._v(" "),v("li",[_._v("尽量只修改"),v("code",[_._v("position：absolute")]),_._v("或"),v("code",[_._v("fixed")]),_._v("元素，对其他元素影响不大")]),_._v(" "),v("li",[_._v("动画开始"),v("code",[_._v("GPU")]),_._v("加速，"),v("code",[_._v("translate")]),_._v("使用"),v("code",[_._v("3D")]),_._v("变化")]),_._v(" "),v("li",[_._v("提升为合成层")])]),_._v(" "),v("h3",{attrs:{id:"_18-说说你对-xss-的了解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-说说你对-xss-的了解"}},[_._v("#")]),_._v(" 18.说说你对 XSS 的了解")]),_._v(" "),v("p",[_._v("英文全称是 "),v("code",[_._v("Cross Site Script")]),_._v("，"),v("code",[_._v("XSS")]),_._v("攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于"),v("code",[_._v("DOM XSS")])]),_._v(" "),v("p",[_._v("反射线：通过用户的输入的信息反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功，通常反射型"),v("code",[_._v("XSS")]),_._v("的恶意代码存在"),v("code",[_._v("URL")]),_._v("里，通过"),v("code",[_._v("URL")]),_._v("传递参数的功能，如网站搜索、跳转等")]),_._v(" "),v("p",[_._v("存储型:存储型 "),v("code",[_._v("XSS")]),_._v(" 会把用户输入的数据“存储”在服务器端,比如表单中写入js,当渲染页面执行的时候，遇到script标签就会执行输入的脚本")]),_._v(" "),v("p",[_._v("基于"),v("code",[_._v("DOM XSS")]),_._v("：实际上，这种类型的"),v("code",[_._v("XSS")]),_._v("并非按照“数据是否保存在服务器端”来划分，"),v("code",[_._v("DOM Based XSS")]),_._v("从效果上来说也是反射型"),v("code",[_._v("XSS")]),_._v("。单独划分出来，是因为"),v("code",[_._v("DOM Based XSS")]),_._v(" 的形成原因比较特别，发现它的安全专家专门提出了这种类型的"),v("code",[_._v("XSS")]),_._v("。"),v("code",[_._v("DOM 型 XSS")]),_._v("跟前两种"),v("code",[_._v("XSS")]),_._v("的区别："),v("code",[_._v("DOM 型 XSS")]),_._v("攻击中，取出和执行恶意代码由浏览器端完成，属于前端"),v("code",[_._v("JavaScript")]),_._v("自身的安全漏洞，而其他两种"),v("code",[_._v("XSS")]),_._v("都属于服务端的安全漏洞。")]),_._v(" "),v("h3",{attrs:{id:"_19-xss攻击防御"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-xss攻击防御"}},[_._v("#")]),_._v(" 19."),v("code",[_._v("XSS")]),_._v("攻击防御")]),_._v(" "),v("ul",[v("li",[_._v("HttpOnly`")]),_._v(" "),v("li",[_._v("输入检查 ：在"),v("code",[_._v("XSS")]),_._v("的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如"),v("code",[_._v("＜、＞、’、”")]),_._v("，做转义")]),_._v(" "),v("li",[_._v("输出检查：和输入一样，转义")])]),_._v(" "),v("h3",{attrs:{id:"_20-get请求传参长度的误区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-get请求传参长度的误区"}},[_._v("#")]),_._v(" 20.get请求传参长度的误区")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("HTTP 协议 未规定 GET 和POST的长度限制")])]),_._v(" "),v("li",[v("p",[_._v("GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度")])]),_._v(" "),v("li",[v("p",[_._v("不同的浏览器和WEB服务器，限制的最大长度不一样")])]),_._v(" "),v("li",[v("p",[_._v("要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte")])])]),_._v(" "),v("h3",{attrs:{id:"_21-补充get和post请求在缓存方面的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-补充get和post请求在缓存方面的区别"}},[_._v("#")]),_._v(" 21.补充get和post请求在缓存方面的区别")]),_._v(" "),v("ul",[v("li",[_._v("get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。")]),_._v(" "),v("li",[_._v("post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。")])]),_._v(" "),v("h3",{attrs:{id:"_22-状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-状态码"}},[_._v("#")]),_._v(" 22.状态码")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("400状态码：请求无效")])]),_._v(" "),v("li",[v("p",[_._v("401状态码：当前请求需要用户验证，token过期")])]),_._v(" "),v("li",[v("p",[_._v("403状态码：服务器已经得到请求，但是拒绝执行 getpost方法不对")]),_._v(" "),v("h3",{attrs:{id:"_23-cookie如何防范xss攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-cookie如何防范xss攻击"}},[_._v("#")]),_._v(" 23.Cookie如何防范XSS攻击")])])]),_._v(" "),v("p",[_._v("XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：")]),_._v(" "),v("ul",[v("li",[_._v("httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。")]),_._v(" "),v("li",[_._v("secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);